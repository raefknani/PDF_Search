HOUSSEM SABRI
Graphes et Optimisation
2`emeannée
LISI  LSI
Institut Supérieur des Sciences Appliquées et de Technologie de Sousse
A.U. 2023-2024
28 novembre 2023Table des matières
1 Les graphes 3
1.1 Définitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.1 Graphes non orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.2 Graphes orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.2 Opérations et quelques types de graphes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.3 Représentation d’un graphe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.1 Listes d’adjacences (ou de succession) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.2 Matrices d’adjacence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.3.3 Matrice d’incidence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2 La connexité 11
2.1 Les chaînes et les cycles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.2 Graphe connexe, eulérien, hamiltonien . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.3 Arbres . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.3.1 Codage et décodage d’un arbre – Prüfer code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.3.2 Arbre couvrant de poids minimum – ACM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3 Les algorithmes de base 20
3.1 Parcours en profondeur (DFS) / largeur (BFS) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
3.2 Recherche des chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.1 Matrice d’adjacence et nombre de chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.2 Plus court chemin et l’algorithme de Dijkstra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
3.3 Problèmes d’ordonnancement et chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
3.3.1 Algorithmes de tri topologique et de chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . 25
4 Programmation linéaire 27
4.1 La méthode simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.1 Solution de base admissible . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux . . . . . . . . . . . . . . . . . . . . . . . . 29
4.1.3 Initialisation - Phase I du simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
4.2 Dualité . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
2CHAPITRE 1
Les graphes
L ’exemple classique pour introduire la théorie des graphes est le problème des ponts de Königsberg, étudié par
Euler en 1736. Quel itinéraire doit-on suivre pour traverser chaque pont exactement une fois? Une telle prome-
nade n’existe pas, et c’est Euler qui donna la solution de ce problème en caractérisant les graphes que l’on appelle
aujourd’hui eulériens .
A
B
Ce1 e2
e3 e4
De5
e6e7
FIGURE 1.1 – Les ponts de Königsberg
Les graphes introduisent une simplification : les régions se transforment en des "points" (aussi appelés noeuds
ousommet ), les ponts se transforment en des lignes (aussi appelées arêtes ouarcs ), et ce principe s’applique dès
lors qu’une relation existe entre des objets. Les graphes relèvent de la combinatoire plutôt que de la géométrie (les
intersections, les longueurs, et la forme des arêtes n’ont aucune importance, sauf en ce qui concerne la lisibilité de
la représentation).
1.1 Définitions
Dans la suite, il est toujours supposé que les graphes sont finis, sauf indication contraire.
1.1.1 Graphes non orientés
Définition 1.1: Graphe
Un graphe Gest un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V{2}des pairs non ordon-
nées de V.Vest l’ensemble des noeuds (Vertices en anglais) et Ec’est l’ensemble des arêtes de G(Edges en
anglais). Lorsque e={x,y} est une arête, on dit que x, y sont les extrémités de cette arête, que eest incidente
enxet en y. On joint x et y par un trait et on dit que x, y sont adjacents (ou voisins). On note aussi e=x you
encore e=(x,y) (attention , dans ce cas : ( x,y)=(y,x)).
SiGest un graphe alors, on note par V(G) l’ensemble de noeuds et par E(G) l’ensemble des arcs.
Remarque 1.
— Une arête e ={x,x}s’appelle boucle .
— Dans un graphe, il peut exister des arêtes parallèles (on parle donc de multigraphe ).
Dans l’exemple des ponts on a : e 1=e2=(A,B).
34 Chapitre 1. Les graphes
— Un graphe est dit simple s’il ne comporte ni arêtes multiples ni de boucles, c’est-à-dire chaque paire de nœuds
distincts est reliée par au plus une arête, ou encore E (G)⊆P2(G).
Dans la plupart des cas, les graphes sont considérés comme simples par défaut.
Définition 1.2: ordre – taille – degré
Soit G=(V,E) un graphe.
1. On appelle ordre d’un graphe noté v(G) le nombre de ses sommets :
v(G)= |V|
2. On appelle taille d’un graphe noté e(G) le nombre de ses arêtes :
e(G)= |E|
3. Le degré (ou valence) d’un sommet xnoté d(x) est le nombre d’arêtes contenant x. (Attention! Une
boucle sur un sommet compte double).
Si on note par Γ(x) l’ensemble des voisins de x, i.e.
Γ(x)={y∈V:x y∈E}
alors, siGest simple , on a :
d(x)= |Γ(x)|
Example 1.1 (Graphe complet)
Un graphe d’ordre nest dit complet noté Knsi chaque sommet du graphe est relié directement à tous les
autres sommets, i.e. E(Kn)=P2(V(Kn)).
Représenter graphiquement K3,K4,k5. Calculer la taille de K3,k4,...Kn.
Example 1.2 (Graphe biparti)
Un graphe G=(V,E) est dit biparti si son ensemble de sommets V=V1˙∪V2, i.e. peut être divisé en deux
sous-ensembles disjoints V1etV2tels que chaque arête ait une extrémité dans V1et l’autre dans V2.
Si∀x∈V1,∀y∈V2;x y∈E, alors Gest dit biparti complet noté Kn,moùn= |V1|etm= |V2|.
a1
 a2
 a3
 a4
b1
 b2
 b3
FIGURE 1.2 – Un graphe biparti
Théorème 1.1 Lemme des poignées de main – Handshaking lemma
Soit Gun graphe alors, on a :X
x∈V(G)d(x)=2e(G)
Dans ce théorème d(x) est le nombre de personnes à qui xserre la main et e(G) le nombre total de poignées
de mains.H. SABRI 5
Preuve.
•Méthode simple Il y en a d(x) arêtes en un sommet xfixé. Pour tout les sommets cela fait doncP
x∈V(G)d(x).
Mais avec cette manière chaque arête est comptée deux fois, une fois à chacune de ses extrémités, d’où le
résultat en divisant par 2.
•Preuve par double dénombrement On pose
Z={(x,e)∈V×E:x∈e}⊆V×E
et les deux projections :
p:Z→V
(x,e)7→xet q:Z→E
(x,e)7→e
L ’idée est de calculer |Z|de deux manières différentes. D’abord, on rappelle que si f:A→Best une fonction
quelconque, alors :X
b∈B|f−1[b]| = | A|
oùf−1[b] désigne l’image réciproque de { b} par f(pourquoi ˙S
b∈Bf−1[b] est une union disjointe ?).
Ainsi on obtient :
|Z| =X
x∈V|p−1[x]| =X
e∈E|q−1[e]|
Or,|p−1[x]| =d(x) et|q−1[e]| = |{x∈V:x∈e}| =2. Donc :
X
x∈Vd(x)=X
e∈E2=2|E|
Remarque 2.
— Un sommet de degré 0est appelé sommet isolé .
— Un graphe tel que : ∀x∈V,d(x)=kest dit graphe k-régulier .
— Le graphe complet K nest un graphe (n−1)-régulier .
Exercice 1.1
Montrer que dans un graphe le nombre de sommets d’ordre impairs est toujours pair. En particulier un
graphe k-régulier avec kimpaire est un graphe d’ordre pair.
Voici quelques exemples comme application :
1. Est-il possible de relier 15 ordinateurs en réseau de sorte que chacun soit relié à exactement 3 autres ?
2. Une ligue de football comprenant 11 clubs organise un tournoi. Pour gagner du temps on décide que chaque
équipe ne jouera que la moitié des matches possibles. Comment organiser le tournoi ?
Proposition 1.1
Soit G=(V,E) un graphe (simple) d’ordre n≥2. Alors :
∃u,v∈V,u̸=v:d(u)=d(v)
Preuve. Supposons le contraire, c’est-à-dire ∀u,v∈V;d(u)̸=d(v). Or dans un graphe (simple) on a toujours d(x)∈
{0,1,..., n−1}. Dans ce cas, puisque tous les nsommets ont des degrés distincts, alors il existe une bijection
{d(x):x∈V}←→ {0,1,..., n−1}
Donc, il existe un sommet uavec un degré 0, et un sommet vavec degré n−1, donc vest connecté à tous les autres
sommets du graphe, ce qui signifie que une peut pas être un sommet isolé, d’où une contradiction.6 Chapitre 1. Les graphes
1.1.2 Graphes orientés
Les arêtes d’un graphe peuvent être orientées, auquel cas une flèche indique la direction. De tels graphes sont
appelés des graphes orientés ou des digraphes , et une arête ( a,b) dans un tel graphe indique que cette arête est
dirigée de sommet avers b, i.e. ( a,b)=− →ab̸=(b,a)=− →ba. D’où la définition :
Définition 1.3: Graphe orienté - digraphe
Un graphe orienté G(ou− →G) est un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V2des pairs
ordonnées de V.Eest l’ensemble des arêtes (ou flèches, arcs) de G. Lorsque e=(x,y) est une arête, on dit
que xestl’origine (ou sommet initiale) et yl’extrémité (ou sommet terminale) de e, que eest sortant en x
et incident en y, et que yest un successeur de xtandis que xest un prédécesseur de y. On note l’arête e
par :
e=(x,y)=− →x y=x→y
De la même façon, une arête x→xest une boucle. On peut toujours supprimer les boucles pour obtenir des
digraphes simples. Voici l’exemple d’un digraphe G=(V,E) d’une fonction f:E→Eoù ( x,y) est un arc si et seule-
ment si y=f(x). On l’appelle digraphe fonctionnelle.
0
3
1214
11 568
169
4
2 1
713 10
15
FIGURE 1.3 – Le digraphe fonctionnelle Gfdex7→(x2+3) mod 17.
Comme dans les graphes on peut définir les degrés (entrant, sortant) d’un sommet dans un digraphe.
Définition 1.4: indegree - outdegree
Soit G=(V,E) un digraphe. Pour v∈V, on note par :
d+(v) le degré extérieur (sortant - outdegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité initiale.
d+(v)= |{v→ •}|
d−(v) le degré intérieur (entrant - indegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité finale.
d−(v)= |{• → v}|
On définit le degré : d(v)=d−(v)+d+(v).
Un sommet de degré entrant non nul et de degré sortant nul est appelé puits , tandis qu’un sommet de
degré entrant nul et de degré sortant non nul est appelé source ouracine .
Dans un graphe orienté, les voisins d’un sommet vsont soit des successeurs ou des prédécesseurs. On les notes
par :
Γ+(x)=Succ (x)={y∈V:x→y∈E} et Γ−(x)=Pr ed (x)={y∈V:y→x∈E}H. SABRI 7
Si le digraphe est simple (ni boucle ni arcs parallèles) on a :
d−(v)= |Γ−(v)|et d+(v)= |Γ+(v)|
Proposition 1.2
Soit Gun digraphe, alors :X
v∈Vd−(v)=X
v∈Vd+(v)= |E|
Preuve. On a
E=˙[
v∈V{• → v}=˙[
v∈V{v→ •}
=⇒ | E| =X
v∈V|{• → v}| =X
v∈V|{v→ •}| =⇒ | E| =X
v∈Vd−(v)=X
v∈Vd+(v)
1.2 Opérations et quelques types de graphes
Une opération sur les graphes permet de construire un nouveau graphe comme résultat de l’opération. Les
opérations courantes sur les graphes sont la suppression, la valuation, l’union, l’intersection et le produit cartésien.
Graphe valué
Tout d’abord, on peut vouloir attribuer des valeurs aux arcs ou arêtes pour tenir compte de contraintes : dis-
tance, coût ...
Définition 1.5: (di)graphe valué
Un (di)graphe valué G=(V,E,w) est un (di)graphe muni d’une application w:E→R. L ’application west
appelée application poids ou coût. On indique sur chaque arête son poids (ou son coût). On note w(x,y)
au lieu de w((x,y)). On convient (même que ceci n’a pas de sens!) que w(x,y)= +∞ si (x,y)∉E.
ab
c
d
ef53
43
3
335
81
FIGURE 1.4 – Un digraphe valué
/pythonPython code : -
Implémenter le digraphe valué précédent avec python. Indice – use chatGPT : how to build a weighted digraph with
python8 Chapitre 1. Les graphes
Sous graphes
Soit G=(V,E) un graphe (orienté ou non). Un sous graphe de Gest un graphe de la forme G′=(V′,E′) où
V′⊆V,E′⊆Etels que toute arête de E′a ses extrémités dans V′(ou encore G′est aussi un graphe). On a :
•Sous-graphe induit Un sous-graphe G′=(V′,E′) de G=(V,E) est appelé un sous-graphe induit deGsi :
∀x,y∈V′; (x,y)∈E′⇐⇒ (x,y)∈E
En d’autres termes, deux sommets de G′qui sont connectés dans G, sont également connectés dans G′.
•Sous-graphe couvrant Un sous-graphe couvrant G′deGcontient tous les sommets de G, i.e. V′=V.
•G−vSupprimer un sommet vd’un graphe Gconsiste à supprimer vet toutes ses arêtes incidentes. Le sous-
graphe obtenu de cette opération est noté G−v, i.e.
V′=V−{v} et E′=E−{(v,y): (v,y)∈E}
De manière similaire, une arête epeut être supprimée (resp. ajoutée) d’un graphe G, et le sous-graphe
résultant est représenté par G−e(resp. G+e). Notez que la suppression d’une arête ne retire pas de sommets
du graphe.
•G−V′=G[V′] On supprimer tous les sommets v∈V′du graphe Gavec les arêtes incidentes. Le sous-graphe
obtenu de cette opération est noté G[V′], i.e.
V(G[V′])=V−V′et E(G[V′])=E−{(v,y)∈E:v∈V′}
•Clique Une clique Cd’un graphe Gest un sous-ensemble des sommets de Gdont le sous-graphe induit G′=
(C,E′) est un graphe complet, en d’autres termes, deux sommets quelconques de la clique Csont toujours
adjacents.
•Stable Un stable – appelé aussi ensemble indépendant (independent set en anglais) est un ensemble de som-
mets deux à deux non adjacents. Donc le sous-graphe induit est sans arcs.
FIGURE 1.5 – L ’ensemble des sommets en bleu dans ce graphe est un stable maximal du graphe.
Note : -
Le problème décisionnel de la clique (c’est à dire existe t-il une clique de taille k) est NP-complet . De même la
recherche d’un stable de taille maximum dans un graphe est un problème NP-complet et difficile à approximer.
Exercice 1.2
Trouver un plus grand stable et une plus grande clique du graphe suivant :
8
4
62 7
3
1 5
Indice : vérifier le résultat avec networkx.find_cliques(G) et.maximum_independent_set(G) de python.H. SABRI 9
Opérations binaires
Union L ’union de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∪H=(VF,EF) dans lequel
VF=VG∪VH et EF=EG∪EH
Intersection L ’intersection de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∩H=(VF,EF)
dans lequel
VF=VG∩VH et EF=EG∩EH
1.3 Représentation d’un graphe
Il est important de savoir comment représenter les graphes au sein d’un ordinateur. Il ya plusieurs méthodes
selon la nature des traitements que l’on souhaite appliquer au graphe considéré.
1.3.1 Listes d’adjacences (ou de succession)
Soit Gun (di)graphe. On suppose que les sommets de Gsont numérotés de S1àSn. La représentation par listes
d’adjacence de Gconsiste en un tableau (ou des listes chainées) tel que la ligne i=1... ncorrespond au sommet Si
et comporte la liste des voisins/successeurs (ou des prédécesseurs) de ce sommet notée T[Si]. Les sommets dans
chaque liste d’adjacence sont généralement listés selon un ordre arbitraire.
1
2
345
FIGURE 1.6 – Un digraphe
La liste d’adjacence de digraphe 1.6 est donc :
1 2 3 4 5
2 3
3 4
4−
5 1 410 Chapitre 1. Les graphes
1.3.2 Matrices d’adjacence
Définition 1.6: Mat. Adjacence
Soit G=(V,E) un graphe (orienté) d’ordre n. On peut numéroter V={1,2,..., n}.La matrice d’adjacence
deGest la matrice carrée A=(ai j) d’ordre n, définie par :
ai j=(
1 si ( i j)∈E;
0 sinon.
Remarque 3.
1. Si le graphe G est non orienté et simple, alors la matrice A est symétrique avec des 0sur la diagonale. Pour un
digraphe simple, on a toujours des 0sur la diagonale, mais la matrice n’est pas symétrique en général.
2. Pour les multigraphes, il peut y avoir des termes diagonaux (pour les boucles) et s’il y a plusieurs arêtes de i à
j , le coefficient de la matrice a i jest le nombre d’arêtes de i à j .
3. Pour un (di)graphe valué G =(V,E,w), on pose :
ai j=(
w(i,j)si(i j)∈E ;
∞ sinon.
La matrice d’adjacence de la figure 1.4 est :

∞ 5∞ 4 3 ∞
∞ ∞ 3∞ 1∞
∞ ∞ ∞ ∞ ∞ 5
∞ ∞ 3∞ 3 3
∞ ∞ ∞ ∞ ∞ 8
∞ ∞ ∞ ∞ ∞ ∞

1.3.3 Matrice d’incidence
Définition 1.7: Mat. Incidence
Soit G=(V,E) un graphe (simple) d’ordre net de taille m. On pose V={v1,v2,..., vn} etE={e1,e2,..., em}.
La matrice d’incidence deGest la matrice de type n×m B=(bi j), définie par :
•Si G orienté
bi j=

1 si ej=vi→ • (i.e. viest l’extrémité initiale de ej) ;
−1 si ej= • → vi(i.e. viest l’extrémité terminale de ej) ;
0 sinon.
•Si G non-orienté
bi j=(
1 si viest une extrémité de ej;
0 sinon.
Exercice 1.3
1. Donner la matrice d’incidence du graphe 1.6.
2. Montrer le théorème 1.1 avec la matrice d’incidence.CHAPITRE 2
La connexité
Il est important de savoir si on peut suivre un chemin d’un sommet donné à un autre dans un graphe donné.
Cette propriété (de connexité) doit être maintenue dans différents types de réseaux.
2.1 Les chaînes et les cycles
Définition 2.1: (chaine – cycle) (chemin – circuit)
•Graphe non orienté
1. Une chaîne (walk ) reliant xày, notée µ(x,y), est définie par une suite finie d’arêtes consécutives,
reliant xày, ou encore une séquence de sommets (puisque non multigraphe)
µ(x,y)=<v0,v1,..., vk>
tels que v0=x,vk=yet (vi−1,vi)∈E(G) pour tout i=1... k. Six=yla chaîne est dite fermée .
Lalongueur du chaîne l(µ(x,y)) est le nombre d’arcs dans la chaîne, c’est-à-dire k.
2. Une chaîne élémentaire (a path ) si tous les sommets sont distincts. Une chaîne simple (a simple
walk, a trail ) est une chaîne ne passant pas deux fois par une même arête, c’est-à-dire dont toutes
les arêtes sont distinctes. Remarquer que : élémentaire =⇒ simple.
3. Un cycle v0v1...vnde longueur n≥3 est une chaîne simple fermée ( v0=vn) tel que les sommets
v0,v1,..., vn−1sont tous distincts. Un graphe sans cycle est dit acyclique .
•Graphe orienté
Dans un graphe orienté, on parlera de chemin au lieu de chaîne, et de circuit au lieu de cycle.
Example 2.1
abxcd xa est une chaîne simple et fermée (non cycle!) de longueur 6 (mais, c’est un graphe eulérien - voir
plus loin). Y a-t-il un cycle de longueur 3,4 ?
a b
x
c dÏ
Remarque 4.
1. On peut pivoter une chaine fermée (l’orienter de manière arbitraire) , i.e.
<v0,v1,v2,..., v0>=< vk,vk+1,..., v0,v1,..., vk>
1112 Chapitre 2. La connexité
2. Soient x ,y∈V . La distance de x à y est définie par :
d(x,y)=(
k si le plus court chemin/chaîne de x vers y est de longueur k
∞ sinon
On convient que d (x,x)=0.
3. Le diamètre du graphe la plus grande distance entre deux sommets.
L ’observation suivante, bien que très facile à prouver, sera utile.
Théorème 2.1
S’il existe une chaîne du sommet yau sommet zdans le graphe G, où y̸=z, alors il existe une chaîne élé-
mentaire ( path ) dans Gavec pour premier sommet yet pour dernier sommet z.
Preuve. Soit la chaine
W1=µ(y,z)=x0x1...xn; avec x0=yetxn=z.
Si les sommets x0,x1,..., xnsont tous distincts, alors W1est une chaîne élémentaire, et nous avons terminé. Sinon,
il existe xi=xj(i<j) et on écrit :
W2=x0x1...xixj+1...xn.
Alors, l(W2)<l(W1). Si W2ne contient aucun sommet répété, alors c’est la chaîne recherché. Sinon, par la même
procédure, il existe W3(y z−chaîne) tel que
l(W3)<l(W2)<l(W1).
Ce processus doit s’arrêter à un certain stade, car chaque chaîne est plus courte que la précédente et la longueur
ne peut jamais être inférieure à 1
1< ··· < l(Wk)< ··· < l(W3)<l(W2)<l(W1).
Ainsi, pour un certain k,Wkne peut pas être réduit en longueur. Donc, la chaîne Wkne contient aucun sommet
répété et est donc une y z−chaîne élémentaire (path).
Exercice 2.1
Dans le graphe suivant, construire un path à partir de la chaîne W=v2v3v4v5v6v4v2v8v1
v1
 v2
v3
v4
v5
v6
v7
 v8
 v9
Calculer d(v1,v7) et le diamètre de G.
/pythonpython : >>G = nx.Graph([(1, 2), (2, 3), (2, 4), ...]) >>nx.diameter(G)
Les cycles fournissent la caractérisation suivante pour les graphes bipartis .H. SABRI 13
Théorème 2.2
Un graphe est biparti si et seulement s’il ne contient aucun cycle de longueur impaire.
Preuve.
⇒On suppose que G=U˙∪Vest un graphe biparti. Soit W=< x1,x2,..., x2k+1,x1>un cycle de longueur im-
paire (2 k+1). Si x1∈U, alors
x1∈U=⇒ x2∈V=⇒ x3∈U=⇒ ··· =⇒ x2k+1∈U=⇒ x1∈V/exclamati⌢n-triangle
absurde, d’où le résultat.
⇐On suppose que Gest connexe (car l’union des composantes connexes bipartis est un graphe biparti). Soit
xun sommet de Get on pose :
U={y∈V(G):d(x,y) est paire} et V={z∈V(G):d(x,z) est impaire}
S’il existe y1,y2∈Utel que y1y2∈E(G), alors on a :
W1=<x,..., y1>est une chaîne de longueur paire =2k1
W2=<x,..., y2>est une chaîne de longueur paire =2k2
=⇒ W3=<x,..., y1,y2,..., x>est un cycle de longueur impaire =2k1+2k2+1/exclamati⌢n-triangle
Donc G=U˙∪Vest un graphe biparti.
Exercice 2.2
Vérifier si le graphe maison est un graphe biparti. Faire de même pour la grille G4,4.
maison grille
2.2 Graphe connexe, eulérien, hamiltonien
Définition 2.2: Graphe connexe
Un graphe est dit connexe si deux points peuvent toujours être joints par une chaîne, i.e.
∀x,y∈V(G),d(x,y)< ∞
— Une composante connexe d’un graphe est un sous-graphe induit maximal connexe.
— Un point d’articulation d’un graphe est un sommet dont la suppression augmente le nombre de
composantes connexes.
Par exemple, le graphe suivant :14 Chapitre 2. La connexité
a
 b
d
 c
e
f
 g
n’est pas connexe car il n’existe pas de chaîne entre les sommets aete. On a donc 2 composantes connexes. En
revanche, le sous-graphe induit par les sommets { a,b,c,d} est connexe dont aest le seul point d’articulation.
Remarque 5.
1. Un graphe connexe à n sommets possède au moins n −1arêtes ( faite une preuve par récurrence ).
2. L’algorithme de parcours en profondeur permet de déterminer si un graphe est connexe ou non.
3. Même définitions dans un graphe orienté . Graphe orienté (fortement) connexe et de composante connexe .
Définition 2.3: Graphe eulérien
— Une chaîne joignant deux sommets xetyest dite chaîne eulérienne si elle emprunte chaque arête
deGune et une seule fois. On parle de chemin eulérien dans le cas d’un graphe orienté.
— Un cycle eulérien est une chaîne eulérienne dont les extrémités coïncident. Un graphe qui admet
un cycle (resp. circuit) eulérien est dit graphe eulérien .
/flushedRemarquer qu’un cycle eulérien n’est pas forcément un cycle comme définit dans la définition 2.1
Si un graphe (ou multigraphe) Gpossède une chaîne eulérienne, alors soit Gpossède deux sommets impairs, le
début et la fin de cette chaîne, soit Gn’a aucun sommet impair, et la promenade d’Euler commence et se termine
au même point (cycle eulérien). Une autre condition nécessaire évidente est que Gdoit être connexe. Ces deux
conditions sont ensemble suffisantes.
Théorème 2.3 Euler
Soit Gun graphe (multigraphe) connexe.
— Si Gn’a pas de sommets impairs, alors il possède un cycle eulérien (commençant à n’importe quel
point).
i.e.∀x,d(x)≡0 mod 2 =⇒ Gest un graphe eulérien.
— Si Ga deux sommets impairs, alors il possède une chaîne eulérienne dont le début et la fin sont les
sommets impairs.
La réciproque est aussi vraie.
Preuve.
⇐On commence par la réciproque. S’il existe une chaîne eulérienne µ(x,y), alors on peut crée une arête fictive
e=(y,x) et par la suite on obtient un cycle eulérien. Donc il suffit de montrer que si Gadmet un cycle
eulérien alors tous les sommets sont de degré pair.
Soit W=< v1,v2,..., vn,v1>un cycle eulérien. Soit le sommet vjavec j̸=1, il est donc claire que chaque
fois vjapparaît dans W, il ya deux arcs distincts incidents en vj( (•,vj) et ( vj,•)). Comme toutes les arêtes
sont utilisées, on voit que d(vj) est pair. Même chose pour v1car on ajoute deux arcs ( v1,v2) et ( v1,vn).
⇒On suppose que tous les sommets sont de degré pair. Montrons que Gadmet un cycle eulérien. Puisque
tous les sommets sont de degré pair on peut construire d’abord une chaîne simple fermée (quelconque)
W1=<v1,v2,..., vk,v1>
SiW1contient chaque arête de G, alors c’est finis, c’est un cycle eulérien. Sinon (puisque Gest connexe), il
existe une arête e=(vi,c) qui n’est pas dans W1(avec visommet de W1). On pose le sous-graphe
G′=G−{ arêtes de W1}H. SABRI 15
Il est donc claire que les sommets de G′sont aussi de degré pair. Alors, par la même procédure on construit
une chaîne simple fermée dans G′de la forme : <vi,c,d,..., vi>et par la suite on insère cette chaîne dans
W1pour obtenir :
W2=<v1,v2,..., vi,c,d,..., vi,vi+1,..., vk,v1>
Sil(W2)< |E(G)|, on construit W3de longueur plus grand. Ainsi, on a :
l(W1)<l(W2)<l(W3)< ··· ≤ | E(G)|
Donc, nécessairement, il existe Wk(chaîne simple fermée de longueur |E(G)|) donc c’est un cycle eulérien.
Finalement , si∃a,b∈V(G):d(a)≡d(b)≡1 mod 2, et tous les autres sommets sont de degré pair, alors on
pose :
G′=G+{a,b}
et donc tous les sommets de G′sont de degré pair. Avec la construction précédente, il existe un cycle eulérien
dans G′:
W=<a,b,v1,..., a>
est donc la chaîne <b,v2,..., a>est une chaîne eulérienne dans G.
Algorithme 1 : Euler
Entrées : Gun graphe eulérien
Output : Un cycle eulérien W
/* On suppose que G est eulérien, i.e. les sommets sont de degré pair */
1Gaux←G;W←µ(v,v) une chaîne simple (quelconque) de G; // Initialisation
2tant que l(W)<e(G)faire
3 Gaux←G−{ arêtes de W} ;
4 Choisir ( x,c)∈E(Gaux) tel que x∈W;
5 L←< x,c,..., x>une chaîne simple de Gaux ;
6 Dans W, remplacer (juste ce) xpar la séquence L;
7fin
8retourner W;
Exercice 2.3
1. Montrer que le graphe de l’exercice 2.1 est un graphe eulérien et donner un cycle eulérien.
2. Tracer cette maison d’un seul trait.
Remarque 6. Le théorème d’Euler dans un graphe orienté connexe s’écrit :
Admet un circuit eulérien si, et seulement si, pour tout sommet, le degré entrant est égal au degré sortant.
∀v∈V(G),d+(v)=d−(v)
Admet un chemin eulérien de a vers b si, et seulement si,


d+(v)=d−(v) ;∀v̸=a,b,
d−(a)=d+(a)−1
d−(b)=d+(b)+116 Chapitre 2. La connexité
Définition 2.4: Graphe hamiltonien
Soit Gun graphe connexe d’ordre n. On appelle :
1. On appelle cycle hamiltonien deGun cycle passant (une et une seule fois) par chacun des sommets
deG. Un graphe est dit hamiltonien s’il possède un cycle hamiltonien.
2. Une chaîne hamiltonienne est une chaîne passant une et une seule fois par chacun des sommets de
G. Un graphe ne possédant que des chaînes hamiltoniennes est semi-hamiltonien .
3. Dans un digraphe, on change cycle par circuit et chaîne par chemin .
Remarque 7.
— Une chaîne hamiltonienne est une chaîne élémentaire de longueur n −1.
— Un graphe peut être eulérien, hamiltonien, les deux à la fois, ou aucun des deux.
— De nombreux problèmes concrets peuvent être formulés en termes de recherche de parcours hamiltoniens : pro-
blème du voyageur de commerce (chercher un cycle hamiltonien de longueur totale minimale), l’ ordonancement
de tâches .
— Le problème du chaîne hamiltonienne est un problème NP-complet .
Exercice 2.4
Donner un graphe (connexe, simple) qui soit :
1. hamiltonien et eulérien.
2. hamiltonien et non eulérien.
3. eulérien et non hamiltonien.
4. non hamiltonien et non eulérien.
Aucune condition nécessaire et suffisante adéquate n’est connue pour l’existence de cycles hamiltoniens. Le
résultat suivant constitue une condition suffisante utile.
Théorème 2.4 Ore
Soit Gun graphe simple d’ordre n≥3. Si pour toute paire { x,y} de sommets non adjacents, on a d(x)+d(y)≥
n, alors Gest hamiltonien.
Preuve. On suppose que le théorème est faux. Alors, il existe un graphe Gsimple d’ordre nnon hamiltonien tel que
d(u)+d(v)≥npour tout sommets non adjacents uetv. On prend Gun tel graphe d’ordre nde taille maximale qui
vérifie cette propriété (remarquer que le graphe complet Knest hamiltonien).
Soient uetvdeux sommets non adjacents de G. Par maximalité de G, le graphe G+uv(d’ordre n) doit être
hamiltonien. Donc il existe dans G+uvun cycle hamiltonien :
W=<u,x1,x2,..., xn−2,v,u>
u
x1
xi xi+1xn−2
v
... ...
Or, si uxi+1∈E(G) etv xi∈E(G) (les arcs en rouge), alors on peut construire dans Gle cycle hamiltonien :
<u,x1,x2,..., xi,v,xn−2,..., xi+1,u>H. SABRI 17
Ceci est absurde car Gest non hamiltonien. Donc si xi+1est un sommet voisin à u, alors le sommet xin’est pas
voisin de v:
xi+1∈Γ(u)=⇒ xi∉Γ(v)
Donc :
d(u)= |Γ(u)| =p=⇒ d(v)≤(n−1)−p
et par la suite
d(u)+d(v)≤n−1
ce qui absurde par hypothèse. Donc Gest hamiltonien.
Une conséquence immédiate est le théorème de Dirac :
Proposition 2.1 Dirac
Soit Gun graphe simple d’ordre n≥3. Si pour tout sommet xdeG, on a d(x)≥n
2, alors Gest hamiltonien.
2.3 Arbres
Définition 2.5: Arbres et forêts
On appelle arbre tout graphe (non orienté) connexe et acyclique . Les composantes connexes dans un
graphe acyclique sont des arbres et le graphe est dit forêt . Une feuille ou sommet pendant est un som-
met de degré 1.
Un forêt avec deux arbres
Un graphe Gest une arborescence s’il existe un sommet Rappelé racine deGtel que, pour tout sommet
SdeG, il existe un chemin et un seul de Rvers S. Donc, c’est un arbre orienté dans lequel on choisit un
sommet Rcomme racine et on dirige les arcs vers le sens sortant de la racine.
Remarque 8.
— Un graphe G d’ordre n est un arbre ssi G est sans cycle et possède n −1arêtes.
— Un graphe G d’ordre n est un arbre ssi G est connexe et possède n −1arêtes.
— G est un arbre si pour chaque paire u ,v de sommets distincts est reliée par une seule chaîne (donc chaîne
élémentaire d’après le théorème 2.1).
— Un arbre (ou forêt) est nécessairement un graphe simple.
Pour démontrer les remarques précédentes, il suffit de prouver le théorème suivant :
Théorème 2.5
Soit Gun graphe ayant marêtes, nsommets et pcomposantes connexes, on définit nu( G) :
ν(G)=m−n+p
Alors, on a :
1.ν(G)≥0.
2.ν(G)=0⇐⇒ Gest acyclique.18 Chapitre 2. La connexité
Preuve. Par récurrence sur la taille mdu graphe. Le résultat est évident pour m=0 et m=1. On suppose le résultat
est vrai pour les graphe de taille m, et montrons que ceci est vrai pour un graphe de taille m+1. Soit donc Gun
graphe d’ordre nde taille m+1 ayant pcomposantes connexes.
•On suppose que Gest un graphe acyclique. Soit uvune arête de Gdans la composante C. Si on supprime uv,
la composante Cse transforme en deux composantes connexes (sinon on a un cycle dans G). Par la suite,
le graphe G′=G−uvest un graphe acyclique d’ordre n, de taille met ayant p+1 composantes connexes.
Donc d’après l’hypothèse de récurrence :
ν(G′)=0=(m−1)−n+(p+1)=m−n+p=ν(G)
•Maintenant, si Gcontient un cycle Wdans la composante connexe C. Soit uvune arête de W, alors si on
supprime l’arête uv, la composante Creste connexe. Donc le graphe G′=G−uvest un graphe d’ordre nde
taille m−1 ayant pcomposantes connexes. Donc, d’après l’hypothèse de récurrence :
ν(G′)=(m−1)−n−p≥0
=⇒ν(G)=m−n−p≥1>0
D’où le résultat – car si ν(G)=0,Gne peut être que acyclique, sinon 0 =ν(G)≥1/exclamati⌢n-triangle
2.3.1 Codage et décodage d’un arbre – Prüfer code
Soit Tun arbre ayant nsommet numérotés {1,2,..., n}. Le codage de Prüfer représente l’arbre Tarbre de avec
une suite P=(x1,x2,x3,..., xn−2) de n−2 termes (les n° des sommets avec répétition possible). Une suite Pdonnée
correspond à un et un seul arbre numéroté. Voici les algorithmes de codage et de décodage.
Algorithme 2 : Codage de Prüfer
Entrées : Un arbre T
Output : Séquence de Prüfer P
1P←() ; // Initialisation de P comme séquence vide
2tant que v(T)>2faire
3 x←feuille de Tayant le n° minimum ; // donc d(x)=1
4 P←(P,s) où sest le seul (n°) sommet adjacent à x;
5 T←T−x;
6fin
7retourner P;
Example 2.2
Donner le code de Prüfer de l’arbre :
126 345
Indice : on trouve, P=(2,3,3,2)
Pour faire la réciproque, étant donnée une séquence P=(x1,x2,..., xn−2) où les xi∈{1,2,..., n}, on construit
l’arbre Tdont les sommets sont {1,2,..., n} avec l’algorithme suivant (le décodage) :H. SABRI 19
Algorithme 3 : Décodage de Prüfer
Entrées : Une séquence Pde taille n−2
Output : L ’arbre Tcorrespondante
1I←{1,2,..., n};
2T←graphe tel que V(T)=IetE(T)= ; ; // T graphe à n sommets isolés
3tant que P̸=()faire
4 i←min {x∈I:x∉P};
5 T←T+(i,P[1]) ; // ajouter l'arc (i,P[1])
6 P←P−P[1];I←I−{i};
7fin
8T←T+(a,b) ; // a,b sont les deux éléments restant dans I
9retourner T;
Example 2.3
Donner l’arbre dont le code de Prüfer est : P=(2,3,3,3)
Puisqu’il ya une bijection entre les arbres d’ordre net les suites Pde longueur n−2 à coefficients dans {1,2,..., n},
on déduit le théorème de Cayley :
Théorème 2.6 Formule de Cayley
Le nombre d’arbres que l’on peut construire sur n(n≥2) sommets numérotés est égal à nn−2.
2.3.2 Arbre couvrant de poids minimum – ACM
Soit Gun graphe (non orienté). Un arbre couvrant (spanning tree) TdeGest un sous graphe couvrant de G
tel que Test un arbre. Remarquer que, Gdoit être connexe, sinon un arbre couvrant de Gn’existe pas. Le nombre
des arbres couvrant de Gest noté a(G). Remarquer que a(Kn)=nn−2(le nombre de Cayley). Un problème algo-
rithmique classique est de trouver, dans un graphe valué , un arbre couvrant de poids minimal . On dispose de
plusieurs algorithmes (l’algorithme de Prim, l’algorithme de Kruskal ...).
Algorithme 4 : Kruskal
Entrées : Un graphe Gvalué d’ordre net de taille m
Output : Arbre (ou forêt) couvrant de poids minimum
1Numéroter les arêtes de Gpar poids minimum : w(e1)≤w(e2)≤ ··· ≤ w(em)
2T←graphe tel que V(T)=V(G) etE(T)= ; ; // T graphe à n sommets isolés
3k←0;
4tant que k<m et e (T)<n−1faire
5 siT+ek+1est acyclique alors
6 T←T+ek+1;
7 k←k+1;
8fin
9retourner T;
Appliquer l’algorithme de Kruskal dans le graphe suivant :
CHAPITRE 3
Les algorithmes de base
Beaucoup de problèmes sur les graphes nécessitent que l’on parcourt l’ensemble des sommets et des arcs. Par
exemple, pour vérifier que le graphe est connexe, chercher un sommet particulier, construire un arbre couvrant,
trouver un plus court chemin ...etc.
3.1 Parcours en profondeur (DFS) / largeur (BFS)
Une manière simple de tester si un graphe Gest connexe ou non est d’exécuter l’algorithme DFS ouBFS dans
Gen commençant par n’importe quel sommet et en enregistrant les sommets visités pendant l’exécution dans une
liste. Si la liste contient tous les sommets de G, alors Gest connexe. Une petite modification permet de donner les
composantes connexes de G. L ’algorithme DFS_Component suivant donne les composantes connexes de G. Il est
donné sous forme d’implémentation récursive.
Algorithme 5 : DFS_Component
Entrées : Un graphe G=(V,E)
Output : Les composantes connexes C=(C1,C2,..., Ck) de G.
1VisitedNodes ← ; ;
2k←0 ; // k est le nombre des composantes connexes
3pour chaque u∈Vfaire
4 siu∉VisitedNodes alors
5 k←k+1;
6 DFS( u);
7 fin
8fin
9retourner (C1,C2,..., Ck);
1Procedure DFS( u )
2 VisitedNodes ←VisitedNodes ∪{u};
3 Ck←Ck∪{u};
4 pour chaque x∈Γ(u)faire
5 six∉VisitedNodes alors
6 DFS( x);
7 fin
8 fin
Note : -
Il est possible de d’implémenter la procédure DFS itérativement à l’aide d’une pile LIFO (stack) contenant les
sommets à explorer : on désempile un sommet et on empile ses voisins non encore explorés.
20H. SABRI 21
Pseudocode :
stack . push ( root )
while stack . isEmpty ( ) = f a l s e do
node = stack . pop ( ) // so mark i t as v i s i t e d
for each x in node . childNodes do
i f x i s not v i s i t e d then
stack . push ( x )
. . .
endfor
endwhile
Example 3.1 (DFS )
Ici on empile (gris) les sommets les plus à droite, alors l’ordre des sommets visité (noir) est ( a,b,d,e,g,c,f).
Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b
 c
d
 e
f
g
a
b
 c
d e
f
ga
b
 c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g
L ’utilisation d’une file (FIFO) au lieu d’une pile transforme l’algorithme du parcours en profondeur en algo-
rithme de parcours en largeur ( BFS ). Avec BFS l’exemple précédent devient (en enfile le plus à gauche) :
Example 3.2 (BFS )
Ici, avec BFS, on enfile (gris) les sommets les plus à gauche d’abord, alors l’ordre des sommets visité (noir)
est ( a,b,d,e,g,c,f). Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b c
d
 e
f
g
a
b c
d
 e
f
ga
b c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g22 Chapitre 3. Les algorithmes de base
Exercice 3.1
1. Écrire la procédure BFS .
2. Utiliser DFS (ou BFS) pour la construction d’un arbre couvrant d’un graphe connexe. L ’appliquer
pour le graphe triangle.
3. Utiliser DFS pour écrire une procédure DFS_Cycle pour détecter un cycle dans un graphe.
On sait qu’un graphe orienté G=(V,E) est fortement connexe si pour chaque paire de sommets u,v∈V, il
existe un chemin de uàvet il existe un chemin de vàu. En d’autres termes, nous avons besoin d’une connectivité
dans les deux directions .
Une procédure pour tester si un graphe orienté est fortement connexe ou non peut être conçue avec l’idée
suivante. En partant d’un sommet arbitraire vdu graphe G, on exécute l’algorithme BFS ouDFS et l’on note les
sommets visités. Ensuite, on obtient la transposée de G,GT, en inversant la direction des arêtes de G, et l’on
exécute à nouveau l’algorithme BFS ou DFS à partir du sommet v. Si les sommets visités dans les deux cas sont
égaux à V, alors le graphe orienté est fortement connexe. Cette méthode est illustrée dans l’algorithme 6.
Algorithme 6 : Fortement_connexe
Entrées : Un graphe orienté G=(V,E)
Output : true siGest fortement connexe et false sinon
1X← ; ;
2Y← ; ;
3v←un sommet quelconque de V;
4X←DFS( G,v) ; // Enregistrez les sommets visités dans X
5GT←Gavec flèches inversées;
6Y←DFS( GT,v);
7siX=Y=Valors
8 retourner TRUE.
9sinon
10 retourner FALSE.
11fin
3.2 Recherche des chemins
3.2.1 Matrice d’adjacence et nombre de chemins
La puissance de la matrice d’adjacence Amontre qu’il y a des chemins (ou chaînes) de longueur kallant de xà
ycomme le montre le théorème suivant.
Théorème 3.1
Soit G=(V,E) un (di)graphe. On note V={1,2,..., n} et Asa matrice d’adjacence et Akla puissance k-ème
deA. Alors le terme d’indices i,jdeAkest le nombre de chemins (chaînes) de longueur kallant de iàj.
Preuve. Par récurrence sur k. Pour k=1 c’est clair. On suppose le résultat est vrai à l’ordre ket montrons qu’elle
est vrai pour k+1. Soit S=(si,j)=Ak. Si on a un chemin de iàjde longueur k+1, alors on va d’abord de ià un
sommet ravec kpas et puis de ràj. Or d’après l’hypothèse de récurrence on a si,rchemins possibles pour aller de
iàret finalement ar,jpas (1 ou 0) pour aller de ràj. Ainsi, le nombre totale possibles (i.e. tous les sommets r) est :
nX
r=1si,rar,j=³
Ak×A´
i,jH. SABRI 23
ce qui est bien le terme ( i,j) de la matrice Ak+1.
3.2.2 Plus court chemin et l’algorithme de Dijkstra
Dans cette partie on suppose que le (di)graphe G=(V,E,w) est valué positivement (i.e.∀e∈E,w(e)>0). Notre
objectif est de chercher un plus court chemin (i.e., un chemin de poids minimal ) d’un sommet ufixé à un sommet
quelconque de G.
Il est clair que l’on peut restreindre ce problème au cas d’un (di)graphe simple1. On suppose aussi que Gest
connexe (sinon, certains trajets sont impossibles). Il est aussi claire (d’après théorème 2.1), qu’un plus court chemin
est nécessairement un chemin élémentaire (path).
L ’algorithme de Dijkstra (1959) permet de calculer le plus court chemin entre un sommet particulier u(racine )
et tous les autres sommets. L ’algorithme fonctionne de la manière suivante :
Pour tout sommet vdeG, on associe une valeur T(v), initialisée à w(u,v) et une liste de sommets C(v) qui
correspond à un chemin de uàv. À la fin de l’algorithme, T(v) contient le poids minimal des chemins joignant uà
v(ou T(v)= ∞ siu↛v) et la liste C(v) réalise un tel chemin. Voici donc l’algorithme de Dijkstra :
Algorithme 7 : Algorithme de Dijkstra
Entrées : Un (di)graphe valué G=(V,E,w) et un sommet racine u
Output : Le coût minimum d’un chemin de uàv(∀v∈V) et un trajet pour chaque coût minimal obtenu
1∀v∈V,T(v)←w(u,v) etC(v)←(u,v); // Initialisation de T(v) et la liste C(v)
2X←{u};
3tant que X̸=Vfaire
4 Choisir v∈V−Xtel que ∀y∈V−X,T(v)≤T(y);
5 X←X∪{v};
6 pour chaque y∈V−Xfaire // Faire les mises à jours pour les autres sommets
7 siT(y)>T(v)+w(v,y)alors
8 T(y)←T(v)+w(v,y);
9 C(y)←[C(v),y]; // On ajoute à la liste C(v) l'élément y
10
11 fin
12 fin
13fin
Example 3.3
Voici une application de l’algorithme de Dijkstra au digraphe suivant. On prend Ecomme sommet racine.
EA
B
CD
FG
S5
4
21
12
2
34
4
215
7
1. En effet, passer par une boucle ne ferait qu’augmenter inutilement le poids de ce chemin. De même, si plusieurs arcs joignent deux
sommets, il suffit de conserver l’arc de poids minimal.24 Chapitre 3. Les algorithmes de base
Ainsi, pour l’initialisation, on a : X={E} et on a les valeurs :
v  E A B C D F G S
T(v) 0 5 4 2 ∞ ∞ ∞ ∞
C(v)(E,E) ( E,A) ( E,B) ( E,C) ( E,D) ( E,F) ( E,G) ( E,S)
Maintenant, on choisit (un seul choix) le sommet C, donc X={E,C}. Le tableau est mis à jour :
v  E A B  C D F G S
T(v) 0 5 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À l’étape suivante, on est forcé de choisir B. Ainsi, X={E,C,B} et la mise à jour est :
v  E A  B  C D F G S
T(v) 0 4 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À présent, on a le choix entre AetF. On choisit A. Donc X={E,C,B,A} et on a :
v  E  A  B  C D F G S
T(v) 0 4 3 2 6 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,B,A,D) ( E,C,F) ( E,C,G) ( E,S)
Puis, on prend le sommet F. D’où X={E,C,B,A,F} et :
v  E  A  B  C D  F G S
T(v) 0 4 3 2 5 4 5 11
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,S)
On prend Det on obtient X={E,C,B,A,F,D} et :
v  E  A  B  C  D  F G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Finalement, on prend Gpuis Set on voit que ceci ne change rien. D’où le tableau finale :
v  E  A  B  C  D  F  G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Ainsi le chemin minimum pour aller de EàSest de coût 10 et un trajet de coût minimal de EàSest : EC F DS .H. SABRI 25
3.3 Problèmes d’ordonnancement et chemin critique
Un problème d’ordonnancement peut-être représenté sous la forme d’un digraphe. Les sommets sont des évé-
nements (début et fin de la tâche) et les arcs des tâches, La longueur (ou poids) de chaque arc représente la durée
d’exécution de la tâche. Ainsi, la tâche correspondant à l’arc ( i,j) ne peut commencer que si toutes les tâches cor-
respondant à des arcs ( k,i) ont été complétées. On ajoute deux sommets pour le début (s) et de fin(t) du projet .
Le digraphe peut contenir des tâches fictives dedurée nulle afin de forcer certaines précédences (postériorité).
Ainsi, un réseau PERT est un digraphe valué G=(V,E,w,s,t) où la fonction poids (ou longueur) w:E→R+
etsle sommet source (début) et tle sommet puits (fin). Un chemin critique est un chemin de sàtdelongueur
maximale . S’il n’existe pas de chemin critique, le projet n’est pas réalisable (e.g. un circuit). Le temps minimal
requis pour l’exécution d’un projet réalisable est égal à la longueur d’un chemin critique. Les tâches figurant sur un
chemin critique sont aussi appelées critiques, ce qui s’explique par le fait que tout retard d’exécution d’une tâche
critique retarde d’autant l’exécution du projet.
3.3.1 Algorithmes de tri topologique et de chemin critique
Il faut d’abord numérotés les sommets de 1 à nde manière compatible au pré-ordre (rang) avec l’algorithme du
rang suivant (tri topologique) :
Algorithme 8 : Algorithme du rang
Entrées : Un digraphe G=(V,E) sans circuit
Output : Le rang r(v) de chaque sommet v∈Vde G
1r←0;X←V;
2R←{v∈X:Γ−
X(v)= ;} ; // l'ensemble des sommets de X sans prédécesseur dans X
3tant que X̸= ; faire
4 r(v)←rpour chaque sommet v∈R;
5 X←X−R;
6 R←l’ensemble des sommets de Xsans prédécesseur dans X;
7 r←r+1;
8fin
On supposera dorénavant que les sommets ont déjà été numérotés de 1 à nde manière compatible avec leurs
rangs, c’est-à-dire que r(j)>r(i) implique j>i(donc 1 =setn=t). Enfin, on supposera éliminés les arcs paral-
lèles par l’introduction de tâches fictives de durée nulle .
Pour un sommet i, on note tiledébut au plus tôt des tâches correspondant aux arcs i→jet par Tilafin au
plus tard des tâches correspondant aux arcs j→i.
Algorithme 9 : Algorithme du chemin critique
Entrées : Un digraphe G=(V,E) sans circuit trié topologiquement
Output : La durée du chemin critique et les dates ti,Ti
1t1←0;
2pour j=2···nfaire // Calcul des dates de début au plus tôt  récurrence en avançant
3 tj←max i∈Γ−(j){ti+w(i,j)}
4fin
5Tn←tn;
6pour j=n−1···1faire // Calcul des dates de fin au plus tard  récurrence en reculant
7 Tj←min i∈Γ+(j){Ti−w(j,i)}
8fin26 Chapitre 3. Les algorithmes de base
Définition 3.1
— Un sommet iest critique si ti=Ti.
— Un arc ( i,j) est critique les sommets ietjsont critiques ettj−ti=w(i,j).
— Un chemin critique est un chemin de 1 à nn’utilisant que des arcs critiques.
— La durée du chemin critique est donnée par Tn(ou par tn). Elle correspond à la durée minimale du
projet .
Example 3.4
L ’application de l’algorithme du chemin critique au digraphe suivant (trié topologiquement) est :
1 23
45
6B
9A
3
C
5D
8
E
4
F7G
20
H6I5
=⇒
 1
0,02
9,933,16
4
16,23513,24
6
29,29B
9A
3
C
5D
8
E
4
F7G
20
H6I5
Les tâches critiques sont BetG. La durée totale minimale du projet est donc 29.
Exercice 3.2
Les tâches ( durée et précédences ) pour la construction d’un entrepôt sont données dans le tableau suivant :
Tâches Nature Précédences Durée (jours)
A Acceptation des plans par le propriétaire – 4
B Préparation du terrain – 2
C Commande des matériaux A 1
D Creusage des fondations A, B 1
E Commande des portes et fenêtres A 2
F Livraison des matériaux C 2
G Coulage des fondations D, F 2
H Livraison des portes et fenêtres E 10
I Pose des murs, de la charpente et du toit G 4
J Mise en place des portes et fenêtres H, I 1
1. Représentez le graphe des précédences de ce projet (trié topologiquement).
2. Déterminez une durée totale minimale en exhibant un chemin critique dans ce graphe.CHAPITRE 4
Programmation linéaire
La programmation linéaire est le processus de minimiser ou maximiser une fonction objective linéaire sou-
mise à un nombre fini de contraintes d’égalités et d’inégalités linéaires.
La programmation linéaire a de nombreuses applications dans le domaine de l’informatique théorique. Elle
peut être utilisée pour résoudre de nombreux problèmes combinatoires variés, tels que la recherche de flot maxi-
mum dans un réseau, la recherche d’un couplage maximal dans un graphe et la coloration d’un graphe parfait.
Example 4.1 (Problème de régime)
On suppose qu’on a quatre plats : de la truite ( XT), un sandwich au corned-beef ( XC B), un burrito ( XBU R )
et un hamburger ( XHB). Le tableau suivant répertorie la valeur nutritionnelle de chaque plat (vitamines et
calories) et notre besoin journalier des vitamines.
Vit. A Vit. C Vit. D Calories
Truite 203 92 100 600
Corned-beef 90 84 230 350
Burrito 270 80 512 250
Humburger 500 90 210 500
Besoins 2000 300 430
Notre objectif est de minimiser le nombre total de calories consommées : 600 XT+350XC B+250XBU R+
500XHBtout en satisfaisant les trois besoins nutritionnels en vitamines. Le programme linéaire résultant
s’écrit :
min 600 XT+350XC B+250XBU R+500XHB
s.t. 203 XT+90XC B+270XBU R+500XHB≥2000, (Besoins de Vit. A),
92XT+84XC B+80XBU R+90XHB≥300, (Besoins de Vit. C),
100XT+230XC B+512XBU R+210XHB≥430, (Besoins de Vit. D),
XT,XC B,XBU R ,XHB≥0
Définition 4.1: Forme canonique – Forme standard
On peut écrire un P .L. sous deux formes spéciales :
•Canonique
max
mincTX+c0
s.t. AX≤b(≥bsi min),
X≥0•Standard
max cTX+c0
s.t. AX=b,
X≥0Avec :
cTX=¡
c1··· cn¢
x1
...
xn

cTX+c0=c1x1+c2x2+···+ cnxn+c0
2728 Chapitre 4. Programmation linéaire
Remarque 9. Un P .L. général peut être formulé selon une forme standard ou canonique par la méthode suivante :
générale =⇒ standard il faut éliminer les contraintes d’inégalité et les variables sans contrainte de positivité.
— Si dT
iX≤biest une contrainte d’inégalité, alors créer une nouvelle variable ( d’écart ) siet remplacer l’in-
égalité dT
iX≤bipar dT
iX+si=biet s i≥0.
Si dT
iX≥bi, alors on peut écrire dT
iX−si=biet s i≥0.
— Si une variable x i≶0est de signe quelconque, alors créez deux nouvelles variables x+
iet x−
iet remplacez
xipartout par x+
i−x−
i, et ajoutez les contraintes de signe : x+
i≥0,x−
i≥0.
générale =⇒ canonique
— Si dT
iX=biest une contrainte d’égalité, alors remplacer cette égalité par une paire d’inégalités :
dT
iX≥biet−dT
iX≥ −bi
— Même chose que précédemment si la variable x i≶0.
Il est facile de voir que les problèmes qui en résultent sont équivalents aux problème d’origine. Pour l’algorithme
simplexe , nous utiliserons la forme standard .
On remarque aussi qu’en utilisant la relation min f(x)= − max¡
−f(x)¢
dans laquelle f (x)représente la fonction-
nelle linéaire à optimiser, on peut toujours se ramener à un problème de minimisation (ou de maximisation).
Example 4.2
Le P .L :max 5 x+4y
s.t. x≤6
1
4x+y≤6
3x+2y≤22
x,y≥0s’écrit sous forme standard :max 5 x1+4x2
s.t. x1+e1=6
1
4x1+x2+e2=6
3x1+2x2+e3=22
x1,x2,e1,e2,e3≥0
Donc (sous la forme matricielle) on a :
cT=¡
5 4 0 0 0¢
;A=
1 0 1 0 0
1
41 0 1 0
3 2 0 0 1
;X=
x1
x2
e1
e2
e3
et b=
6
6
22

4.1 La méthode simplexe
4.1.1 Solution de base admissible
On suppose que la matrice Adu programme linéaire est de type m×netde rang m(pourquoi !). Soit Bla
matrice carrée extraite de Aformée par les mcolonnes j1,j2,..., jmlinéairement indépendants de A(les vecteurs
de base). Alors, Best une matrice inversible. Ainsi si on pose xl=0 sil∉{j1,..., jm} etxjklak-ième composante de
B−1b. Alors, on a AX B=b. Si de plus XB≥0(i.e. chaque xi≥0), alors :
Xest une solution de base admissible (ou réalisable)
Dans l’exemple 4.2, la matrice extraite B=
1 0 0
0 1 0
0 0 1
est inversible et B−1b=
6
6
22
. Donc XB=
0
0
6
6
22
≥0, par suite
XBest une solution de base admissible. On appelle les variables xjklesvariables de base . Les autres variables xl
sont les variables hors-base .
Parfois, il n’est pas évident de trouver une solution de base admissible, comme le montre l’exercice suivant :H. SABRI 29
Exercice 4.1
Écrire le programme linéaire suivant sous forme standard et montrer qu’on n’a pas une solution de base
admissible. Résoudre le programme linéaire.
max −x+y
s.t. x+y≥1,
3x+2y=6,
x,y≥0
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux
Dans cette section, on suppose qu’on a déjà trouvé une solution de base admissible X(produite avec B=Im)
du programme linéaire ( P: max z=cTX+c0etb≥0pour garantir que 0est une solution de AX≤b).
La méthode du simplexe est une méthode itérative qui génère une séquence de solutions de base réalisable
(correspondant à différentes bases) et s’arrête finalement lorsqu’elle a trouvé une solution de base réalisable opti-
male. Remarquer qu’on peut toujours prendre c0=0.
Algorithme 10 : Algorithme du simplexe
Entrées : Un P .L. standard P(max) avec une solution de base réalisable
Output : La solution optimale (ou non)
1On commence à écrire le tableau initiale (avec les variables de base xj1,..., xjm)
VB x1 ... xn b
xj1 b1
... A...
xjm bm
c1 ... cn−c0
2Sicj≤0 (∀j:xjest hors base), alors solution optimale (STOP) // min ⇝cj≥0
3Trouver la colonne s(hors base) tel que cs=max©
cj:cj>0ª// min ⇝cs=min©
cj:cj<0ª
4Siai,s≤0∀i=1... m, alors pas de solution optimale (STOP)
5Min Ratio Test : trouver la ligne rtel que
br
ar,s=min
i=1...m½bi
ai,s:ai,s>0¾
6Appliquer la procédure de Gauss autour de pivot ar,s(ar,s⇝1 et on annule les coefficients situés sous et
sur le pivot dans la colonne s, par combinaisons de lignes) // Ne pas oublier la dernière ligne
7Remplacer (dans VB) la variable de base ( sortante ) située à la ligne rpar la variable ( entrante )xs
8Retourner à l’étape 2 // l'algorithme termine si le programme linéaire est non dégénéré
Remarque 10.
— La dernière ligne représente l’équation linéaire −z+c1x1+···+ cnxn= −c0.
— La valeur de la variable de base de V Bde la ligne k est égale à la valeur b k(de la ligne k).
— La solution optimale du problème est la valeur finale (dernière cellule) (×− 1).
— Si on n’a pas au départ B =Im(à l’aide des variables d’écart) alors, on ajoute les variables artificielles (et on
applique d’abord la phase I - voir section suivante).30 Chapitre 4. Programmation linéaire
Exercice 4.2
Soit le programme linéaire :
max 2 x1+x2
s.t. x1−x2≤3,
x1+2x2≤6,
−x1+2x2≤2,
x1,x2≥0
Rajouter les variables d’écart. Puis résoudre le problème par l’algorithme du simplexe.
Remarque 11. Vérifier le résultat de l’exercice précédent, par la méthode graphique.
4.1.3 Initialisation - Phase I du simplexe
Un programme linéaire est dit sous forme simpliciale si la matrice Acontient la matrice identité Imcomme
sous matrice. On suppose que le programme linéaire P, après la mise en forme AX=b, n’est pas simpliciale
(possible dans le cas de contraintes du type ≥ou du type =). Soit Bune matrice d’ordre mextraite de Ainversible
tel que B−1b≥0et soit XBla solution de base réalisable ( XB≥0etAX B=b), alors on peut changer l’équation
matricielle :
AX B=b
⇐⇒ (B−1A)XB=B−1b
⇐⇒ A∗XB=b∗
et la matrice A∗contient la matrice identité Imcomme matrice extraite ( B−1A=B−1(H|B)=¡
B−1H|Im¢
). Ainsi, on
peut appliquer directement l’algorithme 10 en remplaçant Apar A∗etbpar b∗. Cependant, cette méthode n’est
pas efficace, car il faut trouver une matrice extraite Bréalisable correspondante. Pour une matrice Ade type m×n,
il existe¡m
n¢
matrices extraites à tester !
L ’idée est d’ajouter des variables, dites artificielles w1,w2,..., wm, pour faire apparaître une forme simpliciale
du programme linéaire P: (AX=b). Mais, il faut que w1= ··· = wm=0. Donc, il faut minimiser d’abord le pro-
gramme linéaire P0suivant :
P0=min W=w1+···+ wm
s.t. (A|Im)×(x1...xnw1...wm)T=b
x1,..., xn,w1,..., wm ≥0
On exprime Wà l’aide des autres variables (hors base) et puis on applique l’algorithme du simplexe 10 pour P0
(phase I). À la fin, si on trouve que les wi=0, alors les variables de bases xj1,..., xjmforment une première base
admissible pour démarrer le simplexe pour le programme d’origine P.H. SABRI 31
Remarque 12. On ajoute la ligne de Z :c1 ... cn−c0dans le tableau du simplexe de P0(phase I) et on lui
applique les opérations élémentaire comme avec les autres lignes. À la fin de la phase I, on supprime les colonnes des
wiet la ligne de la fonction W . Finalement, on utilise ce tableau pour résoudre le problème initiale P.
Example 4.3
Soit le programme linéaire P:
min 6 x1+3x2
s.t. x1+x2≥1,
2x1−x2≥1,
3x2≤2,
x1,x2≥0sous forme standard (max)= = = = = = = = = = = = = = = = = = ⇒max Z= −6x1−3x2
s.t. x1+x2−e1=1,
2x1−x2−e2=1,
3x2+e3=2,
x1,x2,e1,e2,e3≥0
La matrice Aest :
A=x1 x2 e1 e2 e3

1 1 −1 0 0
2−1 0 −1 0
0 3 0 0 1
est par suite Pn’est pas sous forme simpliciale (il n’ ya pas de sous matrice I3). Donc on peut ajouter 2
variables artificielles pour construire le problème initiale P0:
max −w1−w2=3x1−e1−e2−2
s.t. x1+x2−e1+w1=1,
2x1−x2−e2+w2=1,
3x2+e3=2,
x1,x2,e1,e2,e3,w1,w2≥0dont le vecteur X=

0 x1
0 x2
0 e1
0 e2
2 e3
1 w1
1 w2est une solution de base réalisable.
Ainsi, on commence notre algorithme 10 pour le programme P0. Le tableau initial est :
x1 x2 e1 e2 e3 w1 w2 b

w1 1 1 −1 0 0 1 0 1
w2 2−1 0 −1 0 0 1 1
e3 0 3 0 0 1 0 0 2
W: 3 0 −1−1 0 0 0 2
Z:−6−3 0 0 0 0 0 0
Le pivot c’est a2,1donc x1est la variable entrante et w2est sortante. On obtient après pivotement le tableau :
L2←1
2L2− − − − − − − − →
L1←L1−L2
L4←L4−3L2
L5←L5+6L2x1 x2 e1 e2 e3 w1 w2 b

w1 03
2−11
20 1−1
21
2
x1 1−1
20−1
20 01
21
2
e3 0 3 0 0 1 0 0 2
W: 03
2−11
20 0−3
21
2
Z: 0 −6 0 −3 0 0 3 3
Le pivot est a1,2(Min ratio test =1
3). On obtient alors :32 Chapitre 4. Programmation linéaire
L1←2
3L1− − − − − − − − →
L2←L2+1
2L1
L3←L3−3L1
L4←L4−3
2L1
L5←L5+6L1x1 x2 e1 e2 e3 w1 w2 b


x2 0 1−2
31
302
3−1
31
3
x1 1 0−1
3−1
301
31
32
3
e3 0 0 2 −1 1 −2 1 1
W: 0 0 0 0 0 −1−1 0
Z: 0 0 −4−1 0 4 1 5
Ainsi, la phase I se termine avec W=0 et x1=2
3,x2=1
3,e3=1 et e1=e2=w1=w2=0. Le tableau pour la
phase II est donc :
x1 x2 e1 e2 e3 b


x2 0 1−2
31
301
3
x1 1 0−1
3−1
302
3
e3 0 0 2 −1 1 1
Z: 0 0 −4−1 0 5
On remarque donc que les cj≤0, donc (STOP) la solution est optimale et le max est −5. Ainsi la solution
optimale pour le programme P=min6 x1+3x2est−(−5)=5=6×2
3+3×1
3.
4.2 Dualité
SoitPun P .L. sous forme canonique. Le programme dualDdePest définit par :
P=max z=cTX
s.t. AX ≤ b
X≥ 0le dual est= = = = = = = ⇒D=min w=bTY
s.t. ATY≥ c
Y≥ 0
Le programme Pest dit primal . On remarque que si Ade type m×n, alors X∈RnetY∈Rmpour le dual.
Théorème 4.1 Théorème de dualité
Si un problème primal ou dual admet une solution, alors l’autre problème admet aussi une solution et on a :
max z=cTX =
s.t. AX ≤ b
X≥ 0min w=bTY
s.t. ATY≥ c
Y≥ 0
Exercice 4.3
Soit le problème suivant de type régime :
D=min w=340x1+2400 x2+560x3
s.t. x1+2x2+x3≥ 1200
x1+3x2+2x3≥ 1400
x1+x2+3x3≥ 1500
x1,x2,x3≥ 0
Écrire le programme primal PdeD. Résoudre le programme Pet déduire la valeur minimale de w, a-t-on
besoin de faire les deux phases du simplexe ?
7} A B oS



HOUSSEM SABRI
Graphes et Optimisation
2`emeannée
LISI  LSI
Institut Supérieur des Sciences Appliquées et de Technologie de Sousse
A.U. 2023-2024
28 novembre 2023Table des matières
1 Les graphes 3
1.1 Définitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.1 Graphes non orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.2 Graphes orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.2 Opérations et quelques types de graphes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.3 Représentation d’un graphe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.1 Listes d’adjacences (ou de succession) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.2 Matrices d’adjacence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.3.3 Matrice d’incidence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2 La connexité 11
2.1 Les chaînes et les cycles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.2 Graphe connexe, eulérien, hamiltonien . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.3 Arbres . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.3.1 Codage et décodage d’un arbre – Prüfer code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.3.2 Arbre couvrant de poids minimum – ACM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3 Les algorithmes de base 20
3.1 Parcours en profondeur (DFS) / largeur (BFS) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
3.2 Recherche des chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.1 Matrice d’adjacence et nombre de chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.2 Plus court chemin et l’algorithme de Dijkstra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
3.3 Problèmes d’ordonnancement et chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
3.3.1 Algorithmes de tri topologique et de chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . 25
4 Programmation linéaire 27
4.1 La méthode simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.1 Solution de base admissible . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux . . . . . . . . . . . . . . . . . . . . . . . . 29
4.1.3 Initialisation - Phase I du simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
4.2 Dualité . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
2CHAPITRE 1
Les graphes
L ’exemple classique pour introduire la théorie des graphes est le problème des ponts de Königsberg, étudié par
Euler en 1736. Quel itinéraire doit-on suivre pour traverser chaque pont exactement une fois? Une telle prome-
nade n’existe pas, et c’est Euler qui donna la solution de ce problème en caractérisant les graphes que l’on appelle
aujourd’hui eulériens .
A
B
Ce1 e2
e3 e4
De5
e6e7
FIGURE 1.1 – Les ponts de Königsberg
Les graphes introduisent une simplification : les régions se transforment en des "points" (aussi appelés noeuds
ousommet ), les ponts se transforment en des lignes (aussi appelées arêtes ouarcs ), et ce principe s’applique dès
lors qu’une relation existe entre des objets. Les graphes relèvent de la combinatoire plutôt que de la géométrie (les
intersections, les longueurs, et la forme des arêtes n’ont aucune importance, sauf en ce qui concerne la lisibilité de
la représentation).
1.1 Définitions
Dans la suite, il est toujours supposé que les graphes sont finis, sauf indication contraire.
1.1.1 Graphes non orientés
Définition 1.1: Graphe
Un graphe Gest un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V{2}des pairs non ordon-
nées de V.Vest l’ensemble des noeuds (Vertices en anglais) et Ec’est l’ensemble des arêtes de G(Edges en
anglais). Lorsque e={x,y} est une arête, on dit que x, y sont les extrémités de cette arête, que eest incidente
enxet en y. On joint x et y par un trait et on dit que x, y sont adjacents (ou voisins). On note aussi e=x you
encore e=(x,y) (attention , dans ce cas : ( x,y)=(y,x)).
SiGest un graphe alors, on note par V(G) l’ensemble de noeuds et par E(G) l’ensemble des arcs.
Remarque 1.
— Une arête e ={x,x}s’appelle boucle .
— Dans un graphe, il peut exister des arêtes parallèles (on parle donc de multigraphe ).
Dans l’exemple des ponts on a : e 1=e2=(A,B).
34 Chapitre 1. Les graphes
— Un graphe est dit simple s’il ne comporte ni arêtes multiples ni de boucles, c’est-à-dire chaque paire de nœuds
distincts est reliée par au plus une arête, ou encore E (G)⊆P2(G).
Dans la plupart des cas, les graphes sont considérés comme simples par défaut.
Définition 1.2: ordre – taille – degré
Soit G=(V,E) un graphe.
1. On appelle ordre d’un graphe noté v(G) le nombre de ses sommets :
v(G)= |V|
2. On appelle taille d’un graphe noté e(G) le nombre de ses arêtes :
e(G)= |E|
3. Le degré (ou valence) d’un sommet xnoté d(x) est le nombre d’arêtes contenant x. (Attention! Une
boucle sur un sommet compte double).
Si on note par Γ(x) l’ensemble des voisins de x, i.e.
Γ(x)={y∈V:x y∈E}
alors, siGest simple , on a :
d(x)= |Γ(x)|
Example 1.1 (Graphe complet)
Un graphe d’ordre nest dit complet noté Knsi chaque sommet du graphe est relié directement à tous les
autres sommets, i.e. E(Kn)=P2(V(Kn)).
Représenter graphiquement K3,K4,k5. Calculer la taille de K3,k4,...Kn.
Example 1.2 (Graphe biparti)
Un graphe G=(V,E) est dit biparti si son ensemble de sommets V=V1˙∪V2, i.e. peut être divisé en deux
sous-ensembles disjoints V1etV2tels que chaque arête ait une extrémité dans V1et l’autre dans V2.
Si∀x∈V1,∀y∈V2;x y∈E, alors Gest dit biparti complet noté Kn,moùn= |V1|etm= |V2|.
a1
 a2
 a3
 a4
b1
 b2
 b3
FIGURE 1.2 – Un graphe biparti
Théorème 1.1 Lemme des poignées de main – Handshaking lemma
Soit Gun graphe alors, on a :X
x∈V(G)d(x)=2e(G)
Dans ce théorème d(x) est le nombre de personnes à qui xserre la main et e(G) le nombre total de poignées
de mains.H. SABRI 5
Preuve.
•Méthode simple Il y en a d(x) arêtes en un sommet xfixé. Pour tout les sommets cela fait doncP
x∈V(G)d(x).
Mais avec cette manière chaque arête est comptée deux fois, une fois à chacune de ses extrémités, d’où le
résultat en divisant par 2.
•Preuve par double dénombrement On pose
Z={(x,e)∈V×E:x∈e}⊆V×E
et les deux projections :
p:Z→V
(x,e)7→xet q:Z→E
(x,e)7→e
L ’idée est de calculer |Z|de deux manières différentes. D’abord, on rappelle que si f:A→Best une fonction
quelconque, alors :X
b∈B|f−1[b]| = | A|
oùf−1[b] désigne l’image réciproque de { b} par f(pourquoi ˙S
b∈Bf−1[b] est une union disjointe ?).
Ainsi on obtient :
|Z| =X
x∈V|p−1[x]| =X
e∈E|q−1[e]|
Or,|p−1[x]| =d(x) et|q−1[e]| = |{x∈V:x∈e}| =2. Donc :
X
x∈Vd(x)=X
e∈E2=2|E|
Remarque 2.
— Un sommet de degré 0est appelé sommet isolé .
— Un graphe tel que : ∀x∈V,d(x)=kest dit graphe k-régulier .
— Le graphe complet K nest un graphe (n−1)-régulier .
Exercice 1.1
Montrer que dans un graphe le nombre de sommets d’ordre impairs est toujours pair. En particulier un
graphe k-régulier avec kimpaire est un graphe d’ordre pair.
Voici quelques exemples comme application :
1. Est-il possible de relier 15 ordinateurs en réseau de sorte que chacun soit relié à exactement 3 autres ?
2. Une ligue de football comprenant 11 clubs organise un tournoi. Pour gagner du temps on décide que chaque
équipe ne jouera que la moitié des matches possibles. Comment organiser le tournoi ?
Proposition 1.1
Soit G=(V,E) un graphe (simple) d’ordre n≥2. Alors :
∃u,v∈V,u̸=v:d(u)=d(v)
Preuve. Supposons le contraire, c’est-à-dire ∀u,v∈V;d(u)̸=d(v). Or dans un graphe (simple) on a toujours d(x)∈
{0,1,..., n−1}. Dans ce cas, puisque tous les nsommets ont des degrés distincts, alors il existe une bijection
{d(x):x∈V}←→ {0,1,..., n−1}
Donc, il existe un sommet uavec un degré 0, et un sommet vavec degré n−1, donc vest connecté à tous les autres
sommets du graphe, ce qui signifie que une peut pas être un sommet isolé, d’où une contradiction.6 Chapitre 1. Les graphes
1.1.2 Graphes orientés
Les arêtes d’un graphe peuvent être orientées, auquel cas une flèche indique la direction. De tels graphes sont
appelés des graphes orientés ou des digraphes , et une arête ( a,b) dans un tel graphe indique que cette arête est
dirigée de sommet avers b, i.e. ( a,b)=− →ab̸=(b,a)=− →ba. D’où la définition :
Définition 1.3: Graphe orienté - digraphe
Un graphe orienté G(ou− →G) est un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V2des pairs
ordonnées de V.Eest l’ensemble des arêtes (ou flèches, arcs) de G. Lorsque e=(x,y) est une arête, on dit
que xestl’origine (ou sommet initiale) et yl’extrémité (ou sommet terminale) de e, que eest sortant en x
et incident en y, et que yest un successeur de xtandis que xest un prédécesseur de y. On note l’arête e
par :
e=(x,y)=− →x y=x→y
De la même façon, une arête x→xest une boucle. On peut toujours supprimer les boucles pour obtenir des
digraphes simples. Voici l’exemple d’un digraphe G=(V,E) d’une fonction f:E→Eoù ( x,y) est un arc si et seule-
ment si y=f(x). On l’appelle digraphe fonctionnelle.
0
3
1214
11 568
169
4
2 1
713 10
15
FIGURE 1.3 – Le digraphe fonctionnelle Gfdex7→(x2+3) mod 17.
Comme dans les graphes on peut définir les degrés (entrant, sortant) d’un sommet dans un digraphe.
Définition 1.4: indegree - outdegree
Soit G=(V,E) un digraphe. Pour v∈V, on note par :
d+(v) le degré extérieur (sortant - outdegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité initiale.
d+(v)= |{v→ •}|
d−(v) le degré intérieur (entrant - indegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité finale.
d−(v)= |{• → v}|
On définit le degré : d(v)=d−(v)+d+(v).
Un sommet de degré entrant non nul et de degré sortant nul est appelé puits , tandis qu’un sommet de
degré entrant nul et de degré sortant non nul est appelé source ouracine .
Dans un graphe orienté, les voisins d’un sommet vsont soit des successeurs ou des prédécesseurs. On les notes
par :
Γ+(x)=Succ (x)={y∈V:x→y∈E} et Γ−(x)=Pr ed (x)={y∈V:y→x∈E}H. SABRI 7
Si le digraphe est simple (ni boucle ni arcs parallèles) on a :
d−(v)= |Γ−(v)|et d+(v)= |Γ+(v)|
Proposition 1.2
Soit Gun digraphe, alors :X
v∈Vd−(v)=X
v∈Vd+(v)= |E|
Preuve. On a
E=˙[
v∈V{• → v}=˙[
v∈V{v→ •}
=⇒ | E| =X
v∈V|{• → v}| =X
v∈V|{v→ •}| =⇒ | E| =X
v∈Vd−(v)=X
v∈Vd+(v)
1.2 Opérations et quelques types de graphes
Une opération sur les graphes permet de construire un nouveau graphe comme résultat de l’opération. Les
opérations courantes sur les graphes sont la suppression, la valuation, l’union, l’intersection et le produit cartésien.
Graphe valué
Tout d’abord, on peut vouloir attribuer des valeurs aux arcs ou arêtes pour tenir compte de contraintes : dis-
tance, coût ...
Définition 1.5: (di)graphe valué
Un (di)graphe valué G=(V,E,w) est un (di)graphe muni d’une application w:E→R. L ’application west
appelée application poids ou coût. On indique sur chaque arête son poids (ou son coût). On note w(x,y)
au lieu de w((x,y)). On convient (même que ceci n’a pas de sens!) que w(x,y)= +∞ si (x,y)∉E.
ab
c
d
ef53
43
3
335
81
FIGURE 1.4 – Un digraphe valué
/pythonPython code : -
Implémenter le digraphe valué précédent avec python. Indice – use chatGPT : how to build a weighted digraph with
python8 Chapitre 1. Les graphes
Sous graphes
Soit G=(V,E) un graphe (orienté ou non). Un sous graphe de Gest un graphe de la forme G′=(V′,E′) où
V′⊆V,E′⊆Etels que toute arête de E′a ses extrémités dans V′(ou encore G′est aussi un graphe). On a :
•Sous-graphe induit Un sous-graphe G′=(V′,E′) de G=(V,E) est appelé un sous-graphe induit deGsi :
∀x,y∈V′; (x,y)∈E′⇐⇒ (x,y)∈E
En d’autres termes, deux sommets de G′qui sont connectés dans G, sont également connectés dans G′.
•Sous-graphe couvrant Un sous-graphe couvrant G′deGcontient tous les sommets de G, i.e. V′=V.
•G−vSupprimer un sommet vd’un graphe Gconsiste à supprimer vet toutes ses arêtes incidentes. Le sous-
graphe obtenu de cette opération est noté G−v, i.e.
V′=V−{v} et E′=E−{(v,y): (v,y)∈E}
De manière similaire, une arête epeut être supprimée (resp. ajoutée) d’un graphe G, et le sous-graphe
résultant est représenté par G−e(resp. G+e). Notez que la suppression d’une arête ne retire pas de sommets
du graphe.
•G−V′=G[V′] On supprimer tous les sommets v∈V′du graphe Gavec les arêtes incidentes. Le sous-graphe
obtenu de cette opération est noté G[V′], i.e.
V(G[V′])=V−V′et E(G[V′])=E−{(v,y)∈E:v∈V′}
•Clique Une clique Cd’un graphe Gest un sous-ensemble des sommets de Gdont le sous-graphe induit G′=
(C,E′) est un graphe complet, en d’autres termes, deux sommets quelconques de la clique Csont toujours
adjacents.
•Stable Un stable – appelé aussi ensemble indépendant (independent set en anglais) est un ensemble de som-
mets deux à deux non adjacents. Donc le sous-graphe induit est sans arcs.
FIGURE 1.5 – L ’ensemble des sommets en bleu dans ce graphe est un stable maximal du graphe.
Note : -
Le problème décisionnel de la clique (c’est à dire existe t-il une clique de taille k) est NP-complet . De même la
recherche d’un stable de taille maximum dans un graphe est un problème NP-complet et difficile à approximer.
Exercice 1.2
Trouver un plus grand stable et une plus grande clique du graphe suivant :
8
4
62 7
3
1 5
Indice : vérifier le résultat avec networkx.find_cliques(G) et.maximum_independent_set(G) de python.H. SABRI 9
Opérations binaires
Union L ’union de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∪H=(VF,EF) dans lequel
VF=VG∪VH et EF=EG∪EH
Intersection L ’intersection de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∩H=(VF,EF)
dans lequel
VF=VG∩VH et EF=EG∩EH
1.3 Représentation d’un graphe
Il est important de savoir comment représenter les graphes au sein d’un ordinateur. Il ya plusieurs méthodes
selon la nature des traitements que l’on souhaite appliquer au graphe considéré.
1.3.1 Listes d’adjacences (ou de succession)
Soit Gun (di)graphe. On suppose que les sommets de Gsont numérotés de S1àSn. La représentation par listes
d’adjacence de Gconsiste en un tableau (ou des listes chainées) tel que la ligne i=1... ncorrespond au sommet Si
et comporte la liste des voisins/successeurs (ou des prédécesseurs) de ce sommet notée T[Si]. Les sommets dans
chaque liste d’adjacence sont généralement listés selon un ordre arbitraire.
1
2
345
FIGURE 1.6 – Un digraphe
La liste d’adjacence de digraphe 1.6 est donc :
1 2 3 4 5
2 3
3 4
4−
5 1 410 Chapitre 1. Les graphes
1.3.2 Matrices d’adjacence
Définition 1.6: Mat. Adjacence
Soit G=(V,E) un graphe (orienté) d’ordre n. On peut numéroter V={1,2,..., n}.La matrice d’adjacence
deGest la matrice carrée A=(ai j) d’ordre n, définie par :
ai j=(
1 si ( i j)∈E;
0 sinon.
Remarque 3.
1. Si le graphe G est non orienté et simple, alors la matrice A est symétrique avec des 0sur la diagonale. Pour un
digraphe simple, on a toujours des 0sur la diagonale, mais la matrice n’est pas symétrique en général.
2. Pour les multigraphes, il peut y avoir des termes diagonaux (pour les boucles) et s’il y a plusieurs arêtes de i à
j , le coefficient de la matrice a i jest le nombre d’arêtes de i à j .
3. Pour un (di)graphe valué G =(V,E,w), on pose :
ai j=(
w(i,j)si(i j)∈E ;
∞ sinon.
La matrice d’adjacence de la figure 1.4 est :

∞ 5∞ 4 3 ∞
∞ ∞ 3∞ 1∞
∞ ∞ ∞ ∞ ∞ 5
∞ ∞ 3∞ 3 3
∞ ∞ ∞ ∞ ∞ 8
∞ ∞ ∞ ∞ ∞ ∞

1.3.3 Matrice d’incidence
Définition 1.7: Mat. Incidence
Soit G=(V,E) un graphe (simple) d’ordre net de taille m. On pose V={v1,v2,..., vn} etE={e1,e2,..., em}.
La matrice d’incidence deGest la matrice de type n×m B=(bi j), définie par :
•Si G orienté
bi j=

1 si ej=vi→ • (i.e. viest l’extrémité initiale de ej) ;
−1 si ej= • → vi(i.e. viest l’extrémité terminale de ej) ;
0 sinon.
•Si G non-orienté
bi j=(
1 si viest une extrémité de ej;
0 sinon.
Exercice 1.3
1. Donner la matrice d’incidence du graphe 1.6.
2. Montrer le théorème 1.1 avec la matrice d’incidence.CHAPITRE 2
La connexité
Il est important de savoir si on peut suivre un chemin d’un sommet donné à un autre dans un graphe donné.
Cette propriété (de connexité) doit être maintenue dans différents types de réseaux.
2.1 Les chaînes et les cycles
Définition 2.1: (chaine – cycle) (chemin – circuit)
•Graphe non orienté
1. Une chaîne (walk ) reliant xày, notée µ(x,y), est définie par une suite finie d’arêtes consécutives,
reliant xày, ou encore une séquence de sommets (puisque non multigraphe)
µ(x,y)=<v0,v1,..., vk>
tels que v0=x,vk=yet (vi−1,vi)∈E(G) pour tout i=1... k. Six=yla chaîne est dite fermée .
Lalongueur du chaîne l(µ(x,y)) est le nombre d’arcs dans la chaîne, c’est-à-dire k.
2. Une chaîne élémentaire (a path ) si tous les sommets sont distincts. Une chaîne simple (a simple
walk, a trail ) est une chaîne ne passant pas deux fois par une même arête, c’est-à-dire dont toutes
les arêtes sont distinctes. Remarquer que : élémentaire =⇒ simple.
3. Un cycle v0v1...vnde longueur n≥3 est une chaîne simple fermée ( v0=vn) tel que les sommets
v0,v1,..., vn−1sont tous distincts. Un graphe sans cycle est dit acyclique .
•Graphe orienté
Dans un graphe orienté, on parlera de chemin au lieu de chaîne, et de circuit au lieu de cycle.
Example 2.1
abxcd xa est une chaîne simple et fermée (non cycle!) de longueur 6 (mais, c’est un graphe eulérien - voir
plus loin). Y a-t-il un cycle de longueur 3,4 ?
a b
x
c dÏ
Remarque 4.
1. On peut pivoter une chaine fermée (l’orienter de manière arbitraire) , i.e.
<v0,v1,v2,..., v0>=< vk,vk+1,..., v0,v1,..., vk>
1112 Chapitre 2. La connexité
2. Soient x ,y∈V . La distance de x à y est définie par :
d(x,y)=(
k si le plus court chemin/chaîne de x vers y est de longueur k
∞ sinon
On convient que d (x,x)=0.
3. Le diamètre du graphe la plus grande distance entre deux sommets.
L ’observation suivante, bien que très facile à prouver, sera utile.
Théorème 2.1
S’il existe une chaîne du sommet yau sommet zdans le graphe G, où y̸=z, alors il existe une chaîne élé-
mentaire ( path ) dans Gavec pour premier sommet yet pour dernier sommet z.
Preuve. Soit la chaine
W1=µ(y,z)=x0x1...xn; avec x0=yetxn=z.
Si les sommets x0,x1,..., xnsont tous distincts, alors W1est une chaîne élémentaire, et nous avons terminé. Sinon,
il existe xi=xj(i<j) et on écrit :
W2=x0x1...xixj+1...xn.
Alors, l(W2)<l(W1). Si W2ne contient aucun sommet répété, alors c’est la chaîne recherché. Sinon, par la même
procédure, il existe W3(y z−chaîne) tel que
l(W3)<l(W2)<l(W1).
Ce processus doit s’arrêter à un certain stade, car chaque chaîne est plus courte que la précédente et la longueur
ne peut jamais être inférieure à 1
1< ··· < l(Wk)< ··· < l(W3)<l(W2)<l(W1).
Ainsi, pour un certain k,Wkne peut pas être réduit en longueur. Donc, la chaîne Wkne contient aucun sommet
répété et est donc une y z−chaîne élémentaire (path).
Exercice 2.1
Dans le graphe suivant, construire un path à partir de la chaîne W=v2v3v4v5v6v4v2v8v1
v1
 v2
v3
v4
v5
v6
v7
 v8
 v9
Calculer d(v1,v7) et le diamètre de G.
/pythonpython : >>G = nx.Graph([(1, 2), (2, 3), (2, 4), ...]) >>nx.diameter(G)
Les cycles fournissent la caractérisation suivante pour les graphes bipartis .H. SABRI 13
Théorème 2.2
Un graphe est biparti si et seulement s’il ne contient aucun cycle de longueur impaire.
Preuve.
⇒On suppose que G=U˙∪Vest un graphe biparti. Soit W=< x1,x2,..., x2k+1,x1>un cycle de longueur im-
paire (2 k+1). Si x1∈U, alors
x1∈U=⇒ x2∈V=⇒ x3∈U=⇒ ··· =⇒ x2k+1∈U=⇒ x1∈V/exclamati⌢n-triangle
absurde, d’où le résultat.
⇐On suppose que Gest connexe (car l’union des composantes connexes bipartis est un graphe biparti). Soit
xun sommet de Get on pose :
U={y∈V(G):d(x,y) est paire} et V={z∈V(G):d(x,z) est impaire}
S’il existe y1,y2∈Utel que y1y2∈E(G), alors on a :
W1=<x,..., y1>est une chaîne de longueur paire =2k1
W2=<x,..., y2>est une chaîne de longueur paire =2k2
=⇒ W3=<x,..., y1,y2,..., x>est un cycle de longueur impaire =2k1+2k2+1/exclamati⌢n-triangle
Donc G=U˙∪Vest un graphe biparti.
Exercice 2.2
Vérifier si le graphe maison est un graphe biparti. Faire de même pour la grille G4,4.
maison grille
2.2 Graphe connexe, eulérien, hamiltonien
Définition 2.2: Graphe connexe
Un graphe est dit connexe si deux points peuvent toujours être joints par une chaîne, i.e.
∀x,y∈V(G),d(x,y)< ∞
— Une composante connexe d’un graphe est un sous-graphe induit maximal connexe.
— Un point d’articulation d’un graphe est un sommet dont la suppression augmente le nombre de
composantes connexes.
Par exemple, le graphe suivant :14 Chapitre 2. La connexité
a
 b
d
 c
e
f
 g
n’est pas connexe car il n’existe pas de chaîne entre les sommets aete. On a donc 2 composantes connexes. En
revanche, le sous-graphe induit par les sommets { a,b,c,d} est connexe dont aest le seul point d’articulation.
Remarque 5.
1. Un graphe connexe à n sommets possède au moins n −1arêtes ( faite une preuve par récurrence ).
2. L’algorithme de parcours en profondeur permet de déterminer si un graphe est connexe ou non.
3. Même définitions dans un graphe orienté . Graphe orienté (fortement) connexe et de composante connexe .
Définition 2.3: Graphe eulérien
— Une chaîne joignant deux sommets xetyest dite chaîne eulérienne si elle emprunte chaque arête
deGune et une seule fois. On parle de chemin eulérien dans le cas d’un graphe orienté.
— Un cycle eulérien est une chaîne eulérienne dont les extrémités coïncident. Un graphe qui admet
un cycle (resp. circuit) eulérien est dit graphe eulérien .
/flushedRemarquer qu’un cycle eulérien n’est pas forcément un cycle comme définit dans la définition 2.1
Si un graphe (ou multigraphe) Gpossède une chaîne eulérienne, alors soit Gpossède deux sommets impairs, le
début et la fin de cette chaîne, soit Gn’a aucun sommet impair, et la promenade d’Euler commence et se termine
au même point (cycle eulérien). Une autre condition nécessaire évidente est que Gdoit être connexe. Ces deux
conditions sont ensemble suffisantes.
Théorème 2.3 Euler
Soit Gun graphe (multigraphe) connexe.
— Si Gn’a pas de sommets impairs, alors il possède un cycle eulérien (commençant à n’importe quel
point).
i.e.∀x,d(x)≡0 mod 2 =⇒ Gest un graphe eulérien.
— Si Ga deux sommets impairs, alors il possède une chaîne eulérienne dont le début et la fin sont les
sommets impairs.
La réciproque est aussi vraie.
Preuve.
⇐On commence par la réciproque. S’il existe une chaîne eulérienne µ(x,y), alors on peut crée une arête fictive
e=(y,x) et par la suite on obtient un cycle eulérien. Donc il suffit de montrer que si Gadmet un cycle
eulérien alors tous les sommets sont de degré pair.
Soit W=< v1,v2,..., vn,v1>un cycle eulérien. Soit le sommet vjavec j̸=1, il est donc claire que chaque
fois vjapparaît dans W, il ya deux arcs distincts incidents en vj( (•,vj) et ( vj,•)). Comme toutes les arêtes
sont utilisées, on voit que d(vj) est pair. Même chose pour v1car on ajoute deux arcs ( v1,v2) et ( v1,vn).
⇒On suppose que tous les sommets sont de degré pair. Montrons que Gadmet un cycle eulérien. Puisque
tous les sommets sont de degré pair on peut construire d’abord une chaîne simple fermée (quelconque)
W1=<v1,v2,..., vk,v1>
SiW1contient chaque arête de G, alors c’est finis, c’est un cycle eulérien. Sinon (puisque Gest connexe), il
existe une arête e=(vi,c) qui n’est pas dans W1(avec visommet de W1). On pose le sous-graphe
G′=G−{ arêtes de W1}H. SABRI 15
Il est donc claire que les sommets de G′sont aussi de degré pair. Alors, par la même procédure on construit
une chaîne simple fermée dans G′de la forme : <vi,c,d,..., vi>et par la suite on insère cette chaîne dans
W1pour obtenir :
W2=<v1,v2,..., vi,c,d,..., vi,vi+1,..., vk,v1>
Sil(W2)< |E(G)|, on construit W3de longueur plus grand. Ainsi, on a :
l(W1)<l(W2)<l(W3)< ··· ≤ | E(G)|
Donc, nécessairement, il existe Wk(chaîne simple fermée de longueur |E(G)|) donc c’est un cycle eulérien.
Finalement , si∃a,b∈V(G):d(a)≡d(b)≡1 mod 2, et tous les autres sommets sont de degré pair, alors on
pose :
G′=G+{a,b}
et donc tous les sommets de G′sont de degré pair. Avec la construction précédente, il existe un cycle eulérien
dans G′:
W=<a,b,v1,..., a>
est donc la chaîne <b,v2,..., a>est une chaîne eulérienne dans G.
Algorithme 1 : Euler
Entrées : Gun graphe eulérien
Output : Un cycle eulérien W
/* On suppose que G est eulérien, i.e. les sommets sont de degré pair */
1Gaux←G;W←µ(v,v) une chaîne simple (quelconque) de G; // Initialisation
2tant que l(W)<e(G)faire
3 Gaux←G−{ arêtes de W} ;
4 Choisir ( x,c)∈E(Gaux) tel que x∈W;
5 L←< x,c,..., x>une chaîne simple de Gaux ;
6 Dans W, remplacer (juste ce) xpar la séquence L;
7fin
8retourner W;
Exercice 2.3
1. Montrer que le graphe de l’exercice 2.1 est un graphe eulérien et donner un cycle eulérien.
2. Tracer cette maison d’un seul trait.
Remarque 6. Le théorème d’Euler dans un graphe orienté connexe s’écrit :
Admet un circuit eulérien si, et seulement si, pour tout sommet, le degré entrant est égal au degré sortant.
∀v∈V(G),d+(v)=d−(v)
Admet un chemin eulérien de a vers b si, et seulement si,


d+(v)=d−(v) ;∀v̸=a,b,
d−(a)=d+(a)−1
d−(b)=d+(b)+116 Chapitre 2. La connexité
Définition 2.4: Graphe hamiltonien
Soit Gun graphe connexe d’ordre n. On appelle :
1. On appelle cycle hamiltonien deGun cycle passant (une et une seule fois) par chacun des sommets
deG. Un graphe est dit hamiltonien s’il possède un cycle hamiltonien.
2. Une chaîne hamiltonienne est une chaîne passant une et une seule fois par chacun des sommets de
G. Un graphe ne possédant que des chaînes hamiltoniennes est semi-hamiltonien .
3. Dans un digraphe, on change cycle par circuit et chaîne par chemin .
Remarque 7.
— Une chaîne hamiltonienne est une chaîne élémentaire de longueur n −1.
— Un graphe peut être eulérien, hamiltonien, les deux à la fois, ou aucun des deux.
— De nombreux problèmes concrets peuvent être formulés en termes de recherche de parcours hamiltoniens : pro-
blème du voyageur de commerce (chercher un cycle hamiltonien de longueur totale minimale), l’ ordonancement
de tâches .
— Le problème du chaîne hamiltonienne est un problème NP-complet .
Exercice 2.4
Donner un graphe (connexe, simple) qui soit :
1. hamiltonien et eulérien.
2. hamiltonien et non eulérien.
3. eulérien et non hamiltonien.
4. non hamiltonien et non eulérien.
Aucune condition nécessaire et suffisante adéquate n’est connue pour l’existence de cycles hamiltoniens. Le
résultat suivant constitue une condition suffisante utile.
Théorème 2.4 Ore
Soit Gun graphe simple d’ordre n≥3. Si pour toute paire { x,y} de sommets non adjacents, on a d(x)+d(y)≥
n, alors Gest hamiltonien.
Preuve. On suppose que le théorème est faux. Alors, il existe un graphe Gsimple d’ordre nnon hamiltonien tel que
d(u)+d(v)≥npour tout sommets non adjacents uetv. On prend Gun tel graphe d’ordre nde taille maximale qui
vérifie cette propriété (remarquer que le graphe complet Knest hamiltonien).
Soient uetvdeux sommets non adjacents de G. Par maximalité de G, le graphe G+uv(d’ordre n) doit être
hamiltonien. Donc il existe dans G+uvun cycle hamiltonien :
W=<u,x1,x2,..., xn−2,v,u>
u
x1
xi xi+1xn−2
v
... ...
Or, si uxi+1∈E(G) etv xi∈E(G) (les arcs en rouge), alors on peut construire dans Gle cycle hamiltonien :
<u,x1,x2,..., xi,v,xn−2,..., xi+1,u>H. SABRI 17
Ceci est absurde car Gest non hamiltonien. Donc si xi+1est un sommet voisin à u, alors le sommet xin’est pas
voisin de v:
xi+1∈Γ(u)=⇒ xi∉Γ(v)
Donc :
d(u)= |Γ(u)| =p=⇒ d(v)≤(n−1)−p
et par la suite
d(u)+d(v)≤n−1
ce qui absurde par hypothèse. Donc Gest hamiltonien.
Une conséquence immédiate est le théorème de Dirac :
Proposition 2.1 Dirac
Soit Gun graphe simple d’ordre n≥3. Si pour tout sommet xdeG, on a d(x)≥n
2, alors Gest hamiltonien.
2.3 Arbres
Définition 2.5: Arbres et forêts
On appelle arbre tout graphe (non orienté) connexe et acyclique . Les composantes connexes dans un
graphe acyclique sont des arbres et le graphe est dit forêt . Une feuille ou sommet pendant est un som-
met de degré 1.
Un forêt avec deux arbres
Un graphe Gest une arborescence s’il existe un sommet Rappelé racine deGtel que, pour tout sommet
SdeG, il existe un chemin et un seul de Rvers S. Donc, c’est un arbre orienté dans lequel on choisit un
sommet Rcomme racine et on dirige les arcs vers le sens sortant de la racine.
Remarque 8.
— Un graphe G d’ordre n est un arbre ssi G est sans cycle et possède n −1arêtes.
— Un graphe G d’ordre n est un arbre ssi G est connexe et possède n −1arêtes.
— G est un arbre si pour chaque paire u ,v de sommets distincts est reliée par une seule chaîne (donc chaîne
élémentaire d’après le théorème 2.1).
— Un arbre (ou forêt) est nécessairement un graphe simple.
Pour démontrer les remarques précédentes, il suffit de prouver le théorème suivant :
Théorème 2.5
Soit Gun graphe ayant marêtes, nsommets et pcomposantes connexes, on définit nu( G) :
ν(G)=m−n+p
Alors, on a :
1.ν(G)≥0.
2.ν(G)=0⇐⇒ Gest acyclique.18 Chapitre 2. La connexité
Preuve. Par récurrence sur la taille mdu graphe. Le résultat est évident pour m=0 et m=1. On suppose le résultat
est vrai pour les graphe de taille m, et montrons que ceci est vrai pour un graphe de taille m+1. Soit donc Gun
graphe d’ordre nde taille m+1 ayant pcomposantes connexes.
•On suppose que Gest un graphe acyclique. Soit uvune arête de Gdans la composante C. Si on supprime uv,
la composante Cse transforme en deux composantes connexes (sinon on a un cycle dans G). Par la suite,
le graphe G′=G−uvest un graphe acyclique d’ordre n, de taille met ayant p+1 composantes connexes.
Donc d’après l’hypothèse de récurrence :
ν(G′)=0=(m−1)−n+(p+1)=m−n+p=ν(G)
•Maintenant, si Gcontient un cycle Wdans la composante connexe C. Soit uvune arête de W, alors si on
supprime l’arête uv, la composante Creste connexe. Donc le graphe G′=G−uvest un graphe d’ordre nde
taille m−1 ayant pcomposantes connexes. Donc, d’après l’hypothèse de récurrence :
ν(G′)=(m−1)−n−p≥0
=⇒ν(G)=m−n−p≥1>0
D’où le résultat – car si ν(G)=0,Gne peut être que acyclique, sinon 0 =ν(G)≥1/exclamati⌢n-triangle
2.3.1 Codage et décodage d’un arbre – Prüfer code
Soit Tun arbre ayant nsommet numérotés {1,2,..., n}. Le codage de Prüfer représente l’arbre Tarbre de avec
une suite P=(x1,x2,x3,..., xn−2) de n−2 termes (les n° des sommets avec répétition possible). Une suite Pdonnée
correspond à un et un seul arbre numéroté. Voici les algorithmes de codage et de décodage.
Algorithme 2 : Codage de Prüfer
Entrées : Un arbre T
Output : Séquence de Prüfer P
1P←() ; // Initialisation de P comme séquence vide
2tant que v(T)>2faire
3 x←feuille de Tayant le n° minimum ; // donc d(x)=1
4 P←(P,s) où sest le seul (n°) sommet adjacent à x;
5 T←T−x;
6fin
7retourner P;
Example 2.2
Donner le code de Prüfer de l’arbre :
126 345
Indice : on trouve, P=(2,3,3,2)
Pour faire la réciproque, étant donnée une séquence P=(x1,x2,..., xn−2) où les xi∈{1,2,..., n}, on construit
l’arbre Tdont les sommets sont {1,2,..., n} avec l’algorithme suivant (le décodage) :H. SABRI 19
Algorithme 3 : Décodage de Prüfer
Entrées : Une séquence Pde taille n−2
Output : L ’arbre Tcorrespondante
1I←{1,2,..., n};
2T←graphe tel que V(T)=IetE(T)= ; ; // T graphe à n sommets isolés
3tant que P̸=()faire
4 i←min {x∈I:x∉P};
5 T←T+(i,P[1]) ; // ajouter l'arc (i,P[1])
6 P←P−P[1];I←I−{i};
7fin
8T←T+(a,b) ; // a,b sont les deux éléments restant dans I
9retourner T;
Example 2.3
Donner l’arbre dont le code de Prüfer est : P=(2,3,3,3)
Puisqu’il ya une bijection entre les arbres d’ordre net les suites Pde longueur n−2 à coefficients dans {1,2,..., n},
on déduit le théorème de Cayley :
Théorème 2.6 Formule de Cayley
Le nombre d’arbres que l’on peut construire sur n(n≥2) sommets numérotés est égal à nn−2.
2.3.2 Arbre couvrant de poids minimum – ACM
Soit Gun graphe (non orienté). Un arbre couvrant (spanning tree) TdeGest un sous graphe couvrant de G
tel que Test un arbre. Remarquer que, Gdoit être connexe, sinon un arbre couvrant de Gn’existe pas. Le nombre
des arbres couvrant de Gest noté a(G). Remarquer que a(Kn)=nn−2(le nombre de Cayley). Un problème algo-
rithmique classique est de trouver, dans un graphe valué , un arbre couvrant de poids minimal . On dispose de
plusieurs algorithmes (l’algorithme de Prim, l’algorithme de Kruskal ...).
Algorithme 4 : Kruskal
Entrées : Un graphe Gvalué d’ordre net de taille m
Output : Arbre (ou forêt) couvrant de poids minimum
1Numéroter les arêtes de Gpar poids minimum : w(e1)≤w(e2)≤ ··· ≤ w(em)
2T←graphe tel que V(T)=V(G) etE(T)= ; ; // T graphe à n sommets isolés
3k←0;
4tant que k<m et e (T)<n−1faire
5 siT+ek+1est acyclique alors
6 T←T+ek+1;
7 k←k+1;
8fin
9retourner T;
Appliquer l’algorithme de Kruskal dans le graphe suivant :
CHAPITRE 3
Les algorithmes de base
Beaucoup de problèmes sur les graphes nécessitent que l’on parcourt l’ensemble des sommets et des arcs. Par
exemple, pour vérifier que le graphe est connexe, chercher un sommet particulier, construire un arbre couvrant,
trouver un plus court chemin ...etc.
3.1 Parcours en profondeur (DFS) / largeur (BFS)
Une manière simple de tester si un graphe Gest connexe ou non est d’exécuter l’algorithme DFS ouBFS dans
Gen commençant par n’importe quel sommet et en enregistrant les sommets visités pendant l’exécution dans une
liste. Si la liste contient tous les sommets de G, alors Gest connexe. Une petite modification permet de donner les
composantes connexes de G. L ’algorithme DFS_Component suivant donne les composantes connexes de G. Il est
donné sous forme d’implémentation récursive.
Algorithme 5 : DFS_Component
Entrées : Un graphe G=(V,E)
Output : Les composantes connexes C=(C1,C2,..., Ck) de G.
1VisitedNodes ← ; ;
2k←0 ; // k est le nombre des composantes connexes
3pour chaque u∈Vfaire
4 siu∉VisitedNodes alors
5 k←k+1;
6 DFS( u);
7 fin
8fin
9retourner (C1,C2,..., Ck);
1Procedure DFS( u )
2 VisitedNodes ←VisitedNodes ∪{u};
3 Ck←Ck∪{u};
4 pour chaque x∈Γ(u)faire
5 six∉VisitedNodes alors
6 DFS( x);
7 fin
8 fin
Note : -
Il est possible de d’implémenter la procédure DFS itérativement à l’aide d’une pile LIFO (stack) contenant les
sommets à explorer : on désempile un sommet et on empile ses voisins non encore explorés.
20H. SABRI 21
Pseudocode :
stack . push ( root )
while stack . isEmpty ( ) = f a l s e do
node = stack . pop ( ) // so mark i t as v i s i t e d
for each x in node . childNodes do
i f x i s not v i s i t e d then
stack . push ( x )
. . .
endfor
endwhile
Example 3.1 (DFS )
Ici on empile (gris) les sommets les plus à droite, alors l’ordre des sommets visité (noir) est ( a,b,d,e,g,c,f).
Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b
 c
d
 e
f
g
a
b
 c
d e
f
ga
b
 c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g
L ’utilisation d’une file (FIFO) au lieu d’une pile transforme l’algorithme du parcours en profondeur en algo-
rithme de parcours en largeur ( BFS ). Avec BFS l’exemple précédent devient (en enfile le plus à gauche) :
Example 3.2 (BFS )
Ici, avec BFS, on enfile (gris) les sommets les plus à gauche d’abord, alors l’ordre des sommets visité (noir)
est ( a,b,d,e,g,c,f). Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b c
d
 e
f
g
a
b c
d
 e
f
ga
b c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g22 Chapitre 3. Les algorithmes de base
Exercice 3.1
1. Écrire la procédure BFS .
2. Utiliser DFS (ou BFS) pour la construction d’un arbre couvrant d’un graphe connexe. L ’appliquer
pour le graphe triangle.
3. Utiliser DFS pour écrire une procédure DFS_Cycle pour détecter un cycle dans un graphe.
On sait qu’un graphe orienté G=(V,E) est fortement connexe si pour chaque paire de sommets u,v∈V, il
existe un chemin de uàvet il existe un chemin de vàu. En d’autres termes, nous avons besoin d’une connectivité
dans les deux directions .
Une procédure pour tester si un graphe orienté est fortement connexe ou non peut être conçue avec l’idée
suivante. En partant d’un sommet arbitraire vdu graphe G, on exécute l’algorithme BFS ouDFS et l’on note les
sommets visités. Ensuite, on obtient la transposée de G,GT, en inversant la direction des arêtes de G, et l’on
exécute à nouveau l’algorithme BFS ou DFS à partir du sommet v. Si les sommets visités dans les deux cas sont
égaux à V, alors le graphe orienté est fortement connexe. Cette méthode est illustrée dans l’algorithme 6.
Algorithme 6 : Fortement_connexe
Entrées : Un graphe orienté G=(V,E)
Output : true siGest fortement connexe et false sinon
1X← ; ;
2Y← ; ;
3v←un sommet quelconque de V;
4X←DFS( G,v) ; // Enregistrez les sommets visités dans X
5GT←Gavec flèches inversées;
6Y←DFS( GT,v);
7siX=Y=Valors
8 retourner TRUE.
9sinon
10 retourner FALSE.
11fin
3.2 Recherche des chemins
3.2.1 Matrice d’adjacence et nombre de chemins
La puissance de la matrice d’adjacence Amontre qu’il y a des chemins (ou chaînes) de longueur kallant de xà
ycomme le montre le théorème suivant.
Théorème 3.1
Soit G=(V,E) un (di)graphe. On note V={1,2,..., n} et Asa matrice d’adjacence et Akla puissance k-ème
deA. Alors le terme d’indices i,jdeAkest le nombre de chemins (chaînes) de longueur kallant de iàj.
Preuve. Par récurrence sur k. Pour k=1 c’est clair. On suppose le résultat est vrai à l’ordre ket montrons qu’elle
est vrai pour k+1. Soit S=(si,j)=Ak. Si on a un chemin de iàjde longueur k+1, alors on va d’abord de ià un
sommet ravec kpas et puis de ràj. Or d’après l’hypothèse de récurrence on a si,rchemins possibles pour aller de
iàret finalement ar,jpas (1 ou 0) pour aller de ràj. Ainsi, le nombre totale possibles (i.e. tous les sommets r) est :
nX
r=1si,rar,j=³
Ak×A´
i,jH. SABRI 23
ce qui est bien le terme ( i,j) de la matrice Ak+1.
3.2.2 Plus court chemin et l’algorithme de Dijkstra
Dans cette partie on suppose que le (di)graphe G=(V,E,w) est valué positivement (i.e.∀e∈E,w(e)>0). Notre
objectif est de chercher un plus court chemin (i.e., un chemin de poids minimal ) d’un sommet ufixé à un sommet
quelconque de G.
Il est clair que l’on peut restreindre ce problème au cas d’un (di)graphe simple1. On suppose aussi que Gest
connexe (sinon, certains trajets sont impossibles). Il est aussi claire (d’après théorème 2.1), qu’un plus court chemin
est nécessairement un chemin élémentaire (path).
L ’algorithme de Dijkstra (1959) permet de calculer le plus court chemin entre un sommet particulier u(racine )
et tous les autres sommets. L ’algorithme fonctionne de la manière suivante :
Pour tout sommet vdeG, on associe une valeur T(v), initialisée à w(u,v) et une liste de sommets C(v) qui
correspond à un chemin de uàv. À la fin de l’algorithme, T(v) contient le poids minimal des chemins joignant uà
v(ou T(v)= ∞ siu↛v) et la liste C(v) réalise un tel chemin. Voici donc l’algorithme de Dijkstra :
Algorithme 7 : Algorithme de Dijkstra
Entrées : Un (di)graphe valué G=(V,E,w) et un sommet racine u
Output : Le coût minimum d’un chemin de uàv(∀v∈V) et un trajet pour chaque coût minimal obtenu
1∀v∈V,T(v)←w(u,v) etC(v)←(u,v); // Initialisation de T(v) et la liste C(v)
2X←{u};
3tant que X̸=Vfaire
4 Choisir v∈V−Xtel que ∀y∈V−X,T(v)≤T(y);
5 X←X∪{v};
6 pour chaque y∈V−Xfaire // Faire les mises à jours pour les autres sommets
7 siT(y)>T(v)+w(v,y)alors
8 T(y)←T(v)+w(v,y);
9 C(y)←[C(v),y]; // On ajoute à la liste C(v) l'élément y
10
11 fin
12 fin
13fin
Example 3.3
Voici une application de l’algorithme de Dijkstra au digraphe suivant. On prend Ecomme sommet racine.
EA
B
CD
FG
S5
4
21
12
2
34
4
215
7
1. En effet, passer par une boucle ne ferait qu’augmenter inutilement le poids de ce chemin. De même, si plusieurs arcs joignent deux
sommets, il suffit de conserver l’arc de poids minimal.24 Chapitre 3. Les algorithmes de base
Ainsi, pour l’initialisation, on a : X={E} et on a les valeurs :
v  E A B C D F G S
T(v) 0 5 4 2 ∞ ∞ ∞ ∞
C(v)(E,E) ( E,A) ( E,B) ( E,C) ( E,D) ( E,F) ( E,G) ( E,S)
Maintenant, on choisit (un seul choix) le sommet C, donc X={E,C}. Le tableau est mis à jour :
v  E A B  C D F G S
T(v) 0 5 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À l’étape suivante, on est forcé de choisir B. Ainsi, X={E,C,B} et la mise à jour est :
v  E A  B  C D F G S
T(v) 0 4 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À présent, on a le choix entre AetF. On choisit A. Donc X={E,C,B,A} et on a :
v  E  A  B  C D F G S
T(v) 0 4 3 2 6 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,B,A,D) ( E,C,F) ( E,C,G) ( E,S)
Puis, on prend le sommet F. D’où X={E,C,B,A,F} et :
v  E  A  B  C D  F G S
T(v) 0 4 3 2 5 4 5 11
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,S)
On prend Det on obtient X={E,C,B,A,F,D} et :
v  E  A  B  C  D  F G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Finalement, on prend Gpuis Set on voit que ceci ne change rien. D’où le tableau finale :
v  E  A  B  C  D  F  G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Ainsi le chemin minimum pour aller de EàSest de coût 10 et un trajet de coût minimal de EàSest : EC F DS .H. SABRI 25
3.3 Problèmes d’ordonnancement et chemin critique
Un problème d’ordonnancement peut-être représenté sous la forme d’un digraphe. Les sommets sont des évé-
nements (début et fin de la tâche) et les arcs des tâches, La longueur (ou poids) de chaque arc représente la durée
d’exécution de la tâche. Ainsi, la tâche correspondant à l’arc ( i,j) ne peut commencer que si toutes les tâches cor-
respondant à des arcs ( k,i) ont été complétées. On ajoute deux sommets pour le début (s) et de fin(t) du projet .
Le digraphe peut contenir des tâches fictives dedurée nulle afin de forcer certaines précédences (postériorité).
Ainsi, un réseau PERT est un digraphe valué G=(V,E,w,s,t) où la fonction poids (ou longueur) w:E→R+
etsle sommet source (début) et tle sommet puits (fin). Un chemin critique est un chemin de sàtdelongueur
maximale . S’il n’existe pas de chemin critique, le projet n’est pas réalisable (e.g. un circuit). Le temps minimal
requis pour l’exécution d’un projet réalisable est égal à la longueur d’un chemin critique. Les tâches figurant sur un
chemin critique sont aussi appelées critiques, ce qui s’explique par le fait que tout retard d’exécution d’une tâche
critique retarde d’autant l’exécution du projet.
3.3.1 Algorithmes de tri topologique et de chemin critique
Il faut d’abord numérotés les sommets de 1 à nde manière compatible au pré-ordre (rang) avec l’algorithme du
rang suivant (tri topologique) :
Algorithme 8 : Algorithme du rang
Entrées : Un digraphe G=(V,E) sans circuit
Output : Le rang r(v) de chaque sommet v∈Vde G
1r←0;X←V;
2R←{v∈X:Γ−
X(v)= ;} ; // l'ensemble des sommets de X sans prédécesseur dans X
3tant que X̸= ; faire
4 r(v)←rpour chaque sommet v∈R;
5 X←X−R;
6 R←l’ensemble des sommets de Xsans prédécesseur dans X;
7 r←r+1;
8fin
On supposera dorénavant que les sommets ont déjà été numérotés de 1 à nde manière compatible avec leurs
rangs, c’est-à-dire que r(j)>r(i) implique j>i(donc 1 =setn=t). Enfin, on supposera éliminés les arcs paral-
lèles par l’introduction de tâches fictives de durée nulle .
Pour un sommet i, on note tiledébut au plus tôt des tâches correspondant aux arcs i→jet par Tilafin au
plus tard des tâches correspondant aux arcs j→i.
Algorithme 9 : Algorithme du chemin critique
Entrées : Un digraphe G=(V,E) sans circuit trié topologiquement
Output : La durée du chemin critique et les dates ti,Ti
1t1←0;
2pour j=2···nfaire // Calcul des dates de début au plus tôt  récurrence en avançant
3 tj←max i∈Γ−(j){ti+w(i,j)}
4fin
5Tn←tn;
6pour j=n−1···1faire // Calcul des dates de fin au plus tard  récurrence en reculant
7 Tj←min i∈Γ+(j){Ti−w(j,i)}
8fin26 Chapitre 3. Les algorithmes de base
Définition 3.1
— Un sommet iest critique si ti=Ti.
— Un arc ( i,j) est critique les sommets ietjsont critiques ettj−ti=w(i,j).
— Un chemin critique est un chemin de 1 à nn’utilisant que des arcs critiques.
— La durée du chemin critique est donnée par Tn(ou par tn). Elle correspond à la durée minimale du
projet .
Example 3.4
L ’application de l’algorithme du chemin critique au digraphe suivant (trié topologiquement) est :
1 23
45
6B
9A
3
C
5D
8
E
4
F7G
20
H6I5
=⇒
 1
0,02
9,933,16
4
16,23513,24
6
29,29B
9A
3
C
5D
8
E
4
F7G
20
H6I5
Les tâches critiques sont BetG. La durée totale minimale du projet est donc 29.
Exercice 3.2
Les tâches ( durée et précédences ) pour la construction d’un entrepôt sont données dans le tableau suivant :
Tâches Nature Précédences Durée (jours)
A Acceptation des plans par le propriétaire – 4
B Préparation du terrain – 2
C Commande des matériaux A 1
D Creusage des fondations A, B 1
E Commande des portes et fenêtres A 2
F Livraison des matériaux C 2
G Coulage des fondations D, F 2
H Livraison des portes et fenêtres E 10
I Pose des murs, de la charpente et du toit G 4
J Mise en place des portes et fenêtres H, I 1
1. Représentez le graphe des précédences de ce projet (trié topologiquement).
2. Déterminez une durée totale minimale en exhibant un chemin critique dans ce graphe.CHAPITRE 4
Programmation linéaire
La programmation linéaire est le processus de minimiser ou maximiser une fonction objective linéaire sou-
mise à un nombre fini de contraintes d’égalités et d’inégalités linéaires.
La programmation linéaire a de nombreuses applications dans le domaine de l’informatique théorique. Elle
peut être utilisée pour résoudre de nombreux problèmes combinatoires variés, tels que la recherche de flot maxi-
mum dans un réseau, la recherche d’un couplage maximal dans un graphe et la coloration d’un graphe parfait.
Example 4.1 (Problème de régime)
On suppose qu’on a quatre plats : de la truite ( XT), un sandwich au corned-beef ( XC B), un burrito ( XBU R )
et un hamburger ( XHB). Le tableau suivant répertorie la valeur nutritionnelle de chaque plat (vitamines et
calories) et notre besoin journalier des vitamines.
Vit. A Vit. C Vit. D Calories
Truite 203 92 100 600
Corned-beef 90 84 230 350
Burrito 270 80 512 250
Humburger 500 90 210 500
Besoins 2000 300 430
Notre objectif est de minimiser le nombre total de calories consommées : 600 XT+350XC B+250XBU R+
500XHBtout en satisfaisant les trois besoins nutritionnels en vitamines. Le programme linéaire résultant
s’écrit :
min 600 XT+350XC B+250XBU R+500XHB
s.t. 203 XT+90XC B+270XBU R+500XHB≥2000, (Besoins de Vit. A),
92XT+84XC B+80XBU R+90XHB≥300, (Besoins de Vit. C),
100XT+230XC B+512XBU R+210XHB≥430, (Besoins de Vit. D),
XT,XC B,XBU R ,XHB≥0
Définition 4.1: Forme canonique – Forme standard
On peut écrire un P .L. sous deux formes spéciales :
•Canonique
max
mincTX+c0
s.t. AX≤b(≥bsi min),
X≥0•Standard
max cTX+c0
s.t. AX=b,
X≥0Avec :
cTX=¡
c1··· cn¢
x1
...
xn

cTX+c0=c1x1+c2x2+···+ cnxn+c0
2728 Chapitre 4. Programmation linéaire
Remarque 9. Un P .L. général peut être formulé selon une forme standard ou canonique par la méthode suivante :
générale =⇒ standard il faut éliminer les contraintes d’inégalité et les variables sans contrainte de positivité.
— Si dT
iX≤biest une contrainte d’inégalité, alors créer une nouvelle variable ( d’écart ) siet remplacer l’in-
égalité dT
iX≤bipar dT
iX+si=biet s i≥0.
Si dT
iX≥bi, alors on peut écrire dT
iX−si=biet s i≥0.
— Si une variable x i≶0est de signe quelconque, alors créez deux nouvelles variables x+
iet x−
iet remplacez
xipartout par x+
i−x−
i, et ajoutez les contraintes de signe : x+
i≥0,x−
i≥0.
générale =⇒ canonique
— Si dT
iX=biest une contrainte d’égalité, alors remplacer cette égalité par une paire d’inégalités :
dT
iX≥biet−dT
iX≥ −bi
— Même chose que précédemment si la variable x i≶0.
Il est facile de voir que les problèmes qui en résultent sont équivalents aux problème d’origine. Pour l’algorithme
simplexe , nous utiliserons la forme standard .
On remarque aussi qu’en utilisant la relation min f(x)= − max¡
−f(x)¢
dans laquelle f (x)représente la fonction-
nelle linéaire à optimiser, on peut toujours se ramener à un problème de minimisation (ou de maximisation).
Example 4.2
Le P .L :max 5 x+4y
s.t. x≤6
1
4x+y≤6
3x+2y≤22
x,y≥0s’écrit sous forme standard :max 5 x1+4x2
s.t. x1+e1=6
1
4x1+x2+e2=6
3x1+2x2+e3=22
x1,x2,e1,e2,e3≥0
Donc (sous la forme matricielle) on a :
cT=¡
5 4 0 0 0¢
;A=
1 0 1 0 0
1
41 0 1 0
3 2 0 0 1
;X=
x1
x2
e1
e2
e3
et b=
6
6
22

4.1 La méthode simplexe
4.1.1 Solution de base admissible
On suppose que la matrice Adu programme linéaire est de type m×netde rang m(pourquoi !). Soit Bla
matrice carrée extraite de Aformée par les mcolonnes j1,j2,..., jmlinéairement indépendants de A(les vecteurs
de base). Alors, Best une matrice inversible. Ainsi si on pose xl=0 sil∉{j1,..., jm} etxjklak-ième composante de
B−1b. Alors, on a AX B=b. Si de plus XB≥0(i.e. chaque xi≥0), alors :
Xest une solution de base admissible (ou réalisable)
Dans l’exemple 4.2, la matrice extraite B=
1 0 0
0 1 0
0 0 1
est inversible et B−1b=
6
6
22
. Donc XB=
0
0
6
6
22
≥0, par suite
XBest une solution de base admissible. On appelle les variables xjklesvariables de base . Les autres variables xl
sont les variables hors-base .
Parfois, il n’est pas évident de trouver une solution de base admissible, comme le montre l’exercice suivant :H. SABRI 29
Exercice 4.1
Écrire le programme linéaire suivant sous forme standard et montrer qu’on n’a pas une solution de base
admissible. Résoudre le programme linéaire.
max −x+y
s.t. x+y≥1,
3x+2y=6,
x,y≥0
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux
Dans cette section, on suppose qu’on a déjà trouvé une solution de base admissible X(produite avec B=Im)
du programme linéaire ( P: max z=cTX+c0etb≥0pour garantir que 0est une solution de AX≤b).
La méthode du simplexe est une méthode itérative qui génère une séquence de solutions de base réalisable
(correspondant à différentes bases) et s’arrête finalement lorsqu’elle a trouvé une solution de base réalisable opti-
male. Remarquer qu’on peut toujours prendre c0=0.
Algorithme 10 : Algorithme du simplexe
Entrées : Un P .L. standard P(max) avec une solution de base réalisable
Output : La solution optimale (ou non)
1On commence à écrire le tableau initiale (avec les variables de base xj1,..., xjm)
VB x1 ... xn b
xj1 b1
... A...
xjm bm
c1 ... cn−c0
2Sicj≤0 (∀j:xjest hors base), alors solution optimale (STOP) // min ⇝cj≥0
3Trouver la colonne s(hors base) tel que cs=max©
cj:cj>0ª// min ⇝cs=min©
cj:cj<0ª
4Siai,s≤0∀i=1... m, alors pas de solution optimale (STOP)
5Min Ratio Test : trouver la ligne rtel que
br
ar,s=min
i=1...m½bi
ai,s:ai,s>0¾
6Appliquer la procédure de Gauss autour de pivot ar,s(ar,s⇝1 et on annule les coefficients situés sous et
sur le pivot dans la colonne s, par combinaisons de lignes) // Ne pas oublier la dernière ligne
7Remplacer (dans VB) la variable de base ( sortante ) située à la ligne rpar la variable ( entrante )xs
8Retourner à l’étape 2 // l'algorithme termine si le programme linéaire est non dégénéré
Remarque 10.
— La dernière ligne représente l’équation linéaire −z+c1x1+···+ cnxn= −c0.
— La valeur de la variable de base de V Bde la ligne k est égale à la valeur b k(de la ligne k).
— La solution optimale du problème est la valeur finale (dernière cellule) (×− 1).
— Si on n’a pas au départ B =Im(à l’aide des variables d’écart) alors, on ajoute les variables artificielles (et on
applique d’abord la phase I - voir section suivante).30 Chapitre 4. Programmation linéaire
Exercice 4.2
Soit le programme linéaire :
max 2 x1+x2
s.t. x1−x2≤3,
x1+2x2≤6,
−x1+2x2≤2,
x1,x2≥0
Rajouter les variables d’écart. Puis résoudre le problème par l’algorithme du simplexe.
Remarque 11. Vérifier le résultat de l’exercice précédent, par la méthode graphique.
4.1.3 Initialisation - Phase I du simplexe
Un programme linéaire est dit sous forme simpliciale si la matrice Acontient la matrice identité Imcomme
sous matrice. On suppose que le programme linéaire P, après la mise en forme AX=b, n’est pas simpliciale
(possible dans le cas de contraintes du type ≥ou du type =). Soit Bune matrice d’ordre mextraite de Ainversible
tel que B−1b≥0et soit XBla solution de base réalisable ( XB≥0etAX B=b), alors on peut changer l’équation
matricielle :
AX B=b
⇐⇒ (B−1A)XB=B−1b
⇐⇒ A∗XB=b∗
et la matrice A∗contient la matrice identité Imcomme matrice extraite ( B−1A=B−1(H|B)=¡
B−1H|Im¢
). Ainsi, on
peut appliquer directement l’algorithme 10 en remplaçant Apar A∗etbpar b∗. Cependant, cette méthode n’est
pas efficace, car il faut trouver une matrice extraite Bréalisable correspondante. Pour une matrice Ade type m×n,
il existe¡m
n¢
matrices extraites à tester !
L ’idée est d’ajouter des variables, dites artificielles w1,w2,..., wm, pour faire apparaître une forme simpliciale
du programme linéaire P: (AX=b). Mais, il faut que w1= ··· = wm=0. Donc, il faut minimiser d’abord le pro-
gramme linéaire P0suivant :
P0=min W=w1+···+ wm
s.t. (A|Im)×(x1...xnw1...wm)T=b
x1,..., xn,w1,..., wm ≥0
On exprime Wà l’aide des autres variables (hors base) et puis on applique l’algorithme du simplexe 10 pour P0
(phase I). À la fin, si on trouve que les wi=0, alors les variables de bases xj1,..., xjmforment une première base
admissible pour démarrer le simplexe pour le programme d’origine P.H. SABRI 31
Remarque 12. On ajoute la ligne de Z :c1 ... cn−c0dans le tableau du simplexe de P0(phase I) et on lui
applique les opérations élémentaire comme avec les autres lignes. À la fin de la phase I, on supprime les colonnes des
wiet la ligne de la fonction W . Finalement, on utilise ce tableau pour résoudre le problème initiale P.
Example 4.3
Soit le programme linéaire P:
min 6 x1+3x2
s.t. x1+x2≥1,
2x1−x2≥1,
3x2≤2,
x1,x2≥0sous forme standard (max)= = = = = = = = = = = = = = = = = = ⇒max Z= −6x1−3x2
s.t. x1+x2−e1=1,
2x1−x2−e2=1,
3x2+e3=2,
x1,x2,e1,e2,e3≥0
La matrice Aest :
A=x1 x2 e1 e2 e3

1 1 −1 0 0
2−1 0 −1 0
0 3 0 0 1
est par suite Pn’est pas sous forme simpliciale (il n’ ya pas de sous matrice I3). Donc on peut ajouter 2
variables artificielles pour construire le problème initiale P0:
max −w1−w2=3x1−e1−e2−2
s.t. x1+x2−e1+w1=1,
2x1−x2−e2+w2=1,
3x2+e3=2,
x1,x2,e1,e2,e3,w1,w2≥0dont le vecteur X=

0 x1
0 x2
0 e1
0 e2
2 e3
1 w1
1 w2est une solution de base réalisable.
Ainsi, on commence notre algorithme 10 pour le programme P0. Le tableau initial est :
x1 x2 e1 e2 e3 w1 w2 b

w1 1 1 −1 0 0 1 0 1
w2 2−1 0 −1 0 0 1 1
e3 0 3 0 0 1 0 0 2
W: 3 0 −1−1 0 0 0 2
Z:−6−3 0 0 0 0 0 0
Le pivot c’est a2,1donc x1est la variable entrante et w2est sortante. On obtient après pivotement le tableau :
L2←1
2L2− − − − − − − − →
L1←L1−L2
L4←L4−3L2
L5←L5+6L2x1 x2 e1 e2 e3 w1 w2 b

w1 03
2−11
20 1−1
21
2
x1 1−1
20−1
20 01
21
2
e3 0 3 0 0 1 0 0 2
W: 03
2−11
20 0−3
21
2
Z: 0 −6 0 −3 0 0 3 3
Le pivot est a1,2(Min ratio test =1
3). On obtient alors :32 Chapitre 4. Programmation linéaire
L1←2
3L1− − − − − − − − →
L2←L2+1
2L1
L3←L3−3L1
L4←L4−3
2L1
L5←L5+6L1x1 x2 e1 e2 e3 w1 w2 b


x2 0 1−2
31
302
3−1
31
3
x1 1 0−1
3−1
301
31
32
3
e3 0 0 2 −1 1 −2 1 1
W: 0 0 0 0 0 −1−1 0
Z: 0 0 −4−1 0 4 1 5
Ainsi, la phase I se termine avec W=0 et x1=2
3,x2=1
3,e3=1 et e1=e2=w1=w2=0. Le tableau pour la
phase II est donc :
x1 x2 e1 e2 e3 b


x2 0 1−2
31
301
3
x1 1 0−1
3−1
302
3
e3 0 0 2 −1 1 1
Z: 0 0 −4−1 0 5
On remarque donc que les cj≤0, donc (STOP) la solution est optimale et le max est −5. Ainsi la solution
optimale pour le programme P=min6 x1+3x2est−(−5)=5=6×2
3+3×1
3.
4.2 Dualité
SoitPun P .L. sous forme canonique. Le programme dualDdePest définit par :
P=max z=cTX
s.t. AX ≤ b
X≥ 0le dual est= = = = = = = ⇒D=min w=bTY
s.t. ATY≥ c
Y≥ 0
Le programme Pest dit primal . On remarque que si Ade type m×n, alors X∈RnetY∈Rmpour le dual.
Théorème 4.1 Théorème de dualité
Si un problème primal ou dual admet une solution, alors l’autre problème admet aussi une solution et on a :
max z=cTX =
s.t. AX ≤ b
X≥ 0min w=bTY
s.t. ATY≥ c
Y≥ 0
Exercice 4.3
Soit le problème suivant de type régime :
D=min w=340x1+2400 x2+560x3
s.t. x1+2x2+x3≥ 1200
x1+3x2+2x3≥ 1400
x1+x2+3x3≥ 1500
x1,x2,x3≥ 0
Écrire le programme primal PdeD. Résoudre le programme Pet déduire la valeur minimale de w, a-t-on
besoin de faire les deux phases du simplexe ?
7} A B oS



HOUSSEM SABRI
Graphes et Optimisation
2`emeannée
LISI  LSI
Institut Supérieur des Sciences Appliquées et de Technologie de Sousse
A.U. 2023-2024
28 novembre 2023Table des matières
1 Les graphes 3
1.1 Définitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.1 Graphes non orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.2 Graphes orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.2 Opérations et quelques types de graphes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.3 Représentation d’un graphe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.1 Listes d’adjacences (ou de succession) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.2 Matrices d’adjacence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.3.3 Matrice d’incidence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2 La connexité 11
2.1 Les chaînes et les cycles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.2 Graphe connexe, eulérien, hamiltonien . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.3 Arbres . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.3.1 Codage et décodage d’un arbre – Prüfer code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.3.2 Arbre couvrant de poids minimum – ACM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3 Les algorithmes de base 20
3.1 Parcours en profondeur (DFS) / largeur (BFS) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
3.2 Recherche des chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.1 Matrice d’adjacence et nombre de chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.2 Plus court chemin et l’algorithme de Dijkstra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
3.3 Problèmes d’ordonnancement et chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
3.3.1 Algorithmes de tri topologique et de chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . 25
4 Programmation linéaire 27
4.1 La méthode simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.1 Solution de base admissible . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux . . . . . . . . . . . . . . . . . . . . . . . . 29
4.1.3 Initialisation - Phase I du simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
4.2 Dualité . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
2CHAPITRE 1
Les graphes
L ’exemple classique pour introduire la théorie des graphes est le problème des ponts de Königsberg, étudié par
Euler en 1736. Quel itinéraire doit-on suivre pour traverser chaque pont exactement une fois? Une telle prome-
nade n’existe pas, et c’est Euler qui donna la solution de ce problème en caractérisant les graphes que l’on appelle
aujourd’hui eulériens .
A
B
Ce1 e2
e3 e4
De5
e6e7
FIGURE 1.1 – Les ponts de Königsberg
Les graphes introduisent une simplification : les régions se transforment en des "points" (aussi appelés noeuds
ousommet ), les ponts se transforment en des lignes (aussi appelées arêtes ouarcs ), et ce principe s’applique dès
lors qu’une relation existe entre des objets. Les graphes relèvent de la combinatoire plutôt que de la géométrie (les
intersections, les longueurs, et la forme des arêtes n’ont aucune importance, sauf en ce qui concerne la lisibilité de
la représentation).
1.1 Définitions
Dans la suite, il est toujours supposé que les graphes sont finis, sauf indication contraire.
1.1.1 Graphes non orientés
Définition 1.1: Graphe
Un graphe Gest un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V{2}des pairs non ordon-
nées de V.Vest l’ensemble des noeuds (Vertices en anglais) et Ec’est l’ensemble des arêtes de G(Edges en
anglais). Lorsque e={x,y} est une arête, on dit que x, y sont les extrémités de cette arête, que eest incidente
enxet en y. On joint x et y par un trait et on dit que x, y sont adjacents (ou voisins). On note aussi e=x you
encore e=(x,y) (attention , dans ce cas : ( x,y)=(y,x)).
SiGest un graphe alors, on note par V(G) l’ensemble de noeuds et par E(G) l’ensemble des arcs.
Remarque 1.
— Une arête e ={x,x}s’appelle boucle .
— Dans un graphe, il peut exister des arêtes parallèles (on parle donc de multigraphe ).
Dans l’exemple des ponts on a : e 1=e2=(A,B).
34 Chapitre 1. Les graphes
— Un graphe est dit simple s’il ne comporte ni arêtes multiples ni de boucles, c’est-à-dire chaque paire de nœuds
distincts est reliée par au plus une arête, ou encore E (G)⊆P2(G).
Dans la plupart des cas, les graphes sont considérés comme simples par défaut.
Définition 1.2: ordre – taille – degré
Soit G=(V,E) un graphe.
1. On appelle ordre d’un graphe noté v(G) le nombre de ses sommets :
v(G)= |V|
2. On appelle taille d’un graphe noté e(G) le nombre de ses arêtes :
e(G)= |E|
3. Le degré (ou valence) d’un sommet xnoté d(x) est le nombre d’arêtes contenant x. (Attention! Une
boucle sur un sommet compte double).
Si on note par Γ(x) l’ensemble des voisins de x, i.e.
Γ(x)={y∈V:x y∈E}
alors, siGest simple , on a :
d(x)= |Γ(x)|
Example 1.1 (Graphe complet)
Un graphe d’ordre nest dit complet noté Knsi chaque sommet du graphe est relié directement à tous les
autres sommets, i.e. E(Kn)=P2(V(Kn)).
Représenter graphiquement K3,K4,k5. Calculer la taille de K3,k4,...Kn.
Example 1.2 (Graphe biparti)
Un graphe G=(V,E) est dit biparti si son ensemble de sommets V=V1˙∪V2, i.e. peut être divisé en deux
sous-ensembles disjoints V1etV2tels que chaque arête ait une extrémité dans V1et l’autre dans V2.
Si∀x∈V1,∀y∈V2;x y∈E, alors Gest dit biparti complet noté Kn,moùn= |V1|etm= |V2|.
a1
 a2
 a3
 a4
b1
 b2
 b3
FIGURE 1.2 – Un graphe biparti
Théorème 1.1 Lemme des poignées de main – Handshaking lemma
Soit Gun graphe alors, on a :X
x∈V(G)d(x)=2e(G)
Dans ce théorème d(x) est le nombre de personnes à qui xserre la main et e(G) le nombre total de poignées
de mains.H. SABRI 5
Preuve.
•Méthode simple Il y en a d(x) arêtes en un sommet xfixé. Pour tout les sommets cela fait doncP
x∈V(G)d(x).
Mais avec cette manière chaque arête est comptée deux fois, une fois à chacune de ses extrémités, d’où le
résultat en divisant par 2.
•Preuve par double dénombrement On pose
Z={(x,e)∈V×E:x∈e}⊆V×E
et les deux projections :
p:Z→V
(x,e)7→xet q:Z→E
(x,e)7→e
L ’idée est de calculer |Z|de deux manières différentes. D’abord, on rappelle que si f:A→Best une fonction
quelconque, alors :X
b∈B|f−1[b]| = | A|
oùf−1[b] désigne l’image réciproque de { b} par f(pourquoi ˙S
b∈Bf−1[b] est une union disjointe ?).
Ainsi on obtient :
|Z| =X
x∈V|p−1[x]| =X
e∈E|q−1[e]|
Or,|p−1[x]| =d(x) et|q−1[e]| = |{x∈V:x∈e}| =2. Donc :
X
x∈Vd(x)=X
e∈E2=2|E|
Remarque 2.
— Un sommet de degré 0est appelé sommet isolé .
— Un graphe tel que : ∀x∈V,d(x)=kest dit graphe k-régulier .
— Le graphe complet K nest un graphe (n−1)-régulier .
Exercice 1.1
Montrer que dans un graphe le nombre de sommets d’ordre impairs est toujours pair. En particulier un
graphe k-régulier avec kimpaire est un graphe d’ordre pair.
Voici quelques exemples comme application :
1. Est-il possible de relier 15 ordinateurs en réseau de sorte que chacun soit relié à exactement 3 autres ?
2. Une ligue de football comprenant 11 clubs organise un tournoi. Pour gagner du temps on décide que chaque
équipe ne jouera que la moitié des matches possibles. Comment organiser le tournoi ?
Proposition 1.1
Soit G=(V,E) un graphe (simple) d’ordre n≥2. Alors :
∃u,v∈V,u̸=v:d(u)=d(v)
Preuve. Supposons le contraire, c’est-à-dire ∀u,v∈V;d(u)̸=d(v). Or dans un graphe (simple) on a toujours d(x)∈
{0,1,..., n−1}. Dans ce cas, puisque tous les nsommets ont des degrés distincts, alors il existe une bijection
{d(x):x∈V}←→ {0,1,..., n−1}
Donc, il existe un sommet uavec un degré 0, et un sommet vavec degré n−1, donc vest connecté à tous les autres
sommets du graphe, ce qui signifie que une peut pas être un sommet isolé, d’où une contradiction.6 Chapitre 1. Les graphes
1.1.2 Graphes orientés
Les arêtes d’un graphe peuvent être orientées, auquel cas une flèche indique la direction. De tels graphes sont
appelés des graphes orientés ou des digraphes , et une arête ( a,b) dans un tel graphe indique que cette arête est
dirigée de sommet avers b, i.e. ( a,b)=− →ab̸=(b,a)=− →ba. D’où la définition :
Définition 1.3: Graphe orienté - digraphe
Un graphe orienté G(ou− →G) est un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V2des pairs
ordonnées de V.Eest l’ensemble des arêtes (ou flèches, arcs) de G. Lorsque e=(x,y) est une arête, on dit
que xestl’origine (ou sommet initiale) et yl’extrémité (ou sommet terminale) de e, que eest sortant en x
et incident en y, et que yest un successeur de xtandis que xest un prédécesseur de y. On note l’arête e
par :
e=(x,y)=− →x y=x→y
De la même façon, une arête x→xest une boucle. On peut toujours supprimer les boucles pour obtenir des
digraphes simples. Voici l’exemple d’un digraphe G=(V,E) d’une fonction f:E→Eoù ( x,y) est un arc si et seule-
ment si y=f(x). On l’appelle digraphe fonctionnelle.
0
3
1214
11 568
169
4
2 1
713 10
15
FIGURE 1.3 – Le digraphe fonctionnelle Gfdex7→(x2+3) mod 17.
Comme dans les graphes on peut définir les degrés (entrant, sortant) d’un sommet dans un digraphe.
Définition 1.4: indegree - outdegree
Soit G=(V,E) un digraphe. Pour v∈V, on note par :
d+(v) le degré extérieur (sortant - outdegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité initiale.
d+(v)= |{v→ •}|
d−(v) le degré intérieur (entrant - indegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité finale.
d−(v)= |{• → v}|
On définit le degré : d(v)=d−(v)+d+(v).
Un sommet de degré entrant non nul et de degré sortant nul est appelé puits , tandis qu’un sommet de
degré entrant nul et de degré sortant non nul est appelé source ouracine .
Dans un graphe orienté, les voisins d’un sommet vsont soit des successeurs ou des prédécesseurs. On les notes
par :
Γ+(x)=Succ (x)={y∈V:x→y∈E} et Γ−(x)=Pr ed (x)={y∈V:y→x∈E}H. SABRI 7
Si le digraphe est simple (ni boucle ni arcs parallèles) on a :
d−(v)= |Γ−(v)|et d+(v)= |Γ+(v)|
Proposition 1.2
Soit Gun digraphe, alors :X
v∈Vd−(v)=X
v∈Vd+(v)= |E|
Preuve. On a
E=˙[
v∈V{• → v}=˙[
v∈V{v→ •}
=⇒ | E| =X
v∈V|{• → v}| =X
v∈V|{v→ •}| =⇒ | E| =X
v∈Vd−(v)=X
v∈Vd+(v)
1.2 Opérations et quelques types de graphes
Une opération sur les graphes permet de construire un nouveau graphe comme résultat de l’opération. Les
opérations courantes sur les graphes sont la suppression, la valuation, l’union, l’intersection et le produit cartésien.
Graphe valué
Tout d’abord, on peut vouloir attribuer des valeurs aux arcs ou arêtes pour tenir compte de contraintes : dis-
tance, coût ...
Définition 1.5: (di)graphe valué
Un (di)graphe valué G=(V,E,w) est un (di)graphe muni d’une application w:E→R. L ’application west
appelée application poids ou coût. On indique sur chaque arête son poids (ou son coût). On note w(x,y)
au lieu de w((x,y)). On convient (même que ceci n’a pas de sens!) que w(x,y)= +∞ si (x,y)∉E.
ab
c
d
ef53
43
3
335
81
FIGURE 1.4 – Un digraphe valué
/pythonPython code : -
Implémenter le digraphe valué précédent avec python. Indice – use chatGPT : how to build a weighted digraph with
python8 Chapitre 1. Les graphes
Sous graphes
Soit G=(V,E) un graphe (orienté ou non). Un sous graphe de Gest un graphe de la forme G′=(V′,E′) où
V′⊆V,E′⊆Etels que toute arête de E′a ses extrémités dans V′(ou encore G′est aussi un graphe). On a :
•Sous-graphe induit Un sous-graphe G′=(V′,E′) de G=(V,E) est appelé un sous-graphe induit deGsi :
∀x,y∈V′; (x,y)∈E′⇐⇒ (x,y)∈E
En d’autres termes, deux sommets de G′qui sont connectés dans G, sont également connectés dans G′.
•Sous-graphe couvrant Un sous-graphe couvrant G′deGcontient tous les sommets de G, i.e. V′=V.
•G−vSupprimer un sommet vd’un graphe Gconsiste à supprimer vet toutes ses arêtes incidentes. Le sous-
graphe obtenu de cette opération est noté G−v, i.e.
V′=V−{v} et E′=E−{(v,y): (v,y)∈E}
De manière similaire, une arête epeut être supprimée (resp. ajoutée) d’un graphe G, et le sous-graphe
résultant est représenté par G−e(resp. G+e). Notez que la suppression d’une arête ne retire pas de sommets
du graphe.
•G−V′=G[V′] On supprimer tous les sommets v∈V′du graphe Gavec les arêtes incidentes. Le sous-graphe
obtenu de cette opération est noté G[V′], i.e.
V(G[V′])=V−V′et E(G[V′])=E−{(v,y)∈E:v∈V′}
•Clique Une clique Cd’un graphe Gest un sous-ensemble des sommets de Gdont le sous-graphe induit G′=
(C,E′) est un graphe complet, en d’autres termes, deux sommets quelconques de la clique Csont toujours
adjacents.
•Stable Un stable – appelé aussi ensemble indépendant (independent set en anglais) est un ensemble de som-
mets deux à deux non adjacents. Donc le sous-graphe induit est sans arcs.
FIGURE 1.5 – L ’ensemble des sommets en bleu dans ce graphe est un stable maximal du graphe.
Note : -
Le problème décisionnel de la clique (c’est à dire existe t-il une clique de taille k) est NP-complet . De même la
recherche d’un stable de taille maximum dans un graphe est un problème NP-complet et difficile à approximer.
Exercice 1.2
Trouver un plus grand stable et une plus grande clique du graphe suivant :
8
4
62 7
3
1 5
Indice : vérifier le résultat avec networkx.find_cliques(G) et.maximum_independent_set(G) de python.H. SABRI 9
Opérations binaires
Union L ’union de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∪H=(VF,EF) dans lequel
VF=VG∪VH et EF=EG∪EH
Intersection L ’intersection de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∩H=(VF,EF)
dans lequel
VF=VG∩VH et EF=EG∩EH
1.3 Représentation d’un graphe
Il est important de savoir comment représenter les graphes au sein d’un ordinateur. Il ya plusieurs méthodes
selon la nature des traitements que l’on souhaite appliquer au graphe considéré.
1.3.1 Listes d’adjacences (ou de succession)
Soit Gun (di)graphe. On suppose que les sommets de Gsont numérotés de S1àSn. La représentation par listes
d’adjacence de Gconsiste en un tableau (ou des listes chainées) tel que la ligne i=1... ncorrespond au sommet Si
et comporte la liste des voisins/successeurs (ou des prédécesseurs) de ce sommet notée T[Si]. Les sommets dans
chaque liste d’adjacence sont généralement listés selon un ordre arbitraire.
1
2
345
FIGURE 1.6 – Un digraphe
La liste d’adjacence de digraphe 1.6 est donc :
1 2 3 4 5
2 3
3 4
4−
5 1 410 Chapitre 1. Les graphes
1.3.2 Matrices d’adjacence
Définition 1.6: Mat. Adjacence
Soit G=(V,E) un graphe (orienté) d’ordre n. On peut numéroter V={1,2,..., n}.La matrice d’adjacence
deGest la matrice carrée A=(ai j) d’ordre n, définie par :
ai j=(
1 si ( i j)∈E;
0 sinon.
Remarque 3.
1. Si le graphe G est non orienté et simple, alors la matrice A est symétrique avec des 0sur la diagonale. Pour un
digraphe simple, on a toujours des 0sur la diagonale, mais la matrice n’est pas symétrique en général.
2. Pour les multigraphes, il peut y avoir des termes diagonaux (pour les boucles) et s’il y a plusieurs arêtes de i à
j , le coefficient de la matrice a i jest le nombre d’arêtes de i à j .
3. Pour un (di)graphe valué G =(V,E,w), on pose :
ai j=(
w(i,j)si(i j)∈E ;
∞ sinon.
La matrice d’adjacence de la figure 1.4 est :

∞ 5∞ 4 3 ∞
∞ ∞ 3∞ 1∞
∞ ∞ ∞ ∞ ∞ 5
∞ ∞ 3∞ 3 3
∞ ∞ ∞ ∞ ∞ 8
∞ ∞ ∞ ∞ ∞ ∞

1.3.3 Matrice d’incidence
Définition 1.7: Mat. Incidence
Soit G=(V,E) un graphe (simple) d’ordre net de taille m. On pose V={v1,v2,..., vn} etE={e1,e2,..., em}.
La matrice d’incidence deGest la matrice de type n×m B=(bi j), définie par :
•Si G orienté
bi j=

1 si ej=vi→ • (i.e. viest l’extrémité initiale de ej) ;
−1 si ej= • → vi(i.e. viest l’extrémité terminale de ej) ;
0 sinon.
•Si G non-orienté
bi j=(
1 si viest une extrémité de ej;
0 sinon.
Exercice 1.3
1. Donner la matrice d’incidence du graphe 1.6.
2. Montrer le théorème 1.1 avec la matrice d’incidence.CHAPITRE 2
La connexité
Il est important de savoir si on peut suivre un chemin d’un sommet donné à un autre dans un graphe donné.
Cette propriété (de connexité) doit être maintenue dans différents types de réseaux.
2.1 Les chaînes et les cycles
Définition 2.1: (chaine – cycle) (chemin – circuit)
•Graphe non orienté
1. Une chaîne (walk ) reliant xày, notée µ(x,y), est définie par une suite finie d’arêtes consécutives,
reliant xày, ou encore une séquence de sommets (puisque non multigraphe)
µ(x,y)=<v0,v1,..., vk>
tels que v0=x,vk=yet (vi−1,vi)∈E(G) pour tout i=1... k. Six=yla chaîne est dite fermée .
Lalongueur du chaîne l(µ(x,y)) est le nombre d’arcs dans la chaîne, c’est-à-dire k.
2. Une chaîne élémentaire (a path ) si tous les sommets sont distincts. Une chaîne simple (a simple
walk, a trail ) est une chaîne ne passant pas deux fois par une même arête, c’est-à-dire dont toutes
les arêtes sont distinctes. Remarquer que : élémentaire =⇒ simple.
3. Un cycle v0v1...vnde longueur n≥3 est une chaîne simple fermée ( v0=vn) tel que les sommets
v0,v1,..., vn−1sont tous distincts. Un graphe sans cycle est dit acyclique .
•Graphe orienté
Dans un graphe orienté, on parlera de chemin au lieu de chaîne, et de circuit au lieu de cycle.
Example 2.1
abxcd xa est une chaîne simple et fermée (non cycle!) de longueur 6 (mais, c’est un graphe eulérien - voir
plus loin). Y a-t-il un cycle de longueur 3,4 ?
a b
x
c dÏ
Remarque 4.
1. On peut pivoter une chaine fermée (l’orienter de manière arbitraire) , i.e.
<v0,v1,v2,..., v0>=< vk,vk+1,..., v0,v1,..., vk>
1112 Chapitre 2. La connexité
2. Soient x ,y∈V . La distance de x à y est définie par :
d(x,y)=(
k si le plus court chemin/chaîne de x vers y est de longueur k
∞ sinon
On convient que d (x,x)=0.
3. Le diamètre du graphe la plus grande distance entre deux sommets.
L ’observation suivante, bien que très facile à prouver, sera utile.
Théorème 2.1
S’il existe une chaîne du sommet yau sommet zdans le graphe G, où y̸=z, alors il existe une chaîne élé-
mentaire ( path ) dans Gavec pour premier sommet yet pour dernier sommet z.
Preuve. Soit la chaine
W1=µ(y,z)=x0x1...xn; avec x0=yetxn=z.
Si les sommets x0,x1,..., xnsont tous distincts, alors W1est une chaîne élémentaire, et nous avons terminé. Sinon,
il existe xi=xj(i<j) et on écrit :
W2=x0x1...xixj+1...xn.
Alors, l(W2)<l(W1). Si W2ne contient aucun sommet répété, alors c’est la chaîne recherché. Sinon, par la même
procédure, il existe W3(y z−chaîne) tel que
l(W3)<l(W2)<l(W1).
Ce processus doit s’arrêter à un certain stade, car chaque chaîne est plus courte que la précédente et la longueur
ne peut jamais être inférieure à 1
1< ··· < l(Wk)< ··· < l(W3)<l(W2)<l(W1).
Ainsi, pour un certain k,Wkne peut pas être réduit en longueur. Donc, la chaîne Wkne contient aucun sommet
répété et est donc une y z−chaîne élémentaire (path).
Exercice 2.1
Dans le graphe suivant, construire un path à partir de la chaîne W=v2v3v4v5v6v4v2v8v1
v1
 v2
v3
v4
v5
v6
v7
 v8
 v9
Calculer d(v1,v7) et le diamètre de G.
/pythonpython : >>G = nx.Graph([(1, 2), (2, 3), (2, 4), ...]) >>nx.diameter(G)
Les cycles fournissent la caractérisation suivante pour les graphes bipartis .H. SABRI 13
Théorème 2.2
Un graphe est biparti si et seulement s’il ne contient aucun cycle de longueur impaire.
Preuve.
⇒On suppose que G=U˙∪Vest un graphe biparti. Soit W=< x1,x2,..., x2k+1,x1>un cycle de longueur im-
paire (2 k+1). Si x1∈U, alors
x1∈U=⇒ x2∈V=⇒ x3∈U=⇒ ··· =⇒ x2k+1∈U=⇒ x1∈V/exclamati⌢n-triangle
absurde, d’où le résultat.
⇐On suppose que Gest connexe (car l’union des composantes connexes bipartis est un graphe biparti). Soit
xun sommet de Get on pose :
U={y∈V(G):d(x,y) est paire} et V={z∈V(G):d(x,z) est impaire}
S’il existe y1,y2∈Utel que y1y2∈E(G), alors on a :
W1=<x,..., y1>est une chaîne de longueur paire =2k1
W2=<x,..., y2>est une chaîne de longueur paire =2k2
=⇒ W3=<x,..., y1,y2,..., x>est un cycle de longueur impaire =2k1+2k2+1/exclamati⌢n-triangle
Donc G=U˙∪Vest un graphe biparti.
Exercice 2.2
Vérifier si le graphe maison est un graphe biparti. Faire de même pour la grille G4,4.
maison grille
2.2 Graphe connexe, eulérien, hamiltonien
Définition 2.2: Graphe connexe
Un graphe est dit connexe si deux points peuvent toujours être joints par une chaîne, i.e.
∀x,y∈V(G),d(x,y)< ∞
— Une composante connexe d’un graphe est un sous-graphe induit maximal connexe.
— Un point d’articulation d’un graphe est un sommet dont la suppression augmente le nombre de
composantes connexes.
Par exemple, le graphe suivant :14 Chapitre 2. La connexité
a
 b
d
 c
e
f
 g
n’est pas connexe car il n’existe pas de chaîne entre les sommets aete. On a donc 2 composantes connexes. En
revanche, le sous-graphe induit par les sommets { a,b,c,d} est connexe dont aest le seul point d’articulation.
Remarque 5.
1. Un graphe connexe à n sommets possède au moins n −1arêtes ( faite une preuve par récurrence ).
2. L’algorithme de parcours en profondeur permet de déterminer si un graphe est connexe ou non.
3. Même définitions dans un graphe orienté . Graphe orienté (fortement) connexe et de composante connexe .
Définition 2.3: Graphe eulérien
— Une chaîne joignant deux sommets xetyest dite chaîne eulérienne si elle emprunte chaque arête
deGune et une seule fois. On parle de chemin eulérien dans le cas d’un graphe orienté.
— Un cycle eulérien est une chaîne eulérienne dont les extrémités coïncident. Un graphe qui admet
un cycle (resp. circuit) eulérien est dit graphe eulérien .
/flushedRemarquer qu’un cycle eulérien n’est pas forcément un cycle comme définit dans la définition 2.1
Si un graphe (ou multigraphe) Gpossède une chaîne eulérienne, alors soit Gpossède deux sommets impairs, le
début et la fin de cette chaîne, soit Gn’a aucun sommet impair, et la promenade d’Euler commence et se termine
au même point (cycle eulérien). Une autre condition nécessaire évidente est que Gdoit être connexe. Ces deux
conditions sont ensemble suffisantes.
Théorème 2.3 Euler
Soit Gun graphe (multigraphe) connexe.
— Si Gn’a pas de sommets impairs, alors il possède un cycle eulérien (commençant à n’importe quel
point).
i.e.∀x,d(x)≡0 mod 2 =⇒ Gest un graphe eulérien.
— Si Ga deux sommets impairs, alors il possède une chaîne eulérienne dont le début et la fin sont les
sommets impairs.
La réciproque est aussi vraie.
Preuve.
⇐On commence par la réciproque. S’il existe une chaîne eulérienne µ(x,y), alors on peut crée une arête fictive
e=(y,x) et par la suite on obtient un cycle eulérien. Donc il suffit de montrer que si Gadmet un cycle
eulérien alors tous les sommets sont de degré pair.
Soit W=< v1,v2,..., vn,v1>un cycle eulérien. Soit le sommet vjavec j̸=1, il est donc claire que chaque
fois vjapparaît dans W, il ya deux arcs distincts incidents en vj( (•,vj) et ( vj,•)). Comme toutes les arêtes
sont utilisées, on voit que d(vj) est pair. Même chose pour v1car on ajoute deux arcs ( v1,v2) et ( v1,vn).
⇒On suppose que tous les sommets sont de degré pair. Montrons que Gadmet un cycle eulérien. Puisque
tous les sommets sont de degré pair on peut construire d’abord une chaîne simple fermée (quelconque)
W1=<v1,v2,..., vk,v1>
SiW1contient chaque arête de G, alors c’est finis, c’est un cycle eulérien. Sinon (puisque Gest connexe), il
existe une arête e=(vi,c) qui n’est pas dans W1(avec visommet de W1). On pose le sous-graphe
G′=G−{ arêtes de W1}H. SABRI 15
Il est donc claire que les sommets de G′sont aussi de degré pair. Alors, par la même procédure on construit
une chaîne simple fermée dans G′de la forme : <vi,c,d,..., vi>et par la suite on insère cette chaîne dans
W1pour obtenir :
W2=<v1,v2,..., vi,c,d,..., vi,vi+1,..., vk,v1>
Sil(W2)< |E(G)|, on construit W3de longueur plus grand. Ainsi, on a :
l(W1)<l(W2)<l(W3)< ··· ≤ | E(G)|
Donc, nécessairement, il existe Wk(chaîne simple fermée de longueur |E(G)|) donc c’est un cycle eulérien.
Finalement , si∃a,b∈V(G):d(a)≡d(b)≡1 mod 2, et tous les autres sommets sont de degré pair, alors on
pose :
G′=G+{a,b}
et donc tous les sommets de G′sont de degré pair. Avec la construction précédente, il existe un cycle eulérien
dans G′:
W=<a,b,v1,..., a>
est donc la chaîne <b,v2,..., a>est une chaîne eulérienne dans G.
Algorithme 1 : Euler
Entrées : Gun graphe eulérien
Output : Un cycle eulérien W
/* On suppose que G est eulérien, i.e. les sommets sont de degré pair */
1Gaux←G;W←µ(v,v) une chaîne simple (quelconque) de G; // Initialisation
2tant que l(W)<e(G)faire
3 Gaux←G−{ arêtes de W} ;
4 Choisir ( x,c)∈E(Gaux) tel que x∈W;
5 L←< x,c,..., x>une chaîne simple de Gaux ;
6 Dans W, remplacer (juste ce) xpar la séquence L;
7fin
8retourner W;
Exercice 2.3
1. Montrer que le graphe de l’exercice 2.1 est un graphe eulérien et donner un cycle eulérien.
2. Tracer cette maison d’un seul trait.
Remarque 6. Le théorème d’Euler dans un graphe orienté connexe s’écrit :
Admet un circuit eulérien si, et seulement si, pour tout sommet, le degré entrant est égal au degré sortant.
∀v∈V(G),d+(v)=d−(v)
Admet un chemin eulérien de a vers b si, et seulement si,


d+(v)=d−(v) ;∀v̸=a,b,
d−(a)=d+(a)−1
d−(b)=d+(b)+116 Chapitre 2. La connexité
Définition 2.4: Graphe hamiltonien
Soit Gun graphe connexe d’ordre n. On appelle :
1. On appelle cycle hamiltonien deGun cycle passant (une et une seule fois) par chacun des sommets
deG. Un graphe est dit hamiltonien s’il possède un cycle hamiltonien.
2. Une chaîne hamiltonienne est une chaîne passant une et une seule fois par chacun des sommets de
G. Un graphe ne possédant que des chaînes hamiltoniennes est semi-hamiltonien .
3. Dans un digraphe, on change cycle par circuit et chaîne par chemin .
Remarque 7.
— Une chaîne hamiltonienne est une chaîne élémentaire de longueur n −1.
— Un graphe peut être eulérien, hamiltonien, les deux à la fois, ou aucun des deux.
— De nombreux problèmes concrets peuvent être formulés en termes de recherche de parcours hamiltoniens : pro-
blème du voyageur de commerce (chercher un cycle hamiltonien de longueur totale minimale), l’ ordonancement
de tâches .
— Le problème du chaîne hamiltonienne est un problème NP-complet .
Exercice 2.4
Donner un graphe (connexe, simple) qui soit :
1. hamiltonien et eulérien.
2. hamiltonien et non eulérien.
3. eulérien et non hamiltonien.
4. non hamiltonien et non eulérien.
Aucune condition nécessaire et suffisante adéquate n’est connue pour l’existence de cycles hamiltoniens. Le
résultat suivant constitue une condition suffisante utile.
Théorème 2.4 Ore
Soit Gun graphe simple d’ordre n≥3. Si pour toute paire { x,y} de sommets non adjacents, on a d(x)+d(y)≥
n, alors Gest hamiltonien.
Preuve. On suppose que le théorème est faux. Alors, il existe un graphe Gsimple d’ordre nnon hamiltonien tel que
d(u)+d(v)≥npour tout sommets non adjacents uetv. On prend Gun tel graphe d’ordre nde taille maximale qui
vérifie cette propriété (remarquer que le graphe complet Knest hamiltonien).
Soient uetvdeux sommets non adjacents de G. Par maximalité de G, le graphe G+uv(d’ordre n) doit être
hamiltonien. Donc il existe dans G+uvun cycle hamiltonien :
W=<u,x1,x2,..., xn−2,v,u>
u
x1
xi xi+1xn−2
v
... ...
Or, si uxi+1∈E(G) etv xi∈E(G) (les arcs en rouge), alors on peut construire dans Gle cycle hamiltonien :
<u,x1,x2,..., xi,v,xn−2,..., xi+1,u>H. SABRI 17
Ceci est absurde car Gest non hamiltonien. Donc si xi+1est un sommet voisin à u, alors le sommet xin’est pas
voisin de v:
xi+1∈Γ(u)=⇒ xi∉Γ(v)
Donc :
d(u)= |Γ(u)| =p=⇒ d(v)≤(n−1)−p
et par la suite
d(u)+d(v)≤n−1
ce qui absurde par hypothèse. Donc Gest hamiltonien.
Une conséquence immédiate est le théorème de Dirac :
Proposition 2.1 Dirac
Soit Gun graphe simple d’ordre n≥3. Si pour tout sommet xdeG, on a d(x)≥n
2, alors Gest hamiltonien.
2.3 Arbres
Définition 2.5: Arbres et forêts
On appelle arbre tout graphe (non orienté) connexe et acyclique . Les composantes connexes dans un
graphe acyclique sont des arbres et le graphe est dit forêt . Une feuille ou sommet pendant est un som-
met de degré 1.
Un forêt avec deux arbres
Un graphe Gest une arborescence s’il existe un sommet Rappelé racine deGtel que, pour tout sommet
SdeG, il existe un chemin et un seul de Rvers S. Donc, c’est un arbre orienté dans lequel on choisit un
sommet Rcomme racine et on dirige les arcs vers le sens sortant de la racine.
Remarque 8.
— Un graphe G d’ordre n est un arbre ssi G est sans cycle et possède n −1arêtes.
— Un graphe G d’ordre n est un arbre ssi G est connexe et possède n −1arêtes.
— G est un arbre si pour chaque paire u ,v de sommets distincts est reliée par une seule chaîne (donc chaîne
élémentaire d’après le théorème 2.1).
— Un arbre (ou forêt) est nécessairement un graphe simple.
Pour démontrer les remarques précédentes, il suffit de prouver le théorème suivant :
Théorème 2.5
Soit Gun graphe ayant marêtes, nsommets et pcomposantes connexes, on définit nu( G) :
ν(G)=m−n+p
Alors, on a :
1.ν(G)≥0.
2.ν(G)=0⇐⇒ Gest acyclique.18 Chapitre 2. La connexité
Preuve. Par récurrence sur la taille mdu graphe. Le résultat est évident pour m=0 et m=1. On suppose le résultat
est vrai pour les graphe de taille m, et montrons que ceci est vrai pour un graphe de taille m+1. Soit donc Gun
graphe d’ordre nde taille m+1 ayant pcomposantes connexes.
•On suppose que Gest un graphe acyclique. Soit uvune arête de Gdans la composante C. Si on supprime uv,
la composante Cse transforme en deux composantes connexes (sinon on a un cycle dans G). Par la suite,
le graphe G′=G−uvest un graphe acyclique d’ordre n, de taille met ayant p+1 composantes connexes.
Donc d’après l’hypothèse de récurrence :
ν(G′)=0=(m−1)−n+(p+1)=m−n+p=ν(G)
•Maintenant, si Gcontient un cycle Wdans la composante connexe C. Soit uvune arête de W, alors si on
supprime l’arête uv, la composante Creste connexe. Donc le graphe G′=G−uvest un graphe d’ordre nde
taille m−1 ayant pcomposantes connexes. Donc, d’après l’hypothèse de récurrence :
ν(G′)=(m−1)−n−p≥0
=⇒ν(G)=m−n−p≥1>0
D’où le résultat – car si ν(G)=0,Gne peut être que acyclique, sinon 0 =ν(G)≥1/exclamati⌢n-triangle
2.3.1 Codage et décodage d’un arbre – Prüfer code
Soit Tun arbre ayant nsommet numérotés {1,2,..., n}. Le codage de Prüfer représente l’arbre Tarbre de avec
une suite P=(x1,x2,x3,..., xn−2) de n−2 termes (les n° des sommets avec répétition possible). Une suite Pdonnée
correspond à un et un seul arbre numéroté. Voici les algorithmes de codage et de décodage.
Algorithme 2 : Codage de Prüfer
Entrées : Un arbre T
Output : Séquence de Prüfer P
1P←() ; // Initialisation de P comme séquence vide
2tant que v(T)>2faire
3 x←feuille de Tayant le n° minimum ; // donc d(x)=1
4 P←(P,s) où sest le seul (n°) sommet adjacent à x;
5 T←T−x;
6fin
7retourner P;
Example 2.2
Donner le code de Prüfer de l’arbre :
126 345
Indice : on trouve, P=(2,3,3,2)
Pour faire la réciproque, étant donnée une séquence P=(x1,x2,..., xn−2) où les xi∈{1,2,..., n}, on construit
l’arbre Tdont les sommets sont {1,2,..., n} avec l’algorithme suivant (le décodage) :H. SABRI 19
Algorithme 3 : Décodage de Prüfer
Entrées : Une séquence Pde taille n−2
Output : L ’arbre Tcorrespondante
1I←{1,2,..., n};
2T←graphe tel que V(T)=IetE(T)= ; ; // T graphe à n sommets isolés
3tant que P̸=()faire
4 i←min {x∈I:x∉P};
5 T←T+(i,P[1]) ; // ajouter l'arc (i,P[1])
6 P←P−P[1];I←I−{i};
7fin
8T←T+(a,b) ; // a,b sont les deux éléments restant dans I
9retourner T;
Example 2.3
Donner l’arbre dont le code de Prüfer est : P=(2,3,3,3)
Puisqu’il ya une bijection entre les arbres d’ordre net les suites Pde longueur n−2 à coefficients dans {1,2,..., n},
on déduit le théorème de Cayley :
Théorème 2.6 Formule de Cayley
Le nombre d’arbres que l’on peut construire sur n(n≥2) sommets numérotés est égal à nn−2.
2.3.2 Arbre couvrant de poids minimum – ACM
Soit Gun graphe (non orienté). Un arbre couvrant (spanning tree) TdeGest un sous graphe couvrant de G
tel que Test un arbre. Remarquer que, Gdoit être connexe, sinon un arbre couvrant de Gn’existe pas. Le nombre
des arbres couvrant de Gest noté a(G). Remarquer que a(Kn)=nn−2(le nombre de Cayley). Un problème algo-
rithmique classique est de trouver, dans un graphe valué , un arbre couvrant de poids minimal . On dispose de
plusieurs algorithmes (l’algorithme de Prim, l’algorithme de Kruskal ...).
Algorithme 4 : Kruskal
Entrées : Un graphe Gvalué d’ordre net de taille m
Output : Arbre (ou forêt) couvrant de poids minimum
1Numéroter les arêtes de Gpar poids minimum : w(e1)≤w(e2)≤ ··· ≤ w(em)
2T←graphe tel que V(T)=V(G) etE(T)= ; ; // T graphe à n sommets isolés
3k←0;
4tant que k<m et e (T)<n−1faire
5 siT+ek+1est acyclique alors
6 T←T+ek+1;
7 k←k+1;
8fin
9retourner T;
Appliquer l’algorithme de Kruskal dans le graphe suivant :
CHAPITRE 3
Les algorithmes de base
Beaucoup de problèmes sur les graphes nécessitent que l’on parcourt l’ensemble des sommets et des arcs. Par
exemple, pour vérifier que le graphe est connexe, chercher un sommet particulier, construire un arbre couvrant,
trouver un plus court chemin ...etc.
3.1 Parcours en profondeur (DFS) / largeur (BFS)
Une manière simple de tester si un graphe Gest connexe ou non est d’exécuter l’algorithme DFS ouBFS dans
Gen commençant par n’importe quel sommet et en enregistrant les sommets visités pendant l’exécution dans une
liste. Si la liste contient tous les sommets de G, alors Gest connexe. Une petite modification permet de donner les
composantes connexes de G. L ’algorithme DFS_Component suivant donne les composantes connexes de G. Il est
donné sous forme d’implémentation récursive.
Algorithme 5 : DFS_Component
Entrées : Un graphe G=(V,E)
Output : Les composantes connexes C=(C1,C2,..., Ck) de G.
1VisitedNodes ← ; ;
2k←0 ; // k est le nombre des composantes connexes
3pour chaque u∈Vfaire
4 siu∉VisitedNodes alors
5 k←k+1;
6 DFS( u);
7 fin
8fin
9retourner (C1,C2,..., Ck);
1Procedure DFS( u )
2 VisitedNodes ←VisitedNodes ∪{u};
3 Ck←Ck∪{u};
4 pour chaque x∈Γ(u)faire
5 six∉VisitedNodes alors
6 DFS( x);
7 fin
8 fin
Note : -
Il est possible de d’implémenter la procédure DFS itérativement à l’aide d’une pile LIFO (stack) contenant les
sommets à explorer : on désempile un sommet et on empile ses voisins non encore explorés.
20H. SABRI 21
Pseudocode :
stack . push ( root )
while stack . isEmpty ( ) = f a l s e do
node = stack . pop ( ) // so mark i t as v i s i t e d
for each x in node . childNodes do
i f x i s not v i s i t e d then
stack . push ( x )
. . .
endfor
endwhile
Example 3.1 (DFS )
Ici on empile (gris) les sommets les plus à droite, alors l’ordre des sommets visité (noir) est ( a,b,d,e,g,c,f).
Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b
 c
d
 e
f
g
a
b
 c
d e
f
ga
b
 c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g
L ’utilisation d’une file (FIFO) au lieu d’une pile transforme l’algorithme du parcours en profondeur en algo-
rithme de parcours en largeur ( BFS ). Avec BFS l’exemple précédent devient (en enfile le plus à gauche) :
Example 3.2 (BFS )
Ici, avec BFS, on enfile (gris) les sommets les plus à gauche d’abord, alors l’ordre des sommets visité (noir)
est ( a,b,d,e,g,c,f). Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b c
d
 e
f
g
a
b c
d
 e
f
ga
b c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g22 Chapitre 3. Les algorithmes de base
Exercice 3.1
1. Écrire la procédure BFS .
2. Utiliser DFS (ou BFS) pour la construction d’un arbre couvrant d’un graphe connexe. L ’appliquer
pour le graphe triangle.
3. Utiliser DFS pour écrire une procédure DFS_Cycle pour détecter un cycle dans un graphe.
On sait qu’un graphe orienté G=(V,E) est fortement connexe si pour chaque paire de sommets u,v∈V, il
existe un chemin de uàvet il existe un chemin de vàu. En d’autres termes, nous avons besoin d’une connectivité
dans les deux directions .
Une procédure pour tester si un graphe orienté est fortement connexe ou non peut être conçue avec l’idée
suivante. En partant d’un sommet arbitraire vdu graphe G, on exécute l’algorithme BFS ouDFS et l’on note les
sommets visités. Ensuite, on obtient la transposée de G,GT, en inversant la direction des arêtes de G, et l’on
exécute à nouveau l’algorithme BFS ou DFS à partir du sommet v. Si les sommets visités dans les deux cas sont
égaux à V, alors le graphe orienté est fortement connexe. Cette méthode est illustrée dans l’algorithme 6.
Algorithme 6 : Fortement_connexe
Entrées : Un graphe orienté G=(V,E)
Output : true siGest fortement connexe et false sinon
1X← ; ;
2Y← ; ;
3v←un sommet quelconque de V;
4X←DFS( G,v) ; // Enregistrez les sommets visités dans X
5GT←Gavec flèches inversées;
6Y←DFS( GT,v);
7siX=Y=Valors
8 retourner TRUE.
9sinon
10 retourner FALSE.
11fin
3.2 Recherche des chemins
3.2.1 Matrice d’adjacence et nombre de chemins
La puissance de la matrice d’adjacence Amontre qu’il y a des chemins (ou chaînes) de longueur kallant de xà
ycomme le montre le théorème suivant.
Théorème 3.1
Soit G=(V,E) un (di)graphe. On note V={1,2,..., n} et Asa matrice d’adjacence et Akla puissance k-ème
deA. Alors le terme d’indices i,jdeAkest le nombre de chemins (chaînes) de longueur kallant de iàj.
Preuve. Par récurrence sur k. Pour k=1 c’est clair. On suppose le résultat est vrai à l’ordre ket montrons qu’elle
est vrai pour k+1. Soit S=(si,j)=Ak. Si on a un chemin de iàjde longueur k+1, alors on va d’abord de ià un
sommet ravec kpas et puis de ràj. Or d’après l’hypothèse de récurrence on a si,rchemins possibles pour aller de
iàret finalement ar,jpas (1 ou 0) pour aller de ràj. Ainsi, le nombre totale possibles (i.e. tous les sommets r) est :
nX
r=1si,rar,j=³
Ak×A´
i,jH. SABRI 23
ce qui est bien le terme ( i,j) de la matrice Ak+1.
3.2.2 Plus court chemin et l’algorithme de Dijkstra
Dans cette partie on suppose que le (di)graphe G=(V,E,w) est valué positivement (i.e.∀e∈E,w(e)>0). Notre
objectif est de chercher un plus court chemin (i.e., un chemin de poids minimal ) d’un sommet ufixé à un sommet
quelconque de G.
Il est clair que l’on peut restreindre ce problème au cas d’un (di)graphe simple1. On suppose aussi que Gest
connexe (sinon, certains trajets sont impossibles). Il est aussi claire (d’après théorème 2.1), qu’un plus court chemin
est nécessairement un chemin élémentaire (path).
L ’algorithme de Dijkstra (1959) permet de calculer le plus court chemin entre un sommet particulier u(racine )
et tous les autres sommets. L ’algorithme fonctionne de la manière suivante :
Pour tout sommet vdeG, on associe une valeur T(v), initialisée à w(u,v) et une liste de sommets C(v) qui
correspond à un chemin de uàv. À la fin de l’algorithme, T(v) contient le poids minimal des chemins joignant uà
v(ou T(v)= ∞ siu↛v) et la liste C(v) réalise un tel chemin. Voici donc l’algorithme de Dijkstra :
Algorithme 7 : Algorithme de Dijkstra
Entrées : Un (di)graphe valué G=(V,E,w) et un sommet racine u
Output : Le coût minimum d’un chemin de uàv(∀v∈V) et un trajet pour chaque coût minimal obtenu
1∀v∈V,T(v)←w(u,v) etC(v)←(u,v); // Initialisation de T(v) et la liste C(v)
2X←{u};
3tant que X̸=Vfaire
4 Choisir v∈V−Xtel que ∀y∈V−X,T(v)≤T(y);
5 X←X∪{v};
6 pour chaque y∈V−Xfaire // Faire les mises à jours pour les autres sommets
7 siT(y)>T(v)+w(v,y)alors
8 T(y)←T(v)+w(v,y);
9 C(y)←[C(v),y]; // On ajoute à la liste C(v) l'élément y
10
11 fin
12 fin
13fin
Example 3.3
Voici une application de l’algorithme de Dijkstra au digraphe suivant. On prend Ecomme sommet racine.
EA
B
CD
FG
S5
4
21
12
2
34
4
215
7
1. En effet, passer par une boucle ne ferait qu’augmenter inutilement le poids de ce chemin. De même, si plusieurs arcs joignent deux
sommets, il suffit de conserver l’arc de poids minimal.24 Chapitre 3. Les algorithmes de base
Ainsi, pour l’initialisation, on a : X={E} et on a les valeurs :
v  E A B C D F G S
T(v) 0 5 4 2 ∞ ∞ ∞ ∞
C(v)(E,E) ( E,A) ( E,B) ( E,C) ( E,D) ( E,F) ( E,G) ( E,S)
Maintenant, on choisit (un seul choix) le sommet C, donc X={E,C}. Le tableau est mis à jour :
v  E A B  C D F G S
T(v) 0 5 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À l’étape suivante, on est forcé de choisir B. Ainsi, X={E,C,B} et la mise à jour est :
v  E A  B  C D F G S
T(v) 0 4 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À présent, on a le choix entre AetF. On choisit A. Donc X={E,C,B,A} et on a :
v  E  A  B  C D F G S
T(v) 0 4 3 2 6 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,B,A,D) ( E,C,F) ( E,C,G) ( E,S)
Puis, on prend le sommet F. D’où X={E,C,B,A,F} et :
v  E  A  B  C D  F G S
T(v) 0 4 3 2 5 4 5 11
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,S)
On prend Det on obtient X={E,C,B,A,F,D} et :
v  E  A  B  C  D  F G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Finalement, on prend Gpuis Set on voit que ceci ne change rien. D’où le tableau finale :
v  E  A  B  C  D  F  G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Ainsi le chemin minimum pour aller de EàSest de coût 10 et un trajet de coût minimal de EàSest : EC F DS .H. SABRI 25
3.3 Problèmes d’ordonnancement et chemin critique
Un problème d’ordonnancement peut-être représenté sous la forme d’un digraphe. Les sommets sont des évé-
nements (début et fin de la tâche) et les arcs des tâches, La longueur (ou poids) de chaque arc représente la durée
d’exécution de la tâche. Ainsi, la tâche correspondant à l’arc ( i,j) ne peut commencer que si toutes les tâches cor-
respondant à des arcs ( k,i) ont été complétées. On ajoute deux sommets pour le début (s) et de fin(t) du projet .
Le digraphe peut contenir des tâches fictives dedurée nulle afin de forcer certaines précédences (postériorité).
Ainsi, un réseau PERT est un digraphe valué G=(V,E,w,s,t) où la fonction poids (ou longueur) w:E→R+
etsle sommet source (début) et tle sommet puits (fin). Un chemin critique est un chemin de sàtdelongueur
maximale . S’il n’existe pas de chemin critique, le projet n’est pas réalisable (e.g. un circuit). Le temps minimal
requis pour l’exécution d’un projet réalisable est égal à la longueur d’un chemin critique. Les tâches figurant sur un
chemin critique sont aussi appelées critiques, ce qui s’explique par le fait que tout retard d’exécution d’une tâche
critique retarde d’autant l’exécution du projet.
3.3.1 Algorithmes de tri topologique et de chemin critique
Il faut d’abord numérotés les sommets de 1 à nde manière compatible au pré-ordre (rang) avec l’algorithme du
rang suivant (tri topologique) :
Algorithme 8 : Algorithme du rang
Entrées : Un digraphe G=(V,E) sans circuit
Output : Le rang r(v) de chaque sommet v∈Vde G
1r←0;X←V;
2R←{v∈X:Γ−
X(v)= ;} ; // l'ensemble des sommets de X sans prédécesseur dans X
3tant que X̸= ; faire
4 r(v)←rpour chaque sommet v∈R;
5 X←X−R;
6 R←l’ensemble des sommets de Xsans prédécesseur dans X;
7 r←r+1;
8fin
On supposera dorénavant que les sommets ont déjà été numérotés de 1 à nde manière compatible avec leurs
rangs, c’est-à-dire que r(j)>r(i) implique j>i(donc 1 =setn=t). Enfin, on supposera éliminés les arcs paral-
lèles par l’introduction de tâches fictives de durée nulle .
Pour un sommet i, on note tiledébut au plus tôt des tâches correspondant aux arcs i→jet par Tilafin au
plus tard des tâches correspondant aux arcs j→i.
Algorithme 9 : Algorithme du chemin critique
Entrées : Un digraphe G=(V,E) sans circuit trié topologiquement
Output : La durée du chemin critique et les dates ti,Ti
1t1←0;
2pour j=2···nfaire // Calcul des dates de début au plus tôt  récurrence en avançant
3 tj←max i∈Γ−(j){ti+w(i,j)}
4fin
5Tn←tn;
6pour j=n−1···1faire // Calcul des dates de fin au plus tard  récurrence en reculant
7 Tj←min i∈Γ+(j){Ti−w(j,i)}
8fin26 Chapitre 3. Les algorithmes de base
Définition 3.1
— Un sommet iest critique si ti=Ti.
— Un arc ( i,j) est critique les sommets ietjsont critiques ettj−ti=w(i,j).
— Un chemin critique est un chemin de 1 à nn’utilisant que des arcs critiques.
— La durée du chemin critique est donnée par Tn(ou par tn). Elle correspond à la durée minimale du
projet .
Example 3.4
L ’application de l’algorithme du chemin critique au digraphe suivant (trié topologiquement) est :
1 23
45
6B
9A
3
C
5D
8
E
4
F7G
20
H6I5
=⇒
 1
0,02
9,933,16
4
16,23513,24
6
29,29B
9A
3
C
5D
8
E
4
F7G
20
H6I5
Les tâches critiques sont BetG. La durée totale minimale du projet est donc 29.
Exercice 3.2
Les tâches ( durée et précédences ) pour la construction d’un entrepôt sont données dans le tableau suivant :
Tâches Nature Précédences Durée (jours)
A Acceptation des plans par le propriétaire – 4
B Préparation du terrain – 2
C Commande des matériaux A 1
D Creusage des fondations A, B 1
E Commande des portes et fenêtres A 2
F Livraison des matériaux C 2
G Coulage des fondations D, F 2
H Livraison des portes et fenêtres E 10
I Pose des murs, de la charpente et du toit G 4
J Mise en place des portes et fenêtres H, I 1
1. Représentez le graphe des précédences de ce projet (trié topologiquement).
2. Déterminez une durée totale minimale en exhibant un chemin critique dans ce graphe.CHAPITRE 4
Programmation linéaire
La programmation linéaire est le processus de minimiser ou maximiser une fonction objective linéaire sou-
mise à un nombre fini de contraintes d’égalités et d’inégalités linéaires.
La programmation linéaire a de nombreuses applications dans le domaine de l’informatique théorique. Elle
peut être utilisée pour résoudre de nombreux problèmes combinatoires variés, tels que la recherche de flot maxi-
mum dans un réseau, la recherche d’un couplage maximal dans un graphe et la coloration d’un graphe parfait.
Example 4.1 (Problème de régime)
On suppose qu’on a quatre plats : de la truite ( XT), un sandwich au corned-beef ( XC B), un burrito ( XBU R )
et un hamburger ( XHB). Le tableau suivant répertorie la valeur nutritionnelle de chaque plat (vitamines et
calories) et notre besoin journalier des vitamines.
Vit. A Vit. C Vit. D Calories
Truite 203 92 100 600
Corned-beef 90 84 230 350
Burrito 270 80 512 250
Humburger 500 90 210 500
Besoins 2000 300 430
Notre objectif est de minimiser le nombre total de calories consommées : 600 XT+350XC B+250XBU R+
500XHBtout en satisfaisant les trois besoins nutritionnels en vitamines. Le programme linéaire résultant
s’écrit :
min 600 XT+350XC B+250XBU R+500XHB
s.t. 203 XT+90XC B+270XBU R+500XHB≥2000, (Besoins de Vit. A),
92XT+84XC B+80XBU R+90XHB≥300, (Besoins de Vit. C),
100XT+230XC B+512XBU R+210XHB≥430, (Besoins de Vit. D),
XT,XC B,XBU R ,XHB≥0
Définition 4.1: Forme canonique – Forme standard
On peut écrire un P .L. sous deux formes spéciales :
•Canonique
max
mincTX+c0
s.t. AX≤b(≥bsi min),
X≥0•Standard
max cTX+c0
s.t. AX=b,
X≥0Avec :
cTX=¡
c1··· cn¢
x1
...
xn

cTX+c0=c1x1+c2x2+···+ cnxn+c0
2728 Chapitre 4. Programmation linéaire
Remarque 9. Un P .L. général peut être formulé selon une forme standard ou canonique par la méthode suivante :
générale =⇒ standard il faut éliminer les contraintes d’inégalité et les variables sans contrainte de positivité.
— Si dT
iX≤biest une contrainte d’inégalité, alors créer une nouvelle variable ( d’écart ) siet remplacer l’in-
égalité dT
iX≤bipar dT
iX+si=biet s i≥0.
Si dT
iX≥bi, alors on peut écrire dT
iX−si=biet s i≥0.
— Si une variable x i≶0est de signe quelconque, alors créez deux nouvelles variables x+
iet x−
iet remplacez
xipartout par x+
i−x−
i, et ajoutez les contraintes de signe : x+
i≥0,x−
i≥0.
générale =⇒ canonique
— Si dT
iX=biest une contrainte d’égalité, alors remplacer cette égalité par une paire d’inégalités :
dT
iX≥biet−dT
iX≥ −bi
— Même chose que précédemment si la variable x i≶0.
Il est facile de voir que les problèmes qui en résultent sont équivalents aux problème d’origine. Pour l’algorithme
simplexe , nous utiliserons la forme standard .
On remarque aussi qu’en utilisant la relation min f(x)= − max¡
−f(x)¢
dans laquelle f (x)représente la fonction-
nelle linéaire à optimiser, on peut toujours se ramener à un problème de minimisation (ou de maximisation).
Example 4.2
Le P .L :max 5 x+4y
s.t. x≤6
1
4x+y≤6
3x+2y≤22
x,y≥0s’écrit sous forme standard :max 5 x1+4x2
s.t. x1+e1=6
1
4x1+x2+e2=6
3x1+2x2+e3=22
x1,x2,e1,e2,e3≥0
Donc (sous la forme matricielle) on a :
cT=¡
5 4 0 0 0¢
;A=
1 0 1 0 0
1
41 0 1 0
3 2 0 0 1
;X=
x1
x2
e1
e2
e3
et b=
6
6
22

4.1 La méthode simplexe
4.1.1 Solution de base admissible
On suppose que la matrice Adu programme linéaire est de type m×netde rang m(pourquoi !). Soit Bla
matrice carrée extraite de Aformée par les mcolonnes j1,j2,..., jmlinéairement indépendants de A(les vecteurs
de base). Alors, Best une matrice inversible. Ainsi si on pose xl=0 sil∉{j1,..., jm} etxjklak-ième composante de
B−1b. Alors, on a AX B=b. Si de plus XB≥0(i.e. chaque xi≥0), alors :
Xest une solution de base admissible (ou réalisable)
Dans l’exemple 4.2, la matrice extraite B=
1 0 0
0 1 0
0 0 1
est inversible et B−1b=
6
6
22
. Donc XB=
0
0
6
6
22
≥0, par suite
XBest une solution de base admissible. On appelle les variables xjklesvariables de base . Les autres variables xl
sont les variables hors-base .
Parfois, il n’est pas évident de trouver une solution de base admissible, comme le montre l’exercice suivant :H. SABRI 29
Exercice 4.1
Écrire le programme linéaire suivant sous forme standard et montrer qu’on n’a pas une solution de base
admissible. Résoudre le programme linéaire.
max −x+y
s.t. x+y≥1,
3x+2y=6,
x,y≥0
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux
Dans cette section, on suppose qu’on a déjà trouvé une solution de base admissible X(produite avec B=Im)
du programme linéaire ( P: max z=cTX+c0etb≥0pour garantir que 0est une solution de AX≤b).
La méthode du simplexe est une méthode itérative qui génère une séquence de solutions de base réalisable
(correspondant à différentes bases) et s’arrête finalement lorsqu’elle a trouvé une solution de base réalisable opti-
male. Remarquer qu’on peut toujours prendre c0=0.
Algorithme 10 : Algorithme du simplexe
Entrées : Un P .L. standard P(max) avec une solution de base réalisable
Output : La solution optimale (ou non)
1On commence à écrire le tableau initiale (avec les variables de base xj1,..., xjm)
VB x1 ... xn b
xj1 b1
... A...
xjm bm
c1 ... cn−c0
2Sicj≤0 (∀j:xjest hors base), alors solution optimale (STOP) // min ⇝cj≥0
3Trouver la colonne s(hors base) tel que cs=max©
cj:cj>0ª// min ⇝cs=min©
cj:cj<0ª
4Siai,s≤0∀i=1... m, alors pas de solution optimale (STOP)
5Min Ratio Test : trouver la ligne rtel que
br
ar,s=min
i=1...m½bi
ai,s:ai,s>0¾
6Appliquer la procédure de Gauss autour de pivot ar,s(ar,s⇝1 et on annule les coefficients situés sous et
sur le pivot dans la colonne s, par combinaisons de lignes) // Ne pas oublier la dernière ligne
7Remplacer (dans VB) la variable de base ( sortante ) située à la ligne rpar la variable ( entrante )xs
8Retourner à l’étape 2 // l'algorithme termine si le programme linéaire est non dégénéré
Remarque 10.
— La dernière ligne représente l’équation linéaire −z+c1x1+···+ cnxn= −c0.
— La valeur de la variable de base de V Bde la ligne k est égale à la valeur b k(de la ligne k).
— La solution optimale du problème est la valeur finale (dernière cellule) (×− 1).
— Si on n’a pas au départ B =Im(à l’aide des variables d’écart) alors, on ajoute les variables artificielles (et on
applique d’abord la phase I - voir section suivante).30 Chapitre 4. Programmation linéaire
Exercice 4.2
Soit le programme linéaire :
max 2 x1+x2
s.t. x1−x2≤3,
x1+2x2≤6,
−x1+2x2≤2,
x1,x2≥0
Rajouter les variables d’écart. Puis résoudre le problème par l’algorithme du simplexe.
Remarque 11. Vérifier le résultat de l’exercice précédent, par la méthode graphique.
4.1.3 Initialisation - Phase I du simplexe
Un programme linéaire est dit sous forme simpliciale si la matrice Acontient la matrice identité Imcomme
sous matrice. On suppose que le programme linéaire P, après la mise en forme AX=b, n’est pas simpliciale
(possible dans le cas de contraintes du type ≥ou du type =). Soit Bune matrice d’ordre mextraite de Ainversible
tel que B−1b≥0et soit XBla solution de base réalisable ( XB≥0etAX B=b), alors on peut changer l’équation
matricielle :
AX B=b
⇐⇒ (B−1A)XB=B−1b
⇐⇒ A∗XB=b∗
et la matrice A∗contient la matrice identité Imcomme matrice extraite ( B−1A=B−1(H|B)=¡
B−1H|Im¢
). Ainsi, on
peut appliquer directement l’algorithme 10 en remplaçant Apar A∗etbpar b∗. Cependant, cette méthode n’est
pas efficace, car il faut trouver une matrice extraite Bréalisable correspondante. Pour une matrice Ade type m×n,
il existe¡m
n¢
matrices extraites à tester !
L ’idée est d’ajouter des variables, dites artificielles w1,w2,..., wm, pour faire apparaître une forme simpliciale
du programme linéaire P: (AX=b). Mais, il faut que w1= ··· = wm=0. Donc, il faut minimiser d’abord le pro-
gramme linéaire P0suivant :
P0=min W=w1+···+ wm
s.t. (A|Im)×(x1...xnw1...wm)T=b
x1,..., xn,w1,..., wm ≥0
On exprime Wà l’aide des autres variables (hors base) et puis on applique l’algorithme du simplexe 10 pour P0
(phase I). À la fin, si on trouve que les wi=0, alors les variables de bases xj1,..., xjmforment une première base
admissible pour démarrer le simplexe pour le programme d’origine P.H. SABRI 31
Remarque 12. On ajoute la ligne de Z :c1 ... cn−c0dans le tableau du simplexe de P0(phase I) et on lui
applique les opérations élémentaire comme avec les autres lignes. À la fin de la phase I, on supprime les colonnes des
wiet la ligne de la fonction W . Finalement, on utilise ce tableau pour résoudre le problème initiale P.
Example 4.3
Soit le programme linéaire P:
min 6 x1+3x2
s.t. x1+x2≥1,
2x1−x2≥1,
3x2≤2,
x1,x2≥0sous forme standard (max)= = = = = = = = = = = = = = = = = = ⇒max Z= −6x1−3x2
s.t. x1+x2−e1=1,
2x1−x2−e2=1,
3x2+e3=2,
x1,x2,e1,e2,e3≥0
La matrice Aest :
A=x1 x2 e1 e2 e3

1 1 −1 0 0
2−1 0 −1 0
0 3 0 0 1
est par suite Pn’est pas sous forme simpliciale (il n’ ya pas de sous matrice I3). Donc on peut ajouter 2
variables artificielles pour construire le problème initiale P0:
max −w1−w2=3x1−e1−e2−2
s.t. x1+x2−e1+w1=1,
2x1−x2−e2+w2=1,
3x2+e3=2,
x1,x2,e1,e2,e3,w1,w2≥0dont le vecteur X=

0 x1
0 x2
0 e1
0 e2
2 e3
1 w1
1 w2est une solution de base réalisable.
Ainsi, on commence notre algorithme 10 pour le programme P0. Le tableau initial est :
x1 x2 e1 e2 e3 w1 w2 b

w1 1 1 −1 0 0 1 0 1
w2 2−1 0 −1 0 0 1 1
e3 0 3 0 0 1 0 0 2
W: 3 0 −1−1 0 0 0 2
Z:−6−3 0 0 0 0 0 0
Le pivot c’est a2,1donc x1est la variable entrante et w2est sortante. On obtient après pivotement le tableau :
L2←1
2L2− − − − − − − − →
L1←L1−L2
L4←L4−3L2
L5←L5+6L2x1 x2 e1 e2 e3 w1 w2 b

w1 03
2−11
20 1−1
21
2
x1 1−1
20−1
20 01
21
2
e3 0 3 0 0 1 0 0 2
W: 03
2−11
20 0−3
21
2
Z: 0 −6 0 −3 0 0 3 3
Le pivot est a1,2(Min ratio test =1
3). On obtient alors :32 Chapitre 4. Programmation linéaire
L1←2
3L1− − − − − − − − →
L2←L2+1
2L1
L3←L3−3L1
L4←L4−3
2L1
L5←L5+6L1x1 x2 e1 e2 e3 w1 w2 b


x2 0 1−2
31
302
3−1
31
3
x1 1 0−1
3−1
301
31
32
3
e3 0 0 2 −1 1 −2 1 1
W: 0 0 0 0 0 −1−1 0
Z: 0 0 −4−1 0 4 1 5
Ainsi, la phase I se termine avec W=0 et x1=2
3,x2=1
3,e3=1 et e1=e2=w1=w2=0. Le tableau pour la
phase II est donc :
x1 x2 e1 e2 e3 b


x2 0 1−2
31
301
3
x1 1 0−1
3−1
302
3
e3 0 0 2 −1 1 1
Z: 0 0 −4−1 0 5
On remarque donc que les cj≤0, donc (STOP) la solution est optimale et le max est −5. Ainsi la solution
optimale pour le programme P=min6 x1+3x2est−(−5)=5=6×2
3+3×1
3.
4.2 Dualité
SoitPun P .L. sous forme canonique. Le programme dualDdePest définit par :
P=max z=cTX
s.t. AX ≤ b
X≥ 0le dual est= = = = = = = ⇒D=min w=bTY
s.t. ATY≥ c
Y≥ 0
Le programme Pest dit primal . On remarque que si Ade type m×n, alors X∈RnetY∈Rmpour le dual.
Théorème 4.1 Théorème de dualité
Si un problème primal ou dual admet une solution, alors l’autre problème admet aussi une solution et on a :
max z=cTX =
s.t. AX ≤ b
X≥ 0min w=bTY
s.t. ATY≥ c
Y≥ 0
Exercice 4.3
Soit le problème suivant de type régime :
D=min w=340x1+2400 x2+560x3
s.t. x1+2x2+x3≥ 1200
x1+3x2+2x3≥ 1400
x1+x2+3x3≥ 1500
x1,x2,x3≥ 0
Écrire le programme primal PdeD. Résoudre le programme Pet déduire la valeur minimale de w, a-t-on
besoin de faire les deux phases du simplexe ?
7} A B oS



HOUSSEM SABRI
Graphes et Optimisation
2`emeannée
LISI  LSI
Institut Supérieur des Sciences Appliquées et de Technologie de Sousse
A.U. 2023-2024
28 novembre 2023Table des matières
1 Les graphes 3
1.1 Définitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.1 Graphes non orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.2 Graphes orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.2 Opérations et quelques types de graphes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.3 Représentation d’un graphe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.1 Listes d’adjacences (ou de succession) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.2 Matrices d’adjacence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.3.3 Matrice d’incidence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2 La connexité 11
2.1 Les chaînes et les cycles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.2 Graphe connexe, eulérien, hamiltonien . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.3 Arbres . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.3.1 Codage et décodage d’un arbre – Prüfer code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.3.2 Arbre couvrant de poids minimum – ACM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3 Les algorithmes de base 20
3.1 Parcours en profondeur (DFS) / largeur (BFS) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
3.2 Recherche des chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.1 Matrice d’adjacence et nombre de chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.2 Plus court chemin et l’algorithme de Dijkstra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
3.3 Problèmes d’ordonnancement et chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
3.3.1 Algorithmes de tri topologique et de chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . 25
4 Programmation linéaire 27
4.1 La méthode simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.1 Solution de base admissible . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux . . . . . . . . . . . . . . . . . . . . . . . . 29
4.1.3 Initialisation - Phase I du simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
4.2 Dualité . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
2CHAPITRE 1
Les graphes
L ’exemple classique pour introduire la théorie des graphes est le problème des ponts de Königsberg, étudié par
Euler en 1736. Quel itinéraire doit-on suivre pour traverser chaque pont exactement une fois? Une telle prome-
nade n’existe pas, et c’est Euler qui donna la solution de ce problème en caractérisant les graphes que l’on appelle
aujourd’hui eulériens .
A
B
Ce1 e2
e3 e4
De5
e6e7
FIGURE 1.1 – Les ponts de Königsberg
Les graphes introduisent une simplification : les régions se transforment en des "points" (aussi appelés noeuds
ousommet ), les ponts se transforment en des lignes (aussi appelées arêtes ouarcs ), et ce principe s’applique dès
lors qu’une relation existe entre des objets. Les graphes relèvent de la combinatoire plutôt que de la géométrie (les
intersections, les longueurs, et la forme des arêtes n’ont aucune importance, sauf en ce qui concerne la lisibilité de
la représentation).
1.1 Définitions
Dans la suite, il est toujours supposé que les graphes sont finis, sauf indication contraire.
1.1.1 Graphes non orientés
Définition 1.1: Graphe
Un graphe Gest un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V{2}des pairs non ordon-
nées de V.Vest l’ensemble des noeuds (Vertices en anglais) et Ec’est l’ensemble des arêtes de G(Edges en
anglais). Lorsque e={x,y} est une arête, on dit que x, y sont les extrémités de cette arête, que eest incidente
enxet en y. On joint x et y par un trait et on dit que x, y sont adjacents (ou voisins). On note aussi e=x you
encore e=(x,y) (attention , dans ce cas : ( x,y)=(y,x)).
SiGest un graphe alors, on note par V(G) l’ensemble de noeuds et par E(G) l’ensemble des arcs.
Remarque 1.
— Une arête e ={x,x}s’appelle boucle .
— Dans un graphe, il peut exister des arêtes parallèles (on parle donc de multigraphe ).
Dans l’exemple des ponts on a : e 1=e2=(A,B).
34 Chapitre 1. Les graphes
— Un graphe est dit simple s’il ne comporte ni arêtes multiples ni de boucles, c’est-à-dire chaque paire de nœuds
distincts est reliée par au plus une arête, ou encore E (G)⊆P2(G).
Dans la plupart des cas, les graphes sont considérés comme simples par défaut.
Définition 1.2: ordre – taille – degré
Soit G=(V,E) un graphe.
1. On appelle ordre d’un graphe noté v(G) le nombre de ses sommets :
v(G)= |V|
2. On appelle taille d’un graphe noté e(G) le nombre de ses arêtes :
e(G)= |E|
3. Le degré (ou valence) d’un sommet xnoté d(x) est le nombre d’arêtes contenant x. (Attention! Une
boucle sur un sommet compte double).
Si on note par Γ(x) l’ensemble des voisins de x, i.e.
Γ(x)={y∈V:x y∈E}
alors, siGest simple , on a :
d(x)= |Γ(x)|
Example 1.1 (Graphe complet)
Un graphe d’ordre nest dit complet noté Knsi chaque sommet du graphe est relié directement à tous les
autres sommets, i.e. E(Kn)=P2(V(Kn)).
Représenter graphiquement K3,K4,k5. Calculer la taille de K3,k4,...Kn.
Example 1.2 (Graphe biparti)
Un graphe G=(V,E) est dit biparti si son ensemble de sommets V=V1˙∪V2, i.e. peut être divisé en deux
sous-ensembles disjoints V1etV2tels que chaque arête ait une extrémité dans V1et l’autre dans V2.
Si∀x∈V1,∀y∈V2;x y∈E, alors Gest dit biparti complet noté Kn,moùn= |V1|etm= |V2|.
a1
 a2
 a3
 a4
b1
 b2
 b3
FIGURE 1.2 – Un graphe biparti
Théorème 1.1 Lemme des poignées de main – Handshaking lemma
Soit Gun graphe alors, on a :X
x∈V(G)d(x)=2e(G)
Dans ce théorème d(x) est le nombre de personnes à qui xserre la main et e(G) le nombre total de poignées
de mains.H. SABRI 5
Preuve.
•Méthode simple Il y en a d(x) arêtes en un sommet xfixé. Pour tout les sommets cela fait doncP
x∈V(G)d(x).
Mais avec cette manière chaque arête est comptée deux fois, une fois à chacune de ses extrémités, d’où le
résultat en divisant par 2.
•Preuve par double dénombrement On pose
Z={(x,e)∈V×E:x∈e}⊆V×E
et les deux projections :
p:Z→V
(x,e)7→xet q:Z→E
(x,e)7→e
L ’idée est de calculer |Z|de deux manières différentes. D’abord, on rappelle que si f:A→Best une fonction
quelconque, alors :X
b∈B|f−1[b]| = | A|
oùf−1[b] désigne l’image réciproque de { b} par f(pourquoi ˙S
b∈Bf−1[b] est une union disjointe ?).
Ainsi on obtient :
|Z| =X
x∈V|p−1[x]| =X
e∈E|q−1[e]|
Or,|p−1[x]| =d(x) et|q−1[e]| = |{x∈V:x∈e}| =2. Donc :
X
x∈Vd(x)=X
e∈E2=2|E|
Remarque 2.
— Un sommet de degré 0est appelé sommet isolé .
— Un graphe tel que : ∀x∈V,d(x)=kest dit graphe k-régulier .
— Le graphe complet K nest un graphe (n−1)-régulier .
Exercice 1.1
Montrer que dans un graphe le nombre de sommets d’ordre impairs est toujours pair. En particulier un
graphe k-régulier avec kimpaire est un graphe d’ordre pair.
Voici quelques exemples comme application :
1. Est-il possible de relier 15 ordinateurs en réseau de sorte que chacun soit relié à exactement 3 autres ?
2. Une ligue de football comprenant 11 clubs organise un tournoi. Pour gagner du temps on décide que chaque
équipe ne jouera que la moitié des matches possibles. Comment organiser le tournoi ?
Proposition 1.1
Soit G=(V,E) un graphe (simple) d’ordre n≥2. Alors :
∃u,v∈V,u̸=v:d(u)=d(v)
Preuve. Supposons le contraire, c’est-à-dire ∀u,v∈V;d(u)̸=d(v). Or dans un graphe (simple) on a toujours d(x)∈
{0,1,..., n−1}. Dans ce cas, puisque tous les nsommets ont des degrés distincts, alors il existe une bijection
{d(x):x∈V}←→ {0,1,..., n−1}
Donc, il existe un sommet uavec un degré 0, et un sommet vavec degré n−1, donc vest connecté à tous les autres
sommets du graphe, ce qui signifie que une peut pas être un sommet isolé, d’où une contradiction.6 Chapitre 1. Les graphes
1.1.2 Graphes orientés
Les arêtes d’un graphe peuvent être orientées, auquel cas une flèche indique la direction. De tels graphes sont
appelés des graphes orientés ou des digraphes , et une arête ( a,b) dans un tel graphe indique que cette arête est
dirigée de sommet avers b, i.e. ( a,b)=− →ab̸=(b,a)=− →ba. D’où la définition :
Définition 1.3: Graphe orienté - digraphe
Un graphe orienté G(ou− →G) est un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V2des pairs
ordonnées de V.Eest l’ensemble des arêtes (ou flèches, arcs) de G. Lorsque e=(x,y) est une arête, on dit
que xestl’origine (ou sommet initiale) et yl’extrémité (ou sommet terminale) de e, que eest sortant en x
et incident en y, et que yest un successeur de xtandis que xest un prédécesseur de y. On note l’arête e
par :
e=(x,y)=− →x y=x→y
De la même façon, une arête x→xest une boucle. On peut toujours supprimer les boucles pour obtenir des
digraphes simples. Voici l’exemple d’un digraphe G=(V,E) d’une fonction f:E→Eoù ( x,y) est un arc si et seule-
ment si y=f(x). On l’appelle digraphe fonctionnelle.
0
3
1214
11 568
169
4
2 1
713 10
15
FIGURE 1.3 – Le digraphe fonctionnelle Gfdex7→(x2+3) mod 17.
Comme dans les graphes on peut définir les degrés (entrant, sortant) d’un sommet dans un digraphe.
Définition 1.4: indegree - outdegree
Soit G=(V,E) un digraphe. Pour v∈V, on note par :
d+(v) le degré extérieur (sortant - outdegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité initiale.
d+(v)= |{v→ •}|
d−(v) le degré intérieur (entrant - indegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité finale.
d−(v)= |{• → v}|
On définit le degré : d(v)=d−(v)+d+(v).
Un sommet de degré entrant non nul et de degré sortant nul est appelé puits , tandis qu’un sommet de
degré entrant nul et de degré sortant non nul est appelé source ouracine .
Dans un graphe orienté, les voisins d’un sommet vsont soit des successeurs ou des prédécesseurs. On les notes
par :
Γ+(x)=Succ (x)={y∈V:x→y∈E} et Γ−(x)=Pr ed (x)={y∈V:y→x∈E}H. SABRI 7
Si le digraphe est simple (ni boucle ni arcs parallèles) on a :
d−(v)= |Γ−(v)|et d+(v)= |Γ+(v)|
Proposition 1.2
Soit Gun digraphe, alors :X
v∈Vd−(v)=X
v∈Vd+(v)= |E|
Preuve. On a
E=˙[
v∈V{• → v}=˙[
v∈V{v→ •}
=⇒ | E| =X
v∈V|{• → v}| =X
v∈V|{v→ •}| =⇒ | E| =X
v∈Vd−(v)=X
v∈Vd+(v)
1.2 Opérations et quelques types de graphes
Une opération sur les graphes permet de construire un nouveau graphe comme résultat de l’opération. Les
opérations courantes sur les graphes sont la suppression, la valuation, l’union, l’intersection et le produit cartésien.
Graphe valué
Tout d’abord, on peut vouloir attribuer des valeurs aux arcs ou arêtes pour tenir compte de contraintes : dis-
tance, coût ...
Définition 1.5: (di)graphe valué
Un (di)graphe valué G=(V,E,w) est un (di)graphe muni d’une application w:E→R. L ’application west
appelée application poids ou coût. On indique sur chaque arête son poids (ou son coût). On note w(x,y)
au lieu de w((x,y)). On convient (même que ceci n’a pas de sens!) que w(x,y)= +∞ si (x,y)∉E.
ab
c
d
ef53
43
3
335
81
FIGURE 1.4 – Un digraphe valué
/pythonPython code : -
Implémenter le digraphe valué précédent avec python. Indice – use chatGPT : how to build a weighted digraph with
python8 Chapitre 1. Les graphes
Sous graphes
Soit G=(V,E) un graphe (orienté ou non). Un sous graphe de Gest un graphe de la forme G′=(V′,E′) où
V′⊆V,E′⊆Etels que toute arête de E′a ses extrémités dans V′(ou encore G′est aussi un graphe). On a :
•Sous-graphe induit Un sous-graphe G′=(V′,E′) de G=(V,E) est appelé un sous-graphe induit deGsi :
∀x,y∈V′; (x,y)∈E′⇐⇒ (x,y)∈E
En d’autres termes, deux sommets de G′qui sont connectés dans G, sont également connectés dans G′.
•Sous-graphe couvrant Un sous-graphe couvrant G′deGcontient tous les sommets de G, i.e. V′=V.
•G−vSupprimer un sommet vd’un graphe Gconsiste à supprimer vet toutes ses arêtes incidentes. Le sous-
graphe obtenu de cette opération est noté G−v, i.e.
V′=V−{v} et E′=E−{(v,y): (v,y)∈E}
De manière similaire, une arête epeut être supprimée (resp. ajoutée) d’un graphe G, et le sous-graphe
résultant est représenté par G−e(resp. G+e). Notez que la suppression d’une arête ne retire pas de sommets
du graphe.
•G−V′=G[V′] On supprimer tous les sommets v∈V′du graphe Gavec les arêtes incidentes. Le sous-graphe
obtenu de cette opération est noté G[V′], i.e.
V(G[V′])=V−V′et E(G[V′])=E−{(v,y)∈E:v∈V′}
•Clique Une clique Cd’un graphe Gest un sous-ensemble des sommets de Gdont le sous-graphe induit G′=
(C,E′) est un graphe complet, en d’autres termes, deux sommets quelconques de la clique Csont toujours
adjacents.
•Stable Un stable – appelé aussi ensemble indépendant (independent set en anglais) est un ensemble de som-
mets deux à deux non adjacents. Donc le sous-graphe induit est sans arcs.
FIGURE 1.5 – L ’ensemble des sommets en bleu dans ce graphe est un stable maximal du graphe.
Note : -
Le problème décisionnel de la clique (c’est à dire existe t-il une clique de taille k) est NP-complet . De même la
recherche d’un stable de taille maximum dans un graphe est un problème NP-complet et difficile à approximer.
Exercice 1.2
Trouver un plus grand stable et une plus grande clique du graphe suivant :
8
4
62 7
3
1 5
Indice : vérifier le résultat avec networkx.find_cliques(G) et.maximum_independent_set(G) de python.H. SABRI 9
Opérations binaires
Union L ’union de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∪H=(VF,EF) dans lequel
VF=VG∪VH et EF=EG∪EH
Intersection L ’intersection de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∩H=(VF,EF)
dans lequel
VF=VG∩VH et EF=EG∩EH
1.3 Représentation d’un graphe
Il est important de savoir comment représenter les graphes au sein d’un ordinateur. Il ya plusieurs méthodes
selon la nature des traitements que l’on souhaite appliquer au graphe considéré.
1.3.1 Listes d’adjacences (ou de succession)
Soit Gun (di)graphe. On suppose que les sommets de Gsont numérotés de S1àSn. La représentation par listes
d’adjacence de Gconsiste en un tableau (ou des listes chainées) tel que la ligne i=1... ncorrespond au sommet Si
et comporte la liste des voisins/successeurs (ou des prédécesseurs) de ce sommet notée T[Si]. Les sommets dans
chaque liste d’adjacence sont généralement listés selon un ordre arbitraire.
1
2
345
FIGURE 1.6 – Un digraphe
La liste d’adjacence de digraphe 1.6 est donc :
1 2 3 4 5
2 3
3 4
4−
5 1 410 Chapitre 1. Les graphes
1.3.2 Matrices d’adjacence
Définition 1.6: Mat. Adjacence
Soit G=(V,E) un graphe (orienté) d’ordre n. On peut numéroter V={1,2,..., n}.La matrice d’adjacence
deGest la matrice carrée A=(ai j) d’ordre n, définie par :
ai j=(
1 si ( i j)∈E;
0 sinon.
Remarque 3.
1. Si le graphe G est non orienté et simple, alors la matrice A est symétrique avec des 0sur la diagonale. Pour un
digraphe simple, on a toujours des 0sur la diagonale, mais la matrice n’est pas symétrique en général.
2. Pour les multigraphes, il peut y avoir des termes diagonaux (pour les boucles) et s’il y a plusieurs arêtes de i à
j , le coefficient de la matrice a i jest le nombre d’arêtes de i à j .
3. Pour un (di)graphe valué G =(V,E,w), on pose :
ai j=(
w(i,j)si(i j)∈E ;
∞ sinon.
La matrice d’adjacence de la figure 1.4 est :

∞ 5∞ 4 3 ∞
∞ ∞ 3∞ 1∞
∞ ∞ ∞ ∞ ∞ 5
∞ ∞ 3∞ 3 3
∞ ∞ ∞ ∞ ∞ 8
∞ ∞ ∞ ∞ ∞ ∞

1.3.3 Matrice d’incidence
Définition 1.7: Mat. Incidence
Soit G=(V,E) un graphe (simple) d’ordre net de taille m. On pose V={v1,v2,..., vn} etE={e1,e2,..., em}.
La matrice d’incidence deGest la matrice de type n×m B=(bi j), définie par :
•Si G orienté
bi j=

1 si ej=vi→ • (i.e. viest l’extrémité initiale de ej) ;
−1 si ej= • → vi(i.e. viest l’extrémité terminale de ej) ;
0 sinon.
•Si G non-orienté
bi j=(
1 si viest une extrémité de ej;
0 sinon.
Exercice 1.3
1. Donner la matrice d’incidence du graphe 1.6.
2. Montrer le théorème 1.1 avec la matrice d’incidence.CHAPITRE 2
La connexité
Il est important de savoir si on peut suivre un chemin d’un sommet donné à un autre dans un graphe donné.
Cette propriété (de connexité) doit être maintenue dans différents types de réseaux.
2.1 Les chaînes et les cycles
Définition 2.1: (chaine – cycle) (chemin – circuit)
•Graphe non orienté
1. Une chaîne (walk ) reliant xày, notée µ(x,y), est définie par une suite finie d’arêtes consécutives,
reliant xày, ou encore une séquence de sommets (puisque non multigraphe)
µ(x,y)=<v0,v1,..., vk>
tels que v0=x,vk=yet (vi−1,vi)∈E(G) pour tout i=1... k. Six=yla chaîne est dite fermée .
Lalongueur du chaîne l(µ(x,y)) est le nombre d’arcs dans la chaîne, c’est-à-dire k.
2. Une chaîne élémentaire (a path ) si tous les sommets sont distincts. Une chaîne simple (a simple
walk, a trail ) est une chaîne ne passant pas deux fois par une même arête, c’est-à-dire dont toutes
les arêtes sont distinctes. Remarquer que : élémentaire =⇒ simple.
3. Un cycle v0v1...vnde longueur n≥3 est une chaîne simple fermée ( v0=vn) tel que les sommets
v0,v1,..., vn−1sont tous distincts. Un graphe sans cycle est dit acyclique .
•Graphe orienté
Dans un graphe orienté, on parlera de chemin au lieu de chaîne, et de circuit au lieu de cycle.
Example 2.1
abxcd xa est une chaîne simple et fermée (non cycle!) de longueur 6 (mais, c’est un graphe eulérien - voir
plus loin). Y a-t-il un cycle de longueur 3,4 ?
a b
x
c dÏ
Remarque 4.
1. On peut pivoter une chaine fermée (l’orienter de manière arbitraire) , i.e.
<v0,v1,v2,..., v0>=< vk,vk+1,..., v0,v1,..., vk>
1112 Chapitre 2. La connexité
2. Soient x ,y∈V . La distance de x à y est définie par :
d(x,y)=(
k si le plus court chemin/chaîne de x vers y est de longueur k
∞ sinon
On convient que d (x,x)=0.
3. Le diamètre du graphe la plus grande distance entre deux sommets.
L ’observation suivante, bien que très facile à prouver, sera utile.
Théorème 2.1
S’il existe une chaîne du sommet yau sommet zdans le graphe G, où y̸=z, alors il existe une chaîne élé-
mentaire ( path ) dans Gavec pour premier sommet yet pour dernier sommet z.
Preuve. Soit la chaine
W1=µ(y,z)=x0x1...xn; avec x0=yetxn=z.
Si les sommets x0,x1,..., xnsont tous distincts, alors W1est une chaîne élémentaire, et nous avons terminé. Sinon,
il existe xi=xj(i<j) et on écrit :
W2=x0x1...xixj+1...xn.
Alors, l(W2)<l(W1). Si W2ne contient aucun sommet répété, alors c’est la chaîne recherché. Sinon, par la même
procédure, il existe W3(y z−chaîne) tel que
l(W3)<l(W2)<l(W1).
Ce processus doit s’arrêter à un certain stade, car chaque chaîne est plus courte que la précédente et la longueur
ne peut jamais être inférieure à 1
1< ··· < l(Wk)< ··· < l(W3)<l(W2)<l(W1).
Ainsi, pour un certain k,Wkne peut pas être réduit en longueur. Donc, la chaîne Wkne contient aucun sommet
répété et est donc une y z−chaîne élémentaire (path).
Exercice 2.1
Dans le graphe suivant, construire un path à partir de la chaîne W=v2v3v4v5v6v4v2v8v1
v1
 v2
v3
v4
v5
v6
v7
 v8
 v9
Calculer d(v1,v7) et le diamètre de G.
/pythonpython : >>G = nx.Graph([(1, 2), (2, 3), (2, 4), ...]) >>nx.diameter(G)
Les cycles fournissent la caractérisation suivante pour les graphes bipartis .H. SABRI 13
Théorème 2.2
Un graphe est biparti si et seulement s’il ne contient aucun cycle de longueur impaire.
Preuve.
⇒On suppose que G=U˙∪Vest un graphe biparti. Soit W=< x1,x2,..., x2k+1,x1>un cycle de longueur im-
paire (2 k+1). Si x1∈U, alors
x1∈U=⇒ x2∈V=⇒ x3∈U=⇒ ··· =⇒ x2k+1∈U=⇒ x1∈V/exclamati⌢n-triangle
absurde, d’où le résultat.
⇐On suppose que Gest connexe (car l’union des composantes connexes bipartis est un graphe biparti). Soit
xun sommet de Get on pose :
U={y∈V(G):d(x,y) est paire} et V={z∈V(G):d(x,z) est impaire}
S’il existe y1,y2∈Utel que y1y2∈E(G), alors on a :
W1=<x,..., y1>est une chaîne de longueur paire =2k1
W2=<x,..., y2>est une chaîne de longueur paire =2k2
=⇒ W3=<x,..., y1,y2,..., x>est un cycle de longueur impaire =2k1+2k2+1/exclamati⌢n-triangle
Donc G=U˙∪Vest un graphe biparti.
Exercice 2.2
Vérifier si le graphe maison est un graphe biparti. Faire de même pour la grille G4,4.
maison grille
2.2 Graphe connexe, eulérien, hamiltonien
Définition 2.2: Graphe connexe
Un graphe est dit connexe si deux points peuvent toujours être joints par une chaîne, i.e.
∀x,y∈V(G),d(x,y)< ∞
— Une composante connexe d’un graphe est un sous-graphe induit maximal connexe.
— Un point d’articulation d’un graphe est un sommet dont la suppression augmente le nombre de
composantes connexes.
Par exemple, le graphe suivant :14 Chapitre 2. La connexité
a
 b
d
 c
e
f
 g
n’est pas connexe car il n’existe pas de chaîne entre les sommets aete. On a donc 2 composantes connexes. En
revanche, le sous-graphe induit par les sommets { a,b,c,d} est connexe dont aest le seul point d’articulation.
Remarque 5.
1. Un graphe connexe à n sommets possède au moins n −1arêtes ( faite une preuve par récurrence ).
2. L’algorithme de parcours en profondeur permet de déterminer si un graphe est connexe ou non.
3. Même définitions dans un graphe orienté . Graphe orienté (fortement) connexe et de composante connexe .
Définition 2.3: Graphe eulérien
— Une chaîne joignant deux sommets xetyest dite chaîne eulérienne si elle emprunte chaque arête
deGune et une seule fois. On parle de chemin eulérien dans le cas d’un graphe orienté.
— Un cycle eulérien est une chaîne eulérienne dont les extrémités coïncident. Un graphe qui admet
un cycle (resp. circuit) eulérien est dit graphe eulérien .
/flushedRemarquer qu’un cycle eulérien n’est pas forcément un cycle comme définit dans la définition 2.1
Si un graphe (ou multigraphe) Gpossède une chaîne eulérienne, alors soit Gpossède deux sommets impairs, le
début et la fin de cette chaîne, soit Gn’a aucun sommet impair, et la promenade d’Euler commence et se termine
au même point (cycle eulérien). Une autre condition nécessaire évidente est que Gdoit être connexe. Ces deux
conditions sont ensemble suffisantes.
Théorème 2.3 Euler
Soit Gun graphe (multigraphe) connexe.
— Si Gn’a pas de sommets impairs, alors il possède un cycle eulérien (commençant à n’importe quel
point).
i.e.∀x,d(x)≡0 mod 2 =⇒ Gest un graphe eulérien.
— Si Ga deux sommets impairs, alors il possède une chaîne eulérienne dont le début et la fin sont les
sommets impairs.
La réciproque est aussi vraie.
Preuve.
⇐On commence par la réciproque. S’il existe une chaîne eulérienne µ(x,y), alors on peut crée une arête fictive
e=(y,x) et par la suite on obtient un cycle eulérien. Donc il suffit de montrer que si Gadmet un cycle
eulérien alors tous les sommets sont de degré pair.
Soit W=< v1,v2,..., vn,v1>un cycle eulérien. Soit le sommet vjavec j̸=1, il est donc claire que chaque
fois vjapparaît dans W, il ya deux arcs distincts incidents en vj( (•,vj) et ( vj,•)). Comme toutes les arêtes
sont utilisées, on voit que d(vj) est pair. Même chose pour v1car on ajoute deux arcs ( v1,v2) et ( v1,vn).
⇒On suppose que tous les sommets sont de degré pair. Montrons que Gadmet un cycle eulérien. Puisque
tous les sommets sont de degré pair on peut construire d’abord une chaîne simple fermée (quelconque)
W1=<v1,v2,..., vk,v1>
SiW1contient chaque arête de G, alors c’est finis, c’est un cycle eulérien. Sinon (puisque Gest connexe), il
existe une arête e=(vi,c) qui n’est pas dans W1(avec visommet de W1). On pose le sous-graphe
G′=G−{ arêtes de W1}H. SABRI 15
Il est donc claire que les sommets de G′sont aussi de degré pair. Alors, par la même procédure on construit
une chaîne simple fermée dans G′de la forme : <vi,c,d,..., vi>et par la suite on insère cette chaîne dans
W1pour obtenir :
W2=<v1,v2,..., vi,c,d,..., vi,vi+1,..., vk,v1>
Sil(W2)< |E(G)|, on construit W3de longueur plus grand. Ainsi, on a :
l(W1)<l(W2)<l(W3)< ··· ≤ | E(G)|
Donc, nécessairement, il existe Wk(chaîne simple fermée de longueur |E(G)|) donc c’est un cycle eulérien.
Finalement , si∃a,b∈V(G):d(a)≡d(b)≡1 mod 2, et tous les autres sommets sont de degré pair, alors on
pose :
G′=G+{a,b}
et donc tous les sommets de G′sont de degré pair. Avec la construction précédente, il existe un cycle eulérien
dans G′:
W=<a,b,v1,..., a>
est donc la chaîne <b,v2,..., a>est une chaîne eulérienne dans G.
Algorithme 1 : Euler
Entrées : Gun graphe eulérien
Output : Un cycle eulérien W
/* On suppose que G est eulérien, i.e. les sommets sont de degré pair */
1Gaux←G;W←µ(v,v) une chaîne simple (quelconque) de G; // Initialisation
2tant que l(W)<e(G)faire
3 Gaux←G−{ arêtes de W} ;
4 Choisir ( x,c)∈E(Gaux) tel que x∈W;
5 L←< x,c,..., x>une chaîne simple de Gaux ;
6 Dans W, remplacer (juste ce) xpar la séquence L;
7fin
8retourner W;
Exercice 2.3
1. Montrer que le graphe de l’exercice 2.1 est un graphe eulérien et donner un cycle eulérien.
2. Tracer cette maison d’un seul trait.
Remarque 6. Le théorème d’Euler dans un graphe orienté connexe s’écrit :
Admet un circuit eulérien si, et seulement si, pour tout sommet, le degré entrant est égal au degré sortant.
∀v∈V(G),d+(v)=d−(v)
Admet un chemin eulérien de a vers b si, et seulement si,


d+(v)=d−(v) ;∀v̸=a,b,
d−(a)=d+(a)−1
d−(b)=d+(b)+116 Chapitre 2. La connexité
Définition 2.4: Graphe hamiltonien
Soit Gun graphe connexe d’ordre n. On appelle :
1. On appelle cycle hamiltonien deGun cycle passant (une et une seule fois) par chacun des sommets
deG. Un graphe est dit hamiltonien s’il possède un cycle hamiltonien.
2. Une chaîne hamiltonienne est une chaîne passant une et une seule fois par chacun des sommets de
G. Un graphe ne possédant que des chaînes hamiltoniennes est semi-hamiltonien .
3. Dans un digraphe, on change cycle par circuit et chaîne par chemin .
Remarque 7.
— Une chaîne hamiltonienne est une chaîne élémentaire de longueur n −1.
— Un graphe peut être eulérien, hamiltonien, les deux à la fois, ou aucun des deux.
— De nombreux problèmes concrets peuvent être formulés en termes de recherche de parcours hamiltoniens : pro-
blème du voyageur de commerce (chercher un cycle hamiltonien de longueur totale minimale), l’ ordonancement
de tâches .
— Le problème du chaîne hamiltonienne est un problème NP-complet .
Exercice 2.4
Donner un graphe (connexe, simple) qui soit :
1. hamiltonien et eulérien.
2. hamiltonien et non eulérien.
3. eulérien et non hamiltonien.
4. non hamiltonien et non eulérien.
Aucune condition nécessaire et suffisante adéquate n’est connue pour l’existence de cycles hamiltoniens. Le
résultat suivant constitue une condition suffisante utile.
Théorème 2.4 Ore
Soit Gun graphe simple d’ordre n≥3. Si pour toute paire { x,y} de sommets non adjacents, on a d(x)+d(y)≥
n, alors Gest hamiltonien.
Preuve. On suppose que le théorème est faux. Alors, il existe un graphe Gsimple d’ordre nnon hamiltonien tel que
d(u)+d(v)≥npour tout sommets non adjacents uetv. On prend Gun tel graphe d’ordre nde taille maximale qui
vérifie cette propriété (remarquer que le graphe complet Knest hamiltonien).
Soient uetvdeux sommets non adjacents de G. Par maximalité de G, le graphe G+uv(d’ordre n) doit être
hamiltonien. Donc il existe dans G+uvun cycle hamiltonien :
W=<u,x1,x2,..., xn−2,v,u>
u
x1
xi xi+1xn−2
v
... ...
Or, si uxi+1∈E(G) etv xi∈E(G) (les arcs en rouge), alors on peut construire dans Gle cycle hamiltonien :
<u,x1,x2,..., xi,v,xn−2,..., xi+1,u>H. SABRI 17
Ceci est absurde car Gest non hamiltonien. Donc si xi+1est un sommet voisin à u, alors le sommet xin’est pas
voisin de v:
xi+1∈Γ(u)=⇒ xi∉Γ(v)
Donc :
d(u)= |Γ(u)| =p=⇒ d(v)≤(n−1)−p
et par la suite
d(u)+d(v)≤n−1
ce qui absurde par hypothèse. Donc Gest hamiltonien.
Une conséquence immédiate est le théorème de Dirac :
Proposition 2.1 Dirac
Soit Gun graphe simple d’ordre n≥3. Si pour tout sommet xdeG, on a d(x)≥n
2, alors Gest hamiltonien.
2.3 Arbres
Définition 2.5: Arbres et forêts
On appelle arbre tout graphe (non orienté) connexe et acyclique . Les composantes connexes dans un
graphe acyclique sont des arbres et le graphe est dit forêt . Une feuille ou sommet pendant est un som-
met de degré 1.
Un forêt avec deux arbres
Un graphe Gest une arborescence s’il existe un sommet Rappelé racine deGtel que, pour tout sommet
SdeG, il existe un chemin et un seul de Rvers S. Donc, c’est un arbre orienté dans lequel on choisit un
sommet Rcomme racine et on dirige les arcs vers le sens sortant de la racine.
Remarque 8.
— Un graphe G d’ordre n est un arbre ssi G est sans cycle et possède n −1arêtes.
— Un graphe G d’ordre n est un arbre ssi G est connexe et possède n −1arêtes.
— G est un arbre si pour chaque paire u ,v de sommets distincts est reliée par une seule chaîne (donc chaîne
élémentaire d’après le théorème 2.1).
— Un arbre (ou forêt) est nécessairement un graphe simple.
Pour démontrer les remarques précédentes, il suffit de prouver le théorème suivant :
Théorème 2.5
Soit Gun graphe ayant marêtes, nsommets et pcomposantes connexes, on définit nu( G) :
ν(G)=m−n+p
Alors, on a :
1.ν(G)≥0.
2.ν(G)=0⇐⇒ Gest acyclique.18 Chapitre 2. La connexité
Preuve. Par récurrence sur la taille mdu graphe. Le résultat est évident pour m=0 et m=1. On suppose le résultat
est vrai pour les graphe de taille m, et montrons que ceci est vrai pour un graphe de taille m+1. Soit donc Gun
graphe d’ordre nde taille m+1 ayant pcomposantes connexes.
•On suppose que Gest un graphe acyclique. Soit uvune arête de Gdans la composante C. Si on supprime uv,
la composante Cse transforme en deux composantes connexes (sinon on a un cycle dans G). Par la suite,
le graphe G′=G−uvest un graphe acyclique d’ordre n, de taille met ayant p+1 composantes connexes.
Donc d’après l’hypothèse de récurrence :
ν(G′)=0=(m−1)−n+(p+1)=m−n+p=ν(G)
•Maintenant, si Gcontient un cycle Wdans la composante connexe C. Soit uvune arête de W, alors si on
supprime l’arête uv, la composante Creste connexe. Donc le graphe G′=G−uvest un graphe d’ordre nde
taille m−1 ayant pcomposantes connexes. Donc, d’après l’hypothèse de récurrence :
ν(G′)=(m−1)−n−p≥0
=⇒ν(G)=m−n−p≥1>0
D’où le résultat – car si ν(G)=0,Gne peut être que acyclique, sinon 0 =ν(G)≥1/exclamati⌢n-triangle
2.3.1 Codage et décodage d’un arbre – Prüfer code
Soit Tun arbre ayant nsommet numérotés {1,2,..., n}. Le codage de Prüfer représente l’arbre Tarbre de avec
une suite P=(x1,x2,x3,..., xn−2) de n−2 termes (les n° des sommets avec répétition possible). Une suite Pdonnée
correspond à un et un seul arbre numéroté. Voici les algorithmes de codage et de décodage.
Algorithme 2 : Codage de Prüfer
Entrées : Un arbre T
Output : Séquence de Prüfer P
1P←() ; // Initialisation de P comme séquence vide
2tant que v(T)>2faire
3 x←feuille de Tayant le n° minimum ; // donc d(x)=1
4 P←(P,s) où sest le seul (n°) sommet adjacent à x;
5 T←T−x;
6fin
7retourner P;
Example 2.2
Donner le code de Prüfer de l’arbre :
126 345
Indice : on trouve, P=(2,3,3,2)
Pour faire la réciproque, étant donnée une séquence P=(x1,x2,..., xn−2) où les xi∈{1,2,..., n}, on construit
l’arbre Tdont les sommets sont {1,2,..., n} avec l’algorithme suivant (le décodage) :H. SABRI 19
Algorithme 3 : Décodage de Prüfer
Entrées : Une séquence Pde taille n−2
Output : L ’arbre Tcorrespondante
1I←{1,2,..., n};
2T←graphe tel que V(T)=IetE(T)= ; ; // T graphe à n sommets isolés
3tant que P̸=()faire
4 i←min {x∈I:x∉P};
5 T←T+(i,P[1]) ; // ajouter l'arc (i,P[1])
6 P←P−P[1];I←I−{i};
7fin
8T←T+(a,b) ; // a,b sont les deux éléments restant dans I
9retourner T;
Example 2.3
Donner l’arbre dont le code de Prüfer est : P=(2,3,3,3)
Puisqu’il ya une bijection entre les arbres d’ordre net les suites Pde longueur n−2 à coefficients dans {1,2,..., n},
on déduit le théorème de Cayley :
Théorème 2.6 Formule de Cayley
Le nombre d’arbres que l’on peut construire sur n(n≥2) sommets numérotés est égal à nn−2.
2.3.2 Arbre couvrant de poids minimum – ACM
Soit Gun graphe (non orienté). Un arbre couvrant (spanning tree) TdeGest un sous graphe couvrant de G
tel que Test un arbre. Remarquer que, Gdoit être connexe, sinon un arbre couvrant de Gn’existe pas. Le nombre
des arbres couvrant de Gest noté a(G). Remarquer que a(Kn)=nn−2(le nombre de Cayley). Un problème algo-
rithmique classique est de trouver, dans un graphe valué , un arbre couvrant de poids minimal . On dispose de
plusieurs algorithmes (l’algorithme de Prim, l’algorithme de Kruskal ...).
Algorithme 4 : Kruskal
Entrées : Un graphe Gvalué d’ordre net de taille m
Output : Arbre (ou forêt) couvrant de poids minimum
1Numéroter les arêtes de Gpar poids minimum : w(e1)≤w(e2)≤ ··· ≤ w(em)
2T←graphe tel que V(T)=V(G) etE(T)= ; ; // T graphe à n sommets isolés
3k←0;
4tant que k<m et e (T)<n−1faire
5 siT+ek+1est acyclique alors
6 T←T+ek+1;
7 k←k+1;
8fin
9retourner T;
Appliquer l’algorithme de Kruskal dans le graphe suivant :
CHAPITRE 3
Les algorithmes de base
Beaucoup de problèmes sur les graphes nécessitent que l’on parcourt l’ensemble des sommets et des arcs. Par
exemple, pour vérifier que le graphe est connexe, chercher un sommet particulier, construire un arbre couvrant,
trouver un plus court chemin ...etc.
3.1 Parcours en profondeur (DFS) / largeur (BFS)
Une manière simple de tester si un graphe Gest connexe ou non est d’exécuter l’algorithme DFS ouBFS dans
Gen commençant par n’importe quel sommet et en enregistrant les sommets visités pendant l’exécution dans une
liste. Si la liste contient tous les sommets de G, alors Gest connexe. Une petite modification permet de donner les
composantes connexes de G. L ’algorithme DFS_Component suivant donne les composantes connexes de G. Il est
donné sous forme d’implémentation récursive.
Algorithme 5 : DFS_Component
Entrées : Un graphe G=(V,E)
Output : Les composantes connexes C=(C1,C2,..., Ck) de G.
1VisitedNodes ← ; ;
2k←0 ; // k est le nombre des composantes connexes
3pour chaque u∈Vfaire
4 siu∉VisitedNodes alors
5 k←k+1;
6 DFS( u);
7 fin
8fin
9retourner (C1,C2,..., Ck);
1Procedure DFS( u )
2 VisitedNodes ←VisitedNodes ∪{u};
3 Ck←Ck∪{u};
4 pour chaque x∈Γ(u)faire
5 six∉VisitedNodes alors
6 DFS( x);
7 fin
8 fin
Note : -
Il est possible de d’implémenter la procédure DFS itérativement à l’aide d’une pile LIFO (stack) contenant les
sommets à explorer : on désempile un sommet et on empile ses voisins non encore explorés.
20H. SABRI 21
Pseudocode :
stack . push ( root )
while stack . isEmpty ( ) = f a l s e do
node = stack . pop ( ) // so mark i t as v i s i t e d
for each x in node . childNodes do
i f x i s not v i s i t e d then
stack . push ( x )
. . .
endfor
endwhile
Example 3.1 (DFS )
Ici on empile (gris) les sommets les plus à droite, alors l’ordre des sommets visité (noir) est ( a,b,d,e,g,c,f).
Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b
 c
d
 e
f
g
a
b
 c
d e
f
ga
b
 c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g
L ’utilisation d’une file (FIFO) au lieu d’une pile transforme l’algorithme du parcours en profondeur en algo-
rithme de parcours en largeur ( BFS ). Avec BFS l’exemple précédent devient (en enfile le plus à gauche) :
Example 3.2 (BFS )
Ici, avec BFS, on enfile (gris) les sommets les plus à gauche d’abord, alors l’ordre des sommets visité (noir)
est ( a,b,d,e,g,c,f). Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b c
d
 e
f
g
a
b c
d
 e
f
ga
b c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g22 Chapitre 3. Les algorithmes de base
Exercice 3.1
1. Écrire la procédure BFS .
2. Utiliser DFS (ou BFS) pour la construction d’un arbre couvrant d’un graphe connexe. L ’appliquer
pour le graphe triangle.
3. Utiliser DFS pour écrire une procédure DFS_Cycle pour détecter un cycle dans un graphe.
On sait qu’un graphe orienté G=(V,E) est fortement connexe si pour chaque paire de sommets u,v∈V, il
existe un chemin de uàvet il existe un chemin de vàu. En d’autres termes, nous avons besoin d’une connectivité
dans les deux directions .
Une procédure pour tester si un graphe orienté est fortement connexe ou non peut être conçue avec l’idée
suivante. En partant d’un sommet arbitraire vdu graphe G, on exécute l’algorithme BFS ouDFS et l’on note les
sommets visités. Ensuite, on obtient la transposée de G,GT, en inversant la direction des arêtes de G, et l’on
exécute à nouveau l’algorithme BFS ou DFS à partir du sommet v. Si les sommets visités dans les deux cas sont
égaux à V, alors le graphe orienté est fortement connexe. Cette méthode est illustrée dans l’algorithme 6.
Algorithme 6 : Fortement_connexe
Entrées : Un graphe orienté G=(V,E)
Output : true siGest fortement connexe et false sinon
1X← ; ;
2Y← ; ;
3v←un sommet quelconque de V;
4X←DFS( G,v) ; // Enregistrez les sommets visités dans X
5GT←Gavec flèches inversées;
6Y←DFS( GT,v);
7siX=Y=Valors
8 retourner TRUE.
9sinon
10 retourner FALSE.
11fin
3.2 Recherche des chemins
3.2.1 Matrice d’adjacence et nombre de chemins
La puissance de la matrice d’adjacence Amontre qu’il y a des chemins (ou chaînes) de longueur kallant de xà
ycomme le montre le théorème suivant.
Théorème 3.1
Soit G=(V,E) un (di)graphe. On note V={1,2,..., n} et Asa matrice d’adjacence et Akla puissance k-ème
deA. Alors le terme d’indices i,jdeAkest le nombre de chemins (chaînes) de longueur kallant de iàj.
Preuve. Par récurrence sur k. Pour k=1 c’est clair. On suppose le résultat est vrai à l’ordre ket montrons qu’elle
est vrai pour k+1. Soit S=(si,j)=Ak. Si on a un chemin de iàjde longueur k+1, alors on va d’abord de ià un
sommet ravec kpas et puis de ràj. Or d’après l’hypothèse de récurrence on a si,rchemins possibles pour aller de
iàret finalement ar,jpas (1 ou 0) pour aller de ràj. Ainsi, le nombre totale possibles (i.e. tous les sommets r) est :
nX
r=1si,rar,j=³
Ak×A´
i,jH. SABRI 23
ce qui est bien le terme ( i,j) de la matrice Ak+1.
3.2.2 Plus court chemin et l’algorithme de Dijkstra
Dans cette partie on suppose que le (di)graphe G=(V,E,w) est valué positivement (i.e.∀e∈E,w(e)>0). Notre
objectif est de chercher un plus court chemin (i.e., un chemin de poids minimal ) d’un sommet ufixé à un sommet
quelconque de G.
Il est clair que l’on peut restreindre ce problème au cas d’un (di)graphe simple1. On suppose aussi que Gest
connexe (sinon, certains trajets sont impossibles). Il est aussi claire (d’après théorème 2.1), qu’un plus court chemin
est nécessairement un chemin élémentaire (path).
L ’algorithme de Dijkstra (1959) permet de calculer le plus court chemin entre un sommet particulier u(racine )
et tous les autres sommets. L ’algorithme fonctionne de la manière suivante :
Pour tout sommet vdeG, on associe une valeur T(v), initialisée à w(u,v) et une liste de sommets C(v) qui
correspond à un chemin de uàv. À la fin de l’algorithme, T(v) contient le poids minimal des chemins joignant uà
v(ou T(v)= ∞ siu↛v) et la liste C(v) réalise un tel chemin. Voici donc l’algorithme de Dijkstra :
Algorithme 7 : Algorithme de Dijkstra
Entrées : Un (di)graphe valué G=(V,E,w) et un sommet racine u
Output : Le coût minimum d’un chemin de uàv(∀v∈V) et un trajet pour chaque coût minimal obtenu
1∀v∈V,T(v)←w(u,v) etC(v)←(u,v); // Initialisation de T(v) et la liste C(v)
2X←{u};
3tant que X̸=Vfaire
4 Choisir v∈V−Xtel que ∀y∈V−X,T(v)≤T(y);
5 X←X∪{v};
6 pour chaque y∈V−Xfaire // Faire les mises à jours pour les autres sommets
7 siT(y)>T(v)+w(v,y)alors
8 T(y)←T(v)+w(v,y);
9 C(y)←[C(v),y]; // On ajoute à la liste C(v) l'élément y
10
11 fin
12 fin
13fin
Example 3.3
Voici une application de l’algorithme de Dijkstra au digraphe suivant. On prend Ecomme sommet racine.
EA
B
CD
FG
S5
4
21
12
2
34
4
215
7
1. En effet, passer par une boucle ne ferait qu’augmenter inutilement le poids de ce chemin. De même, si plusieurs arcs joignent deux
sommets, il suffit de conserver l’arc de poids minimal.24 Chapitre 3. Les algorithmes de base
Ainsi, pour l’initialisation, on a : X={E} et on a les valeurs :
v  E A B C D F G S
T(v) 0 5 4 2 ∞ ∞ ∞ ∞
C(v)(E,E) ( E,A) ( E,B) ( E,C) ( E,D) ( E,F) ( E,G) ( E,S)
Maintenant, on choisit (un seul choix) le sommet C, donc X={E,C}. Le tableau est mis à jour :
v  E A B  C D F G S
T(v) 0 5 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À l’étape suivante, on est forcé de choisir B. Ainsi, X={E,C,B} et la mise à jour est :
v  E A  B  C D F G S
T(v) 0 4 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À présent, on a le choix entre AetF. On choisit A. Donc X={E,C,B,A} et on a :
v  E  A  B  C D F G S
T(v) 0 4 3 2 6 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,B,A,D) ( E,C,F) ( E,C,G) ( E,S)
Puis, on prend le sommet F. D’où X={E,C,B,A,F} et :
v  E  A  B  C D  F G S
T(v) 0 4 3 2 5 4 5 11
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,S)
On prend Det on obtient X={E,C,B,A,F,D} et :
v  E  A  B  C  D  F G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Finalement, on prend Gpuis Set on voit que ceci ne change rien. D’où le tableau finale :
v  E  A  B  C  D  F  G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Ainsi le chemin minimum pour aller de EàSest de coût 10 et un trajet de coût minimal de EàSest : EC F DS .H. SABRI 25
3.3 Problèmes d’ordonnancement et chemin critique
Un problème d’ordonnancement peut-être représenté sous la forme d’un digraphe. Les sommets sont des évé-
nements (début et fin de la tâche) et les arcs des tâches, La longueur (ou poids) de chaque arc représente la durée
d’exécution de la tâche. Ainsi, la tâche correspondant à l’arc ( i,j) ne peut commencer que si toutes les tâches cor-
respondant à des arcs ( k,i) ont été complétées. On ajoute deux sommets pour le début (s) et de fin(t) du projet .
Le digraphe peut contenir des tâches fictives dedurée nulle afin de forcer certaines précédences (postériorité).
Ainsi, un réseau PERT est un digraphe valué G=(V,E,w,s,t) où la fonction poids (ou longueur) w:E→R+
etsle sommet source (début) et tle sommet puits (fin). Un chemin critique est un chemin de sàtdelongueur
maximale . S’il n’existe pas de chemin critique, le projet n’est pas réalisable (e.g. un circuit). Le temps minimal
requis pour l’exécution d’un projet réalisable est égal à la longueur d’un chemin critique. Les tâches figurant sur un
chemin critique sont aussi appelées critiques, ce qui s’explique par le fait que tout retard d’exécution d’une tâche
critique retarde d’autant l’exécution du projet.
3.3.1 Algorithmes de tri topologique et de chemin critique
Il faut d’abord numérotés les sommets de 1 à nde manière compatible au pré-ordre (rang) avec l’algorithme du
rang suivant (tri topologique) :
Algorithme 8 : Algorithme du rang
Entrées : Un digraphe G=(V,E) sans circuit
Output : Le rang r(v) de chaque sommet v∈Vde G
1r←0;X←V;
2R←{v∈X:Γ−
X(v)= ;} ; // l'ensemble des sommets de X sans prédécesseur dans X
3tant que X̸= ; faire
4 r(v)←rpour chaque sommet v∈R;
5 X←X−R;
6 R←l’ensemble des sommets de Xsans prédécesseur dans X;
7 r←r+1;
8fin
On supposera dorénavant que les sommets ont déjà été numérotés de 1 à nde manière compatible avec leurs
rangs, c’est-à-dire que r(j)>r(i) implique j>i(donc 1 =setn=t). Enfin, on supposera éliminés les arcs paral-
lèles par l’introduction de tâches fictives de durée nulle .
Pour un sommet i, on note tiledébut au plus tôt des tâches correspondant aux arcs i→jet par Tilafin au
plus tard des tâches correspondant aux arcs j→i.
Algorithme 9 : Algorithme du chemin critique
Entrées : Un digraphe G=(V,E) sans circuit trié topologiquement
Output : La durée du chemin critique et les dates ti,Ti
1t1←0;
2pour j=2···nfaire // Calcul des dates de début au plus tôt  récurrence en avançant
3 tj←max i∈Γ−(j){ti+w(i,j)}
4fin
5Tn←tn;
6pour j=n−1···1faire // Calcul des dates de fin au plus tard  récurrence en reculant
7 Tj←min i∈Γ+(j){Ti−w(j,i)}
8fin26 Chapitre 3. Les algorithmes de base
Définition 3.1
— Un sommet iest critique si ti=Ti.
— Un arc ( i,j) est critique les sommets ietjsont critiques ettj−ti=w(i,j).
— Un chemin critique est un chemin de 1 à nn’utilisant que des arcs critiques.
— La durée du chemin critique est donnée par Tn(ou par tn). Elle correspond à la durée minimale du
projet .
Example 3.4
L ’application de l’algorithme du chemin critique au digraphe suivant (trié topologiquement) est :
1 23
45
6B
9A
3
C
5D
8
E
4
F7G
20
H6I5
=⇒
 1
0,02
9,933,16
4
16,23513,24
6
29,29B
9A
3
C
5D
8
E
4
F7G
20
H6I5
Les tâches critiques sont BetG. La durée totale minimale du projet est donc 29.
Exercice 3.2
Les tâches ( durée et précédences ) pour la construction d’un entrepôt sont données dans le tableau suivant :
Tâches Nature Précédences Durée (jours)
A Acceptation des plans par le propriétaire – 4
B Préparation du terrain – 2
C Commande des matériaux A 1
D Creusage des fondations A, B 1
E Commande des portes et fenêtres A 2
F Livraison des matériaux C 2
G Coulage des fondations D, F 2
H Livraison des portes et fenêtres E 10
I Pose des murs, de la charpente et du toit G 4
J Mise en place des portes et fenêtres H, I 1
1. Représentez le graphe des précédences de ce projet (trié topologiquement).
2. Déterminez une durée totale minimale en exhibant un chemin critique dans ce graphe.CHAPITRE 4
Programmation linéaire
La programmation linéaire est le processus de minimiser ou maximiser une fonction objective linéaire sou-
mise à un nombre fini de contraintes d’égalités et d’inégalités linéaires.
La programmation linéaire a de nombreuses applications dans le domaine de l’informatique théorique. Elle
peut être utilisée pour résoudre de nombreux problèmes combinatoires variés, tels que la recherche de flot maxi-
mum dans un réseau, la recherche d’un couplage maximal dans un graphe et la coloration d’un graphe parfait.
Example 4.1 (Problème de régime)
On suppose qu’on a quatre plats : de la truite ( XT), un sandwich au corned-beef ( XC B), un burrito ( XBU R )
et un hamburger ( XHB). Le tableau suivant répertorie la valeur nutritionnelle de chaque plat (vitamines et
calories) et notre besoin journalier des vitamines.
Vit. A Vit. C Vit. D Calories
Truite 203 92 100 600
Corned-beef 90 84 230 350
Burrito 270 80 512 250
Humburger 500 90 210 500
Besoins 2000 300 430
Notre objectif est de minimiser le nombre total de calories consommées : 600 XT+350XC B+250XBU R+
500XHBtout en satisfaisant les trois besoins nutritionnels en vitamines. Le programme linéaire résultant
s’écrit :
min 600 XT+350XC B+250XBU R+500XHB
s.t. 203 XT+90XC B+270XBU R+500XHB≥2000, (Besoins de Vit. A),
92XT+84XC B+80XBU R+90XHB≥300, (Besoins de Vit. C),
100XT+230XC B+512XBU R+210XHB≥430, (Besoins de Vit. D),
XT,XC B,XBU R ,XHB≥0
Définition 4.1: Forme canonique – Forme standard
On peut écrire un P .L. sous deux formes spéciales :
•Canonique
max
mincTX+c0
s.t. AX≤b(≥bsi min),
X≥0•Standard
max cTX+c0
s.t. AX=b,
X≥0Avec :
cTX=¡
c1··· cn¢
x1
...
xn

cTX+c0=c1x1+c2x2+···+ cnxn+c0
2728 Chapitre 4. Programmation linéaire
Remarque 9. Un P .L. général peut être formulé selon une forme standard ou canonique par la méthode suivante :
générale =⇒ standard il faut éliminer les contraintes d’inégalité et les variables sans contrainte de positivité.
— Si dT
iX≤biest une contrainte d’inégalité, alors créer une nouvelle variable ( d’écart ) siet remplacer l’in-
égalité dT
iX≤bipar dT
iX+si=biet s i≥0.
Si dT
iX≥bi, alors on peut écrire dT
iX−si=biet s i≥0.
— Si une variable x i≶0est de signe quelconque, alors créez deux nouvelles variables x+
iet x−
iet remplacez
xipartout par x+
i−x−
i, et ajoutez les contraintes de signe : x+
i≥0,x−
i≥0.
générale =⇒ canonique
— Si dT
iX=biest une contrainte d’égalité, alors remplacer cette égalité par une paire d’inégalités :
dT
iX≥biet−dT
iX≥ −bi
— Même chose que précédemment si la variable x i≶0.
Il est facile de voir que les problèmes qui en résultent sont équivalents aux problème d’origine. Pour l’algorithme
simplexe , nous utiliserons la forme standard .
On remarque aussi qu’en utilisant la relation min f(x)= − max¡
−f(x)¢
dans laquelle f (x)représente la fonction-
nelle linéaire à optimiser, on peut toujours se ramener à un problème de minimisation (ou de maximisation).
Example 4.2
Le P .L :max 5 x+4y
s.t. x≤6
1
4x+y≤6
3x+2y≤22
x,y≥0s’écrit sous forme standard :max 5 x1+4x2
s.t. x1+e1=6
1
4x1+x2+e2=6
3x1+2x2+e3=22
x1,x2,e1,e2,e3≥0
Donc (sous la forme matricielle) on a :
cT=¡
5 4 0 0 0¢
;A=
1 0 1 0 0
1
41 0 1 0
3 2 0 0 1
;X=
x1
x2
e1
e2
e3
et b=
6
6
22

4.1 La méthode simplexe
4.1.1 Solution de base admissible
On suppose que la matrice Adu programme linéaire est de type m×netde rang m(pourquoi !). Soit Bla
matrice carrée extraite de Aformée par les mcolonnes j1,j2,..., jmlinéairement indépendants de A(les vecteurs
de base). Alors, Best une matrice inversible. Ainsi si on pose xl=0 sil∉{j1,..., jm} etxjklak-ième composante de
B−1b. Alors, on a AX B=b. Si de plus XB≥0(i.e. chaque xi≥0), alors :
Xest une solution de base admissible (ou réalisable)
Dans l’exemple 4.2, la matrice extraite B=
1 0 0
0 1 0
0 0 1
est inversible et B−1b=
6
6
22
. Donc XB=
0
0
6
6
22
≥0, par suite
XBest une solution de base admissible. On appelle les variables xjklesvariables de base . Les autres variables xl
sont les variables hors-base .
Parfois, il n’est pas évident de trouver une solution de base admissible, comme le montre l’exercice suivant :H. SABRI 29
Exercice 4.1
Écrire le programme linéaire suivant sous forme standard et montrer qu’on n’a pas une solution de base
admissible. Résoudre le programme linéaire.
max −x+y
s.t. x+y≥1,
3x+2y=6,
x,y≥0
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux
Dans cette section, on suppose qu’on a déjà trouvé une solution de base admissible X(produite avec B=Im)
du programme linéaire ( P: max z=cTX+c0etb≥0pour garantir que 0est une solution de AX≤b).
La méthode du simplexe est une méthode itérative qui génère une séquence de solutions de base réalisable
(correspondant à différentes bases) et s’arrête finalement lorsqu’elle a trouvé une solution de base réalisable opti-
male. Remarquer qu’on peut toujours prendre c0=0.
Algorithme 10 : Algorithme du simplexe
Entrées : Un P .L. standard P(max) avec une solution de base réalisable
Output : La solution optimale (ou non)
1On commence à écrire le tableau initiale (avec les variables de base xj1,..., xjm)
VB x1 ... xn b
xj1 b1
... A...
xjm bm
c1 ... cn−c0
2Sicj≤0 (∀j:xjest hors base), alors solution optimale (STOP) // min ⇝cj≥0
3Trouver la colonne s(hors base) tel que cs=max©
cj:cj>0ª// min ⇝cs=min©
cj:cj<0ª
4Siai,s≤0∀i=1... m, alors pas de solution optimale (STOP)
5Min Ratio Test : trouver la ligne rtel que
br
ar,s=min
i=1...m½bi
ai,s:ai,s>0¾
6Appliquer la procédure de Gauss autour de pivot ar,s(ar,s⇝1 et on annule les coefficients situés sous et
sur le pivot dans la colonne s, par combinaisons de lignes) // Ne pas oublier la dernière ligne
7Remplacer (dans VB) la variable de base ( sortante ) située à la ligne rpar la variable ( entrante )xs
8Retourner à l’étape 2 // l'algorithme termine si le programme linéaire est non dégénéré
Remarque 10.
— La dernière ligne représente l’équation linéaire −z+c1x1+···+ cnxn= −c0.
— La valeur de la variable de base de V Bde la ligne k est égale à la valeur b k(de la ligne k).
— La solution optimale du problème est la valeur finale (dernière cellule) (×− 1).
— Si on n’a pas au départ B =Im(à l’aide des variables d’écart) alors, on ajoute les variables artificielles (et on
applique d’abord la phase I - voir section suivante).30 Chapitre 4. Programmation linéaire
Exercice 4.2
Soit le programme linéaire :
max 2 x1+x2
s.t. x1−x2≤3,
x1+2x2≤6,
−x1+2x2≤2,
x1,x2≥0
Rajouter les variables d’écart. Puis résoudre le problème par l’algorithme du simplexe.
Remarque 11. Vérifier le résultat de l’exercice précédent, par la méthode graphique.
4.1.3 Initialisation - Phase I du simplexe
Un programme linéaire est dit sous forme simpliciale si la matrice Acontient la matrice identité Imcomme
sous matrice. On suppose que le programme linéaire P, après la mise en forme AX=b, n’est pas simpliciale
(possible dans le cas de contraintes du type ≥ou du type =). Soit Bune matrice d’ordre mextraite de Ainversible
tel que B−1b≥0et soit XBla solution de base réalisable ( XB≥0etAX B=b), alors on peut changer l’équation
matricielle :
AX B=b
⇐⇒ (B−1A)XB=B−1b
⇐⇒ A∗XB=b∗
et la matrice A∗contient la matrice identité Imcomme matrice extraite ( B−1A=B−1(H|B)=¡
B−1H|Im¢
). Ainsi, on
peut appliquer directement l’algorithme 10 en remplaçant Apar A∗etbpar b∗. Cependant, cette méthode n’est
pas efficace, car il faut trouver une matrice extraite Bréalisable correspondante. Pour une matrice Ade type m×n,
il existe¡m
n¢
matrices extraites à tester !
L ’idée est d’ajouter des variables, dites artificielles w1,w2,..., wm, pour faire apparaître une forme simpliciale
du programme linéaire P: (AX=b). Mais, il faut que w1= ··· = wm=0. Donc, il faut minimiser d’abord le pro-
gramme linéaire P0suivant :
P0=min W=w1+···+ wm
s.t. (A|Im)×(x1...xnw1...wm)T=b
x1,..., xn,w1,..., wm ≥0
On exprime Wà l’aide des autres variables (hors base) et puis on applique l’algorithme du simplexe 10 pour P0
(phase I). À la fin, si on trouve que les wi=0, alors les variables de bases xj1,..., xjmforment une première base
admissible pour démarrer le simplexe pour le programme d’origine P.H. SABRI 31
Remarque 12. On ajoute la ligne de Z :c1 ... cn−c0dans le tableau du simplexe de P0(phase I) et on lui
applique les opérations élémentaire comme avec les autres lignes. À la fin de la phase I, on supprime les colonnes des
wiet la ligne de la fonction W . Finalement, on utilise ce tableau pour résoudre le problème initiale P.
Example 4.3
Soit le programme linéaire P:
min 6 x1+3x2
s.t. x1+x2≥1,
2x1−x2≥1,
3x2≤2,
x1,x2≥0sous forme standard (max)= = = = = = = = = = = = = = = = = = ⇒max Z= −6x1−3x2
s.t. x1+x2−e1=1,
2x1−x2−e2=1,
3x2+e3=2,
x1,x2,e1,e2,e3≥0
La matrice Aest :
A=x1 x2 e1 e2 e3

1 1 −1 0 0
2−1 0 −1 0
0 3 0 0 1
est par suite Pn’est pas sous forme simpliciale (il n’ ya pas de sous matrice I3). Donc on peut ajouter 2
variables artificielles pour construire le problème initiale P0:
max −w1−w2=3x1−e1−e2−2
s.t. x1+x2−e1+w1=1,
2x1−x2−e2+w2=1,
3x2+e3=2,
x1,x2,e1,e2,e3,w1,w2≥0dont le vecteur X=

0 x1
0 x2
0 e1
0 e2
2 e3
1 w1
1 w2est une solution de base réalisable.
Ainsi, on commence notre algorithme 10 pour le programme P0. Le tableau initial est :
x1 x2 e1 e2 e3 w1 w2 b

w1 1 1 −1 0 0 1 0 1
w2 2−1 0 −1 0 0 1 1
e3 0 3 0 0 1 0 0 2
W: 3 0 −1−1 0 0 0 2
Z:−6−3 0 0 0 0 0 0
Le pivot c’est a2,1donc x1est la variable entrante et w2est sortante. On obtient après pivotement le tableau :
L2←1
2L2− − − − − − − − →
L1←L1−L2
L4←L4−3L2
L5←L5+6L2x1 x2 e1 e2 e3 w1 w2 b

w1 03
2−11
20 1−1
21
2
x1 1−1
20−1
20 01
21
2
e3 0 3 0 0 1 0 0 2
W: 03
2−11
20 0−3
21
2
Z: 0 −6 0 −3 0 0 3 3
Le pivot est a1,2(Min ratio test =1
3). On obtient alors :32 Chapitre 4. Programmation linéaire
L1←2
3L1− − − − − − − − →
L2←L2+1
2L1
L3←L3−3L1
L4←L4−3
2L1
L5←L5+6L1x1 x2 e1 e2 e3 w1 w2 b


x2 0 1−2
31
302
3−1
31
3
x1 1 0−1
3−1
301
31
32
3
e3 0 0 2 −1 1 −2 1 1
W: 0 0 0 0 0 −1−1 0
Z: 0 0 −4−1 0 4 1 5
Ainsi, la phase I se termine avec W=0 et x1=2
3,x2=1
3,e3=1 et e1=e2=w1=w2=0. Le tableau pour la
phase II est donc :
x1 x2 e1 e2 e3 b


x2 0 1−2
31
301
3
x1 1 0−1
3−1
302
3
e3 0 0 2 −1 1 1
Z: 0 0 −4−1 0 5
On remarque donc que les cj≤0, donc (STOP) la solution est optimale et le max est −5. Ainsi la solution
optimale pour le programme P=min6 x1+3x2est−(−5)=5=6×2
3+3×1
3.
4.2 Dualité
SoitPun P .L. sous forme canonique. Le programme dualDdePest définit par :
P=max z=cTX
s.t. AX ≤ b
X≥ 0le dual est= = = = = = = ⇒D=min w=bTY
s.t. ATY≥ c
Y≥ 0
Le programme Pest dit primal . On remarque que si Ade type m×n, alors X∈RnetY∈Rmpour le dual.
Théorème 4.1 Théorème de dualité
Si un problème primal ou dual admet une solution, alors l’autre problème admet aussi une solution et on a :
max z=cTX =
s.t. AX ≤ b
X≥ 0min w=bTY
s.t. ATY≥ c
Y≥ 0
Exercice 4.3
Soit le problème suivant de type régime :
D=min w=340x1+2400 x2+560x3
s.t. x1+2x2+x3≥ 1200
x1+3x2+2x3≥ 1400
x1+x2+3x3≥ 1500
x1,x2,x3≥ 0
Écrire le programme primal PdeD. Résoudre le programme Pet déduire la valeur minimale de w, a-t-on
besoin de faire les deux phases du simplexe ?
7} A B oS



HOUSSEM SABRI
Graphes et Optimisation
2`emeannée
LISI  LSI
Institut Supérieur des Sciences Appliquées et de Technologie de Sousse
A.U. 2023-2024
28 novembre 2023Table des matières
1 Les graphes 3
1.1 Définitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.1 Graphes non orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.2 Graphes orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.2 Opérations et quelques types de graphes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.3 Représentation d’un graphe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.1 Listes d’adjacences (ou de succession) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.2 Matrices d’adjacence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.3.3 Matrice d’incidence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2 La connexité 11
2.1 Les chaînes et les cycles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.2 Graphe connexe, eulérien, hamiltonien . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.3 Arbres . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.3.1 Codage et décodage d’un arbre – Prüfer code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.3.2 Arbre couvrant de poids minimum – ACM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3 Les algorithmes de base 20
3.1 Parcours en profondeur (DFS) / largeur (BFS) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
3.2 Recherche des chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.1 Matrice d’adjacence et nombre de chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.2 Plus court chemin et l’algorithme de Dijkstra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
3.3 Problèmes d’ordonnancement et chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
3.3.1 Algorithmes de tri topologique et de chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . 25
4 Programmation linéaire 27
4.1 La méthode simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.1 Solution de base admissible . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux . . . . . . . . . . . . . . . . . . . . . . . . 29
4.1.3 Initialisation - Phase I du simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
4.2 Dualité . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
2CHAPITRE 1
Les graphes
L ’exemple classique pour introduire la théorie des graphes est le problème des ponts de Königsberg, étudié par
Euler en 1736. Quel itinéraire doit-on suivre pour traverser chaque pont exactement une fois? Une telle prome-
nade n’existe pas, et c’est Euler qui donna la solution de ce problème en caractérisant les graphes que l’on appelle
aujourd’hui eulériens .
A
B
Ce1 e2
e3 e4
De5
e6e7
FIGURE 1.1 – Les ponts de Königsberg
Les graphes introduisent une simplification : les régions se transforment en des "points" (aussi appelés noeuds
ousommet ), les ponts se transforment en des lignes (aussi appelées arêtes ouarcs ), et ce principe s’applique dès
lors qu’une relation existe entre des objets. Les graphes relèvent de la combinatoire plutôt que de la géométrie (les
intersections, les longueurs, et la forme des arêtes n’ont aucune importance, sauf en ce qui concerne la lisibilité de
la représentation).
1.1 Définitions
Dans la suite, il est toujours supposé que les graphes sont finis, sauf indication contraire.
1.1.1 Graphes non orientés
Définition 1.1: Graphe
Un graphe Gest un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V{2}des pairs non ordon-
nées de V.Vest l’ensemble des noeuds (Vertices en anglais) et Ec’est l’ensemble des arêtes de G(Edges en
anglais). Lorsque e={x,y} est une arête, on dit que x, y sont les extrémités de cette arête, que eest incidente
enxet en y. On joint x et y par un trait et on dit que x, y sont adjacents (ou voisins). On note aussi e=x you
encore e=(x,y) (attention , dans ce cas : ( x,y)=(y,x)).
SiGest un graphe alors, on note par V(G) l’ensemble de noeuds et par E(G) l’ensemble des arcs.
Remarque 1.
— Une arête e ={x,x}s’appelle boucle .
— Dans un graphe, il peut exister des arêtes parallèles (on parle donc de multigraphe ).
Dans l’exemple des ponts on a : e 1=e2=(A,B).
34 Chapitre 1. Les graphes
— Un graphe est dit simple s’il ne comporte ni arêtes multiples ni de boucles, c’est-à-dire chaque paire de nœuds
distincts est reliée par au plus une arête, ou encore E (G)⊆P2(G).
Dans la plupart des cas, les graphes sont considérés comme simples par défaut.
Définition 1.2: ordre – taille – degré
Soit G=(V,E) un graphe.
1. On appelle ordre d’un graphe noté v(G) le nombre de ses sommets :
v(G)= |V|
2. On appelle taille d’un graphe noté e(G) le nombre de ses arêtes :
e(G)= |E|
3. Le degré (ou valence) d’un sommet xnoté d(x) est le nombre d’arêtes contenant x. (Attention! Une
boucle sur un sommet compte double).
Si on note par Γ(x) l’ensemble des voisins de x, i.e.
Γ(x)={y∈V:x y∈E}
alors, siGest simple , on a :
d(x)= |Γ(x)|
Example 1.1 (Graphe complet)
Un graphe d’ordre nest dit complet noté Knsi chaque sommet du graphe est relié directement à tous les
autres sommets, i.e. E(Kn)=P2(V(Kn)).
Représenter graphiquement K3,K4,k5. Calculer la taille de K3,k4,...Kn.
Example 1.2 (Graphe biparti)
Un graphe G=(V,E) est dit biparti si son ensemble de sommets V=V1˙∪V2, i.e. peut être divisé en deux
sous-ensembles disjoints V1etV2tels que chaque arête ait une extrémité dans V1et l’autre dans V2.
Si∀x∈V1,∀y∈V2;x y∈E, alors Gest dit biparti complet noté Kn,moùn= |V1|etm= |V2|.
a1
 a2
 a3
 a4
b1
 b2
 b3
FIGURE 1.2 – Un graphe biparti
Théorème 1.1 Lemme des poignées de main – Handshaking lemma
Soit Gun graphe alors, on a :X
x∈V(G)d(x)=2e(G)
Dans ce théorème d(x) est le nombre de personnes à qui xserre la main et e(G) le nombre total de poignées
de mains.H. SABRI 5
Preuve.
•Méthode simple Il y en a d(x) arêtes en un sommet xfixé. Pour tout les sommets cela fait doncP
x∈V(G)d(x).
Mais avec cette manière chaque arête est comptée deux fois, une fois à chacune de ses extrémités, d’où le
résultat en divisant par 2.
•Preuve par double dénombrement On pose
Z={(x,e)∈V×E:x∈e}⊆V×E
et les deux projections :
p:Z→V
(x,e)7→xet q:Z→E
(x,e)7→e
L ’idée est de calculer |Z|de deux manières différentes. D’abord, on rappelle que si f:A→Best une fonction
quelconque, alors :X
b∈B|f−1[b]| = | A|
oùf−1[b] désigne l’image réciproque de { b} par f(pourquoi ˙S
b∈Bf−1[b] est une union disjointe ?).
Ainsi on obtient :
|Z| =X
x∈V|p−1[x]| =X
e∈E|q−1[e]|
Or,|p−1[x]| =d(x) et|q−1[e]| = |{x∈V:x∈e}| =2. Donc :
X
x∈Vd(x)=X
e∈E2=2|E|
Remarque 2.
— Un sommet de degré 0est appelé sommet isolé .
— Un graphe tel que : ∀x∈V,d(x)=kest dit graphe k-régulier .
— Le graphe complet K nest un graphe (n−1)-régulier .
Exercice 1.1
Montrer que dans un graphe le nombre de sommets d’ordre impairs est toujours pair. En particulier un
graphe k-régulier avec kimpaire est un graphe d’ordre pair.
Voici quelques exemples comme application :
1. Est-il possible de relier 15 ordinateurs en réseau de sorte que chacun soit relié à exactement 3 autres ?
2. Une ligue de football comprenant 11 clubs organise un tournoi. Pour gagner du temps on décide que chaque
équipe ne jouera que la moitié des matches possibles. Comment organiser le tournoi ?
Proposition 1.1
Soit G=(V,E) un graphe (simple) d’ordre n≥2. Alors :
∃u,v∈V,u̸=v:d(u)=d(v)
Preuve. Supposons le contraire, c’est-à-dire ∀u,v∈V;d(u)̸=d(v). Or dans un graphe (simple) on a toujours d(x)∈
{0,1,..., n−1}. Dans ce cas, puisque tous les nsommets ont des degrés distincts, alors il existe une bijection
{d(x):x∈V}←→ {0,1,..., n−1}
Donc, il existe un sommet uavec un degré 0, et un sommet vavec degré n−1, donc vest connecté à tous les autres
sommets du graphe, ce qui signifie que une peut pas être un sommet isolé, d’où une contradiction.6 Chapitre 1. Les graphes
1.1.2 Graphes orientés
Les arêtes d’un graphe peuvent être orientées, auquel cas une flèche indique la direction. De tels graphes sont
appelés des graphes orientés ou des digraphes , et une arête ( a,b) dans un tel graphe indique que cette arête est
dirigée de sommet avers b, i.e. ( a,b)=− →ab̸=(b,a)=− →ba. D’où la définition :
Définition 1.3: Graphe orienté - digraphe
Un graphe orienté G(ou− →G) est un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V2des pairs
ordonnées de V.Eest l’ensemble des arêtes (ou flèches, arcs) de G. Lorsque e=(x,y) est une arête, on dit
que xestl’origine (ou sommet initiale) et yl’extrémité (ou sommet terminale) de e, que eest sortant en x
et incident en y, et que yest un successeur de xtandis que xest un prédécesseur de y. On note l’arête e
par :
e=(x,y)=− →x y=x→y
De la même façon, une arête x→xest une boucle. On peut toujours supprimer les boucles pour obtenir des
digraphes simples. Voici l’exemple d’un digraphe G=(V,E) d’une fonction f:E→Eoù ( x,y) est un arc si et seule-
ment si y=f(x). On l’appelle digraphe fonctionnelle.
0
3
1214
11 568
169
4
2 1
713 10
15
FIGURE 1.3 – Le digraphe fonctionnelle Gfdex7→(x2+3) mod 17.
Comme dans les graphes on peut définir les degrés (entrant, sortant) d’un sommet dans un digraphe.
Définition 1.4: indegree - outdegree
Soit G=(V,E) un digraphe. Pour v∈V, on note par :
d+(v) le degré extérieur (sortant - outdegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité initiale.
d+(v)= |{v→ •}|
d−(v) le degré intérieur (entrant - indegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité finale.
d−(v)= |{• → v}|
On définit le degré : d(v)=d−(v)+d+(v).
Un sommet de degré entrant non nul et de degré sortant nul est appelé puits , tandis qu’un sommet de
degré entrant nul et de degré sortant non nul est appelé source ouracine .
Dans un graphe orienté, les voisins d’un sommet vsont soit des successeurs ou des prédécesseurs. On les notes
par :
Γ+(x)=Succ (x)={y∈V:x→y∈E} et Γ−(x)=Pr ed (x)={y∈V:y→x∈E}H. SABRI 7
Si le digraphe est simple (ni boucle ni arcs parallèles) on a :
d−(v)= |Γ−(v)|et d+(v)= |Γ+(v)|
Proposition 1.2
Soit Gun digraphe, alors :X
v∈Vd−(v)=X
v∈Vd+(v)= |E|
Preuve. On a
E=˙[
v∈V{• → v}=˙[
v∈V{v→ •}
=⇒ | E| =X
v∈V|{• → v}| =X
v∈V|{v→ •}| =⇒ | E| =X
v∈Vd−(v)=X
v∈Vd+(v)
1.2 Opérations et quelques types de graphes
Une opération sur les graphes permet de construire un nouveau graphe comme résultat de l’opération. Les
opérations courantes sur les graphes sont la suppression, la valuation, l’union, l’intersection et le produit cartésien.
Graphe valué
Tout d’abord, on peut vouloir attribuer des valeurs aux arcs ou arêtes pour tenir compte de contraintes : dis-
tance, coût ...
Définition 1.5: (di)graphe valué
Un (di)graphe valué G=(V,E,w) est un (di)graphe muni d’une application w:E→R. L ’application west
appelée application poids ou coût. On indique sur chaque arête son poids (ou son coût). On note w(x,y)
au lieu de w((x,y)). On convient (même que ceci n’a pas de sens!) que w(x,y)= +∞ si (x,y)∉E.
ab
c
d
ef53
43
3
335
81
FIGURE 1.4 – Un digraphe valué
/pythonPython code : -
Implémenter le digraphe valué précédent avec python. Indice – use chatGPT : how to build a weighted digraph with
python8 Chapitre 1. Les graphes
Sous graphes
Soit G=(V,E) un graphe (orienté ou non). Un sous graphe de Gest un graphe de la forme G′=(V′,E′) où
V′⊆V,E′⊆Etels que toute arête de E′a ses extrémités dans V′(ou encore G′est aussi un graphe). On a :
•Sous-graphe induit Un sous-graphe G′=(V′,E′) de G=(V,E) est appelé un sous-graphe induit deGsi :
∀x,y∈V′; (x,y)∈E′⇐⇒ (x,y)∈E
En d’autres termes, deux sommets de G′qui sont connectés dans G, sont également connectés dans G′.
•Sous-graphe couvrant Un sous-graphe couvrant G′deGcontient tous les sommets de G, i.e. V′=V.
•G−vSupprimer un sommet vd’un graphe Gconsiste à supprimer vet toutes ses arêtes incidentes. Le sous-
graphe obtenu de cette opération est noté G−v, i.e.
V′=V−{v} et E′=E−{(v,y): (v,y)∈E}
De manière similaire, une arête epeut être supprimée (resp. ajoutée) d’un graphe G, et le sous-graphe
résultant est représenté par G−e(resp. G+e). Notez que la suppression d’une arête ne retire pas de sommets
du graphe.
•G−V′=G[V′] On supprimer tous les sommets v∈V′du graphe Gavec les arêtes incidentes. Le sous-graphe
obtenu de cette opération est noté G[V′], i.e.
V(G[V′])=V−V′et E(G[V′])=E−{(v,y)∈E:v∈V′}
•Clique Une clique Cd’un graphe Gest un sous-ensemble des sommets de Gdont le sous-graphe induit G′=
(C,E′) est un graphe complet, en d’autres termes, deux sommets quelconques de la clique Csont toujours
adjacents.
•Stable Un stable – appelé aussi ensemble indépendant (independent set en anglais) est un ensemble de som-
mets deux à deux non adjacents. Donc le sous-graphe induit est sans arcs.
FIGURE 1.5 – L ’ensemble des sommets en bleu dans ce graphe est un stable maximal du graphe.
Note : -
Le problème décisionnel de la clique (c’est à dire existe t-il une clique de taille k) est NP-complet . De même la
recherche d’un stable de taille maximum dans un graphe est un problème NP-complet et difficile à approximer.
Exercice 1.2
Trouver un plus grand stable et une plus grande clique du graphe suivant :
8
4
62 7
3
1 5
Indice : vérifier le résultat avec networkx.find_cliques(G) et.maximum_independent_set(G) de python.H. SABRI 9
Opérations binaires
Union L ’union de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∪H=(VF,EF) dans lequel
VF=VG∪VH et EF=EG∪EH
Intersection L ’intersection de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∩H=(VF,EF)
dans lequel
VF=VG∩VH et EF=EG∩EH
1.3 Représentation d’un graphe
Il est important de savoir comment représenter les graphes au sein d’un ordinateur. Il ya plusieurs méthodes
selon la nature des traitements que l’on souhaite appliquer au graphe considéré.
1.3.1 Listes d’adjacences (ou de succession)
Soit Gun (di)graphe. On suppose que les sommets de Gsont numérotés de S1àSn. La représentation par listes
d’adjacence de Gconsiste en un tableau (ou des listes chainées) tel que la ligne i=1... ncorrespond au sommet Si
et comporte la liste des voisins/successeurs (ou des prédécesseurs) de ce sommet notée T[Si]. Les sommets dans
chaque liste d’adjacence sont généralement listés selon un ordre arbitraire.
1
2
345
FIGURE 1.6 – Un digraphe
La liste d’adjacence de digraphe 1.6 est donc :
1 2 3 4 5
2 3
3 4
4−
5 1 410 Chapitre 1. Les graphes
1.3.2 Matrices d’adjacence
Définition 1.6: Mat. Adjacence
Soit G=(V,E) un graphe (orienté) d’ordre n. On peut numéroter V={1,2,..., n}.La matrice d’adjacence
deGest la matrice carrée A=(ai j) d’ordre n, définie par :
ai j=(
1 si ( i j)∈E;
0 sinon.
Remarque 3.
1. Si le graphe G est non orienté et simple, alors la matrice A est symétrique avec des 0sur la diagonale. Pour un
digraphe simple, on a toujours des 0sur la diagonale, mais la matrice n’est pas symétrique en général.
2. Pour les multigraphes, il peut y avoir des termes diagonaux (pour les boucles) et s’il y a plusieurs arêtes de i à
j , le coefficient de la matrice a i jest le nombre d’arêtes de i à j .
3. Pour un (di)graphe valué G =(V,E,w), on pose :
ai j=(
w(i,j)si(i j)∈E ;
∞ sinon.
La matrice d’adjacence de la figure 1.4 est :

∞ 5∞ 4 3 ∞
∞ ∞ 3∞ 1∞
∞ ∞ ∞ ∞ ∞ 5
∞ ∞ 3∞ 3 3
∞ ∞ ∞ ∞ ∞ 8
∞ ∞ ∞ ∞ ∞ ∞

1.3.3 Matrice d’incidence
Définition 1.7: Mat. Incidence
Soit G=(V,E) un graphe (simple) d’ordre net de taille m. On pose V={v1,v2,..., vn} etE={e1,e2,..., em}.
La matrice d’incidence deGest la matrice de type n×m B=(bi j), définie par :
•Si G orienté
bi j=

1 si ej=vi→ • (i.e. viest l’extrémité initiale de ej) ;
−1 si ej= • → vi(i.e. viest l’extrémité terminale de ej) ;
0 sinon.
•Si G non-orienté
bi j=(
1 si viest une extrémité de ej;
0 sinon.
Exercice 1.3
1. Donner la matrice d’incidence du graphe 1.6.
2. Montrer le théorème 1.1 avec la matrice d’incidence.CHAPITRE 2
La connexité
Il est important de savoir si on peut suivre un chemin d’un sommet donné à un autre dans un graphe donné.
Cette propriété (de connexité) doit être maintenue dans différents types de réseaux.
2.1 Les chaînes et les cycles
Définition 2.1: (chaine – cycle) (chemin – circuit)
•Graphe non orienté
1. Une chaîne (walk ) reliant xày, notée µ(x,y), est définie par une suite finie d’arêtes consécutives,
reliant xày, ou encore une séquence de sommets (puisque non multigraphe)
µ(x,y)=<v0,v1,..., vk>
tels que v0=x,vk=yet (vi−1,vi)∈E(G) pour tout i=1... k. Six=yla chaîne est dite fermée .
Lalongueur du chaîne l(µ(x,y)) est le nombre d’arcs dans la chaîne, c’est-à-dire k.
2. Une chaîne élémentaire (a path ) si tous les sommets sont distincts. Une chaîne simple (a simple
walk, a trail ) est une chaîne ne passant pas deux fois par une même arête, c’est-à-dire dont toutes
les arêtes sont distinctes. Remarquer que : élémentaire =⇒ simple.
3. Un cycle v0v1...vnde longueur n≥3 est une chaîne simple fermée ( v0=vn) tel que les sommets
v0,v1,..., vn−1sont tous distincts. Un graphe sans cycle est dit acyclique .
•Graphe orienté
Dans un graphe orienté, on parlera de chemin au lieu de chaîne, et de circuit au lieu de cycle.
Example 2.1
abxcd xa est une chaîne simple et fermée (non cycle!) de longueur 6 (mais, c’est un graphe eulérien - voir
plus loin). Y a-t-il un cycle de longueur 3,4 ?
a b
x
c dÏ
Remarque 4.
1. On peut pivoter une chaine fermée (l’orienter de manière arbitraire) , i.e.
<v0,v1,v2,..., v0>=< vk,vk+1,..., v0,v1,..., vk>
1112 Chapitre 2. La connexité
2. Soient x ,y∈V . La distance de x à y est définie par :
d(x,y)=(
k si le plus court chemin/chaîne de x vers y est de longueur k
∞ sinon
On convient que d (x,x)=0.
3. Le diamètre du graphe la plus grande distance entre deux sommets.
L ’observation suivante, bien que très facile à prouver, sera utile.
Théorème 2.1
S’il existe une chaîne du sommet yau sommet zdans le graphe G, où y̸=z, alors il existe une chaîne élé-
mentaire ( path ) dans Gavec pour premier sommet yet pour dernier sommet z.
Preuve. Soit la chaine
W1=µ(y,z)=x0x1...xn; avec x0=yetxn=z.
Si les sommets x0,x1,..., xnsont tous distincts, alors W1est une chaîne élémentaire, et nous avons terminé. Sinon,
il existe xi=xj(i<j) et on écrit :
W2=x0x1...xixj+1...xn.
Alors, l(W2)<l(W1). Si W2ne contient aucun sommet répété, alors c’est la chaîne recherché. Sinon, par la même
procédure, il existe W3(y z−chaîne) tel que
l(W3)<l(W2)<l(W1).
Ce processus doit s’arrêter à un certain stade, car chaque chaîne est plus courte que la précédente et la longueur
ne peut jamais être inférieure à 1
1< ··· < l(Wk)< ··· < l(W3)<l(W2)<l(W1).
Ainsi, pour un certain k,Wkne peut pas être réduit en longueur. Donc, la chaîne Wkne contient aucun sommet
répété et est donc une y z−chaîne élémentaire (path).
Exercice 2.1
Dans le graphe suivant, construire un path à partir de la chaîne W=v2v3v4v5v6v4v2v8v1
v1
 v2
v3
v4
v5
v6
v7
 v8
 v9
Calculer d(v1,v7) et le diamètre de G.
/pythonpython : >>G = nx.Graph([(1, 2), (2, 3), (2, 4), ...]) >>nx.diameter(G)
Les cycles fournissent la caractérisation suivante pour les graphes bipartis .H. SABRI 13
Théorème 2.2
Un graphe est biparti si et seulement s’il ne contient aucun cycle de longueur impaire.
Preuve.
⇒On suppose que G=U˙∪Vest un graphe biparti. Soit W=< x1,x2,..., x2k+1,x1>un cycle de longueur im-
paire (2 k+1). Si x1∈U, alors
x1∈U=⇒ x2∈V=⇒ x3∈U=⇒ ··· =⇒ x2k+1∈U=⇒ x1∈V/exclamati⌢n-triangle
absurde, d’où le résultat.
⇐On suppose que Gest connexe (car l’union des composantes connexes bipartis est un graphe biparti). Soit
xun sommet de Get on pose :
U={y∈V(G):d(x,y) est paire} et V={z∈V(G):d(x,z) est impaire}
S’il existe y1,y2∈Utel que y1y2∈E(G), alors on a :
W1=<x,..., y1>est une chaîne de longueur paire =2k1
W2=<x,..., y2>est une chaîne de longueur paire =2k2
=⇒ W3=<x,..., y1,y2,..., x>est un cycle de longueur impaire =2k1+2k2+1/exclamati⌢n-triangle
Donc G=U˙∪Vest un graphe biparti.
Exercice 2.2
Vérifier si le graphe maison est un graphe biparti. Faire de même pour la grille G4,4.
maison grille
2.2 Graphe connexe, eulérien, hamiltonien
Définition 2.2: Graphe connexe
Un graphe est dit connexe si deux points peuvent toujours être joints par une chaîne, i.e.
∀x,y∈V(G),d(x,y)< ∞
— Une composante connexe d’un graphe est un sous-graphe induit maximal connexe.
— Un point d’articulation d’un graphe est un sommet dont la suppression augmente le nombre de
composantes connexes.
Par exemple, le graphe suivant :14 Chapitre 2. La connexité
a
 b
d
 c
e
f
 g
n’est pas connexe car il n’existe pas de chaîne entre les sommets aete. On a donc 2 composantes connexes. En
revanche, le sous-graphe induit par les sommets { a,b,c,d} est connexe dont aest le seul point d’articulation.
Remarque 5.
1. Un graphe connexe à n sommets possède au moins n −1arêtes ( faite une preuve par récurrence ).
2. L’algorithme de parcours en profondeur permet de déterminer si un graphe est connexe ou non.
3. Même définitions dans un graphe orienté . Graphe orienté (fortement) connexe et de composante connexe .
Définition 2.3: Graphe eulérien
— Une chaîne joignant deux sommets xetyest dite chaîne eulérienne si elle emprunte chaque arête
deGune et une seule fois. On parle de chemin eulérien dans le cas d’un graphe orienté.
— Un cycle eulérien est une chaîne eulérienne dont les extrémités coïncident. Un graphe qui admet
un cycle (resp. circuit) eulérien est dit graphe eulérien .
/flushedRemarquer qu’un cycle eulérien n’est pas forcément un cycle comme définit dans la définition 2.1
Si un graphe (ou multigraphe) Gpossède une chaîne eulérienne, alors soit Gpossède deux sommets impairs, le
début et la fin de cette chaîne, soit Gn’a aucun sommet impair, et la promenade d’Euler commence et se termine
au même point (cycle eulérien). Une autre condition nécessaire évidente est que Gdoit être connexe. Ces deux
conditions sont ensemble suffisantes.
Théorème 2.3 Euler
Soit Gun graphe (multigraphe) connexe.
— Si Gn’a pas de sommets impairs, alors il possède un cycle eulérien (commençant à n’importe quel
point).
i.e.∀x,d(x)≡0 mod 2 =⇒ Gest un graphe eulérien.
— Si Ga deux sommets impairs, alors il possède une chaîne eulérienne dont le début et la fin sont les
sommets impairs.
La réciproque est aussi vraie.
Preuve.
⇐On commence par la réciproque. S’il existe une chaîne eulérienne µ(x,y), alors on peut crée une arête fictive
e=(y,x) et par la suite on obtient un cycle eulérien. Donc il suffit de montrer que si Gadmet un cycle
eulérien alors tous les sommets sont de degré pair.
Soit W=< v1,v2,..., vn,v1>un cycle eulérien. Soit le sommet vjavec j̸=1, il est donc claire que chaque
fois vjapparaît dans W, il ya deux arcs distincts incidents en vj( (•,vj) et ( vj,•)). Comme toutes les arêtes
sont utilisées, on voit que d(vj) est pair. Même chose pour v1car on ajoute deux arcs ( v1,v2) et ( v1,vn).
⇒On suppose que tous les sommets sont de degré pair. Montrons que Gadmet un cycle eulérien. Puisque
tous les sommets sont de degré pair on peut construire d’abord une chaîne simple fermée (quelconque)
W1=<v1,v2,..., vk,v1>
SiW1contient chaque arête de G, alors c’est finis, c’est un cycle eulérien. Sinon (puisque Gest connexe), il
existe une arête e=(vi,c) qui n’est pas dans W1(avec visommet de W1). On pose le sous-graphe
G′=G−{ arêtes de W1}H. SABRI 15
Il est donc claire que les sommets de G′sont aussi de degré pair. Alors, par la même procédure on construit
une chaîne simple fermée dans G′de la forme : <vi,c,d,..., vi>et par la suite on insère cette chaîne dans
W1pour obtenir :
W2=<v1,v2,..., vi,c,d,..., vi,vi+1,..., vk,v1>
Sil(W2)< |E(G)|, on construit W3de longueur plus grand. Ainsi, on a :
l(W1)<l(W2)<l(W3)< ··· ≤ | E(G)|
Donc, nécessairement, il existe Wk(chaîne simple fermée de longueur |E(G)|) donc c’est un cycle eulérien.
Finalement , si∃a,b∈V(G):d(a)≡d(b)≡1 mod 2, et tous les autres sommets sont de degré pair, alors on
pose :
G′=G+{a,b}
et donc tous les sommets de G′sont de degré pair. Avec la construction précédente, il existe un cycle eulérien
dans G′:
W=<a,b,v1,..., a>
est donc la chaîne <b,v2,..., a>est une chaîne eulérienne dans G.
Algorithme 1 : Euler
Entrées : Gun graphe eulérien
Output : Un cycle eulérien W
/* On suppose que G est eulérien, i.e. les sommets sont de degré pair */
1Gaux←G;W←µ(v,v) une chaîne simple (quelconque) de G; // Initialisation
2tant que l(W)<e(G)faire
3 Gaux←G−{ arêtes de W} ;
4 Choisir ( x,c)∈E(Gaux) tel que x∈W;
5 L←< x,c,..., x>une chaîne simple de Gaux ;
6 Dans W, remplacer (juste ce) xpar la séquence L;
7fin
8retourner W;
Exercice 2.3
1. Montrer que le graphe de l’exercice 2.1 est un graphe eulérien et donner un cycle eulérien.
2. Tracer cette maison d’un seul trait.
Remarque 6. Le théorème d’Euler dans un graphe orienté connexe s’écrit :
Admet un circuit eulérien si, et seulement si, pour tout sommet, le degré entrant est égal au degré sortant.
∀v∈V(G),d+(v)=d−(v)
Admet un chemin eulérien de a vers b si, et seulement si,


d+(v)=d−(v) ;∀v̸=a,b,
d−(a)=d+(a)−1
d−(b)=d+(b)+116 Chapitre 2. La connexité
Définition 2.4: Graphe hamiltonien
Soit Gun graphe connexe d’ordre n. On appelle :
1. On appelle cycle hamiltonien deGun cycle passant (une et une seule fois) par chacun des sommets
deG. Un graphe est dit hamiltonien s’il possède un cycle hamiltonien.
2. Une chaîne hamiltonienne est une chaîne passant une et une seule fois par chacun des sommets de
G. Un graphe ne possédant que des chaînes hamiltoniennes est semi-hamiltonien .
3. Dans un digraphe, on change cycle par circuit et chaîne par chemin .
Remarque 7.
— Une chaîne hamiltonienne est une chaîne élémentaire de longueur n −1.
— Un graphe peut être eulérien, hamiltonien, les deux à la fois, ou aucun des deux.
— De nombreux problèmes concrets peuvent être formulés en termes de recherche de parcours hamiltoniens : pro-
blème du voyageur de commerce (chercher un cycle hamiltonien de longueur totale minimale), l’ ordonancement
de tâches .
— Le problème du chaîne hamiltonienne est un problème NP-complet .
Exercice 2.4
Donner un graphe (connexe, simple) qui soit :
1. hamiltonien et eulérien.
2. hamiltonien et non eulérien.
3. eulérien et non hamiltonien.
4. non hamiltonien et non eulérien.
Aucune condition nécessaire et suffisante adéquate n’est connue pour l’existence de cycles hamiltoniens. Le
résultat suivant constitue une condition suffisante utile.
Théorème 2.4 Ore
Soit Gun graphe simple d’ordre n≥3. Si pour toute paire { x,y} de sommets non adjacents, on a d(x)+d(y)≥
n, alors Gest hamiltonien.
Preuve. On suppose que le théorème est faux. Alors, il existe un graphe Gsimple d’ordre nnon hamiltonien tel que
d(u)+d(v)≥npour tout sommets non adjacents uetv. On prend Gun tel graphe d’ordre nde taille maximale qui
vérifie cette propriété (remarquer que le graphe complet Knest hamiltonien).
Soient uetvdeux sommets non adjacents de G. Par maximalité de G, le graphe G+uv(d’ordre n) doit être
hamiltonien. Donc il existe dans G+uvun cycle hamiltonien :
W=<u,x1,x2,..., xn−2,v,u>
u
x1
xi xi+1xn−2
v
... ...
Or, si uxi+1∈E(G) etv xi∈E(G) (les arcs en rouge), alors on peut construire dans Gle cycle hamiltonien :
<u,x1,x2,..., xi,v,xn−2,..., xi+1,u>H. SABRI 17
Ceci est absurde car Gest non hamiltonien. Donc si xi+1est un sommet voisin à u, alors le sommet xin’est pas
voisin de v:
xi+1∈Γ(u)=⇒ xi∉Γ(v)
Donc :
d(u)= |Γ(u)| =p=⇒ d(v)≤(n−1)−p
et par la suite
d(u)+d(v)≤n−1
ce qui absurde par hypothèse. Donc Gest hamiltonien.
Une conséquence immédiate est le théorème de Dirac :
Proposition 2.1 Dirac
Soit Gun graphe simple d’ordre n≥3. Si pour tout sommet xdeG, on a d(x)≥n
2, alors Gest hamiltonien.
2.3 Arbres
Définition 2.5: Arbres et forêts
On appelle arbre tout graphe (non orienté) connexe et acyclique . Les composantes connexes dans un
graphe acyclique sont des arbres et le graphe est dit forêt . Une feuille ou sommet pendant est un som-
met de degré 1.
Un forêt avec deux arbres
Un graphe Gest une arborescence s’il existe un sommet Rappelé racine deGtel que, pour tout sommet
SdeG, il existe un chemin et un seul de Rvers S. Donc, c’est un arbre orienté dans lequel on choisit un
sommet Rcomme racine et on dirige les arcs vers le sens sortant de la racine.
Remarque 8.
— Un graphe G d’ordre n est un arbre ssi G est sans cycle et possède n −1arêtes.
— Un graphe G d’ordre n est un arbre ssi G est connexe et possède n −1arêtes.
— G est un arbre si pour chaque paire u ,v de sommets distincts est reliée par une seule chaîne (donc chaîne
élémentaire d’après le théorème 2.1).
— Un arbre (ou forêt) est nécessairement un graphe simple.
Pour démontrer les remarques précédentes, il suffit de prouver le théorème suivant :
Théorème 2.5
Soit Gun graphe ayant marêtes, nsommets et pcomposantes connexes, on définit nu( G) :
ν(G)=m−n+p
Alors, on a :
1.ν(G)≥0.
2.ν(G)=0⇐⇒ Gest acyclique.18 Chapitre 2. La connexité
Preuve. Par récurrence sur la taille mdu graphe. Le résultat est évident pour m=0 et m=1. On suppose le résultat
est vrai pour les graphe de taille m, et montrons que ceci est vrai pour un graphe de taille m+1. Soit donc Gun
graphe d’ordre nde taille m+1 ayant pcomposantes connexes.
•On suppose que Gest un graphe acyclique. Soit uvune arête de Gdans la composante C. Si on supprime uv,
la composante Cse transforme en deux composantes connexes (sinon on a un cycle dans G). Par la suite,
le graphe G′=G−uvest un graphe acyclique d’ordre n, de taille met ayant p+1 composantes connexes.
Donc d’après l’hypothèse de récurrence :
ν(G′)=0=(m−1)−n+(p+1)=m−n+p=ν(G)
•Maintenant, si Gcontient un cycle Wdans la composante connexe C. Soit uvune arête de W, alors si on
supprime l’arête uv, la composante Creste connexe. Donc le graphe G′=G−uvest un graphe d’ordre nde
taille m−1 ayant pcomposantes connexes. Donc, d’après l’hypothèse de récurrence :
ν(G′)=(m−1)−n−p≥0
=⇒ν(G)=m−n−p≥1>0
D’où le résultat – car si ν(G)=0,Gne peut être que acyclique, sinon 0 =ν(G)≥1/exclamati⌢n-triangle
2.3.1 Codage et décodage d’un arbre – Prüfer code
Soit Tun arbre ayant nsommet numérotés {1,2,..., n}. Le codage de Prüfer représente l’arbre Tarbre de avec
une suite P=(x1,x2,x3,..., xn−2) de n−2 termes (les n° des sommets avec répétition possible). Une suite Pdonnée
correspond à un et un seul arbre numéroté. Voici les algorithmes de codage et de décodage.
Algorithme 2 : Codage de Prüfer
Entrées : Un arbre T
Output : Séquence de Prüfer P
1P←() ; // Initialisation de P comme séquence vide
2tant que v(T)>2faire
3 x←feuille de Tayant le n° minimum ; // donc d(x)=1
4 P←(P,s) où sest le seul (n°) sommet adjacent à x;
5 T←T−x;
6fin
7retourner P;
Example 2.2
Donner le code de Prüfer de l’arbre :
126 345
Indice : on trouve, P=(2,3,3,2)
Pour faire la réciproque, étant donnée une séquence P=(x1,x2,..., xn−2) où les xi∈{1,2,..., n}, on construit
l’arbre Tdont les sommets sont {1,2,..., n} avec l’algorithme suivant (le décodage) :H. SABRI 19
Algorithme 3 : Décodage de Prüfer
Entrées : Une séquence Pde taille n−2
Output : L ’arbre Tcorrespondante
1I←{1,2,..., n};
2T←graphe tel que V(T)=IetE(T)= ; ; // T graphe à n sommets isolés
3tant que P̸=()faire
4 i←min {x∈I:x∉P};
5 T←T+(i,P[1]) ; // ajouter l'arc (i,P[1])
6 P←P−P[1];I←I−{i};
7fin
8T←T+(a,b) ; // a,b sont les deux éléments restant dans I
9retourner T;
Example 2.3
Donner l’arbre dont le code de Prüfer est : P=(2,3,3,3)
Puisqu’il ya une bijection entre les arbres d’ordre net les suites Pde longueur n−2 à coefficients dans {1,2,..., n},
on déduit le théorème de Cayley :
Théorème 2.6 Formule de Cayley
Le nombre d’arbres que l’on peut construire sur n(n≥2) sommets numérotés est égal à nn−2.
2.3.2 Arbre couvrant de poids minimum – ACM
Soit Gun graphe (non orienté). Un arbre couvrant (spanning tree) TdeGest un sous graphe couvrant de G
tel que Test un arbre. Remarquer que, Gdoit être connexe, sinon un arbre couvrant de Gn’existe pas. Le nombre
des arbres couvrant de Gest noté a(G). Remarquer que a(Kn)=nn−2(le nombre de Cayley). Un problème algo-
rithmique classique est de trouver, dans un graphe valué , un arbre couvrant de poids minimal . On dispose de
plusieurs algorithmes (l’algorithme de Prim, l’algorithme de Kruskal ...).
Algorithme 4 : Kruskal
Entrées : Un graphe Gvalué d’ordre net de taille m
Output : Arbre (ou forêt) couvrant de poids minimum
1Numéroter les arêtes de Gpar poids minimum : w(e1)≤w(e2)≤ ··· ≤ w(em)
2T←graphe tel que V(T)=V(G) etE(T)= ; ; // T graphe à n sommets isolés
3k←0;
4tant que k<m et e (T)<n−1faire
5 siT+ek+1est acyclique alors
6 T←T+ek+1;
7 k←k+1;
8fin
9retourner T;
Appliquer l’algorithme de Kruskal dans le graphe suivant :
CHAPITRE 3
Les algorithmes de base
Beaucoup de problèmes sur les graphes nécessitent que l’on parcourt l’ensemble des sommets et des arcs. Par
exemple, pour vérifier que le graphe est connexe, chercher un sommet particulier, construire un arbre couvrant,
trouver un plus court chemin ...etc.
3.1 Parcours en profondeur (DFS) / largeur (BFS)
Une manière simple de tester si un graphe Gest connexe ou non est d’exécuter l’algorithme DFS ouBFS dans
Gen commençant par n’importe quel sommet et en enregistrant les sommets visités pendant l’exécution dans une
liste. Si la liste contient tous les sommets de G, alors Gest connexe. Une petite modification permet de donner les
composantes connexes de G. L ’algorithme DFS_Component suivant donne les composantes connexes de G. Il est
donné sous forme d’implémentation récursive.
Algorithme 5 : DFS_Component
Entrées : Un graphe G=(V,E)
Output : Les composantes connexes C=(C1,C2,..., Ck) de G.
1VisitedNodes ← ; ;
2k←0 ; // k est le nombre des composantes connexes
3pour chaque u∈Vfaire
4 siu∉VisitedNodes alors
5 k←k+1;
6 DFS( u);
7 fin
8fin
9retourner (C1,C2,..., Ck);
1Procedure DFS( u )
2 VisitedNodes ←VisitedNodes ∪{u};
3 Ck←Ck∪{u};
4 pour chaque x∈Γ(u)faire
5 six∉VisitedNodes alors
6 DFS( x);
7 fin
8 fin
Note : -
Il est possible de d’implémenter la procédure DFS itérativement à l’aide d’une pile LIFO (stack) contenant les
sommets à explorer : on désempile un sommet et on empile ses voisins non encore explorés.
20H. SABRI 21
Pseudocode :
stack . push ( root )
while stack . isEmpty ( ) = f a l s e do
node = stack . pop ( ) // so mark i t as v i s i t e d
for each x in node . childNodes do
i f x i s not v i s i t e d then
stack . push ( x )
. . .
endfor
endwhile
Example 3.1 (DFS )
Ici on empile (gris) les sommets les plus à droite, alors l’ordre des sommets visité (noir) est ( a,b,d,e,g,c,f).
Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b
 c
d
 e
f
g
a
b
 c
d e
f
ga
b
 c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g
L ’utilisation d’une file (FIFO) au lieu d’une pile transforme l’algorithme du parcours en profondeur en algo-
rithme de parcours en largeur ( BFS ). Avec BFS l’exemple précédent devient (en enfile le plus à gauche) :
Example 3.2 (BFS )
Ici, avec BFS, on enfile (gris) les sommets les plus à gauche d’abord, alors l’ordre des sommets visité (noir)
est ( a,b,d,e,g,c,f). Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b c
d
 e
f
g
a
b c
d
 e
f
ga
b c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g22 Chapitre 3. Les algorithmes de base
Exercice 3.1
1. Écrire la procédure BFS .
2. Utiliser DFS (ou BFS) pour la construction d’un arbre couvrant d’un graphe connexe. L ’appliquer
pour le graphe triangle.
3. Utiliser DFS pour écrire une procédure DFS_Cycle pour détecter un cycle dans un graphe.
On sait qu’un graphe orienté G=(V,E) est fortement connexe si pour chaque paire de sommets u,v∈V, il
existe un chemin de uàvet il existe un chemin de vàu. En d’autres termes, nous avons besoin d’une connectivité
dans les deux directions .
Une procédure pour tester si un graphe orienté est fortement connexe ou non peut être conçue avec l’idée
suivante. En partant d’un sommet arbitraire vdu graphe G, on exécute l’algorithme BFS ouDFS et l’on note les
sommets visités. Ensuite, on obtient la transposée de G,GT, en inversant la direction des arêtes de G, et l’on
exécute à nouveau l’algorithme BFS ou DFS à partir du sommet v. Si les sommets visités dans les deux cas sont
égaux à V, alors le graphe orienté est fortement connexe. Cette méthode est illustrée dans l’algorithme 6.
Algorithme 6 : Fortement_connexe
Entrées : Un graphe orienté G=(V,E)
Output : true siGest fortement connexe et false sinon
1X← ; ;
2Y← ; ;
3v←un sommet quelconque de V;
4X←DFS( G,v) ; // Enregistrez les sommets visités dans X
5GT←Gavec flèches inversées;
6Y←DFS( GT,v);
7siX=Y=Valors
8 retourner TRUE.
9sinon
10 retourner FALSE.
11fin
3.2 Recherche des chemins
3.2.1 Matrice d’adjacence et nombre de chemins
La puissance de la matrice d’adjacence Amontre qu’il y a des chemins (ou chaînes) de longueur kallant de xà
ycomme le montre le théorème suivant.
Théorème 3.1
Soit G=(V,E) un (di)graphe. On note V={1,2,..., n} et Asa matrice d’adjacence et Akla puissance k-ème
deA. Alors le terme d’indices i,jdeAkest le nombre de chemins (chaînes) de longueur kallant de iàj.
Preuve. Par récurrence sur k. Pour k=1 c’est clair. On suppose le résultat est vrai à l’ordre ket montrons qu’elle
est vrai pour k+1. Soit S=(si,j)=Ak. Si on a un chemin de iàjde longueur k+1, alors on va d’abord de ià un
sommet ravec kpas et puis de ràj. Or d’après l’hypothèse de récurrence on a si,rchemins possibles pour aller de
iàret finalement ar,jpas (1 ou 0) pour aller de ràj. Ainsi, le nombre totale possibles (i.e. tous les sommets r) est :
nX
r=1si,rar,j=³
Ak×A´
i,jH. SABRI 23
ce qui est bien le terme ( i,j) de la matrice Ak+1.
3.2.2 Plus court chemin et l’algorithme de Dijkstra
Dans cette partie on suppose que le (di)graphe G=(V,E,w) est valué positivement (i.e.∀e∈E,w(e)>0). Notre
objectif est de chercher un plus court chemin (i.e., un chemin de poids minimal ) d’un sommet ufixé à un sommet
quelconque de G.
Il est clair que l’on peut restreindre ce problème au cas d’un (di)graphe simple1. On suppose aussi que Gest
connexe (sinon, certains trajets sont impossibles). Il est aussi claire (d’après théorème 2.1), qu’un plus court chemin
est nécessairement un chemin élémentaire (path).
L ’algorithme de Dijkstra (1959) permet de calculer le plus court chemin entre un sommet particulier u(racine )
et tous les autres sommets. L ’algorithme fonctionne de la manière suivante :
Pour tout sommet vdeG, on associe une valeur T(v), initialisée à w(u,v) et une liste de sommets C(v) qui
correspond à un chemin de uàv. À la fin de l’algorithme, T(v) contient le poids minimal des chemins joignant uà
v(ou T(v)= ∞ siu↛v) et la liste C(v) réalise un tel chemin. Voici donc l’algorithme de Dijkstra :
Algorithme 7 : Algorithme de Dijkstra
Entrées : Un (di)graphe valué G=(V,E,w) et un sommet racine u
Output : Le coût minimum d’un chemin de uàv(∀v∈V) et un trajet pour chaque coût minimal obtenu
1∀v∈V,T(v)←w(u,v) etC(v)←(u,v); // Initialisation de T(v) et la liste C(v)
2X←{u};
3tant que X̸=Vfaire
4 Choisir v∈V−Xtel que ∀y∈V−X,T(v)≤T(y);
5 X←X∪{v};
6 pour chaque y∈V−Xfaire // Faire les mises à jours pour les autres sommets
7 siT(y)>T(v)+w(v,y)alors
8 T(y)←T(v)+w(v,y);
9 C(y)←[C(v),y]; // On ajoute à la liste C(v) l'élément y
10
11 fin
12 fin
13fin
Example 3.3
Voici une application de l’algorithme de Dijkstra au digraphe suivant. On prend Ecomme sommet racine.
EA
B
CD
FG
S5
4
21
12
2
34
4
215
7
1. En effet, passer par une boucle ne ferait qu’augmenter inutilement le poids de ce chemin. De même, si plusieurs arcs joignent deux
sommets, il suffit de conserver l’arc de poids minimal.24 Chapitre 3. Les algorithmes de base
Ainsi, pour l’initialisation, on a : X={E} et on a les valeurs :
v  E A B C D F G S
T(v) 0 5 4 2 ∞ ∞ ∞ ∞
C(v)(E,E) ( E,A) ( E,B) ( E,C) ( E,D) ( E,F) ( E,G) ( E,S)
Maintenant, on choisit (un seul choix) le sommet C, donc X={E,C}. Le tableau est mis à jour :
v  E A B  C D F G S
T(v) 0 5 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À l’étape suivante, on est forcé de choisir B. Ainsi, X={E,C,B} et la mise à jour est :
v  E A  B  C D F G S
T(v) 0 4 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À présent, on a le choix entre AetF. On choisit A. Donc X={E,C,B,A} et on a :
v  E  A  B  C D F G S
T(v) 0 4 3 2 6 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,B,A,D) ( E,C,F) ( E,C,G) ( E,S)
Puis, on prend le sommet F. D’où X={E,C,B,A,F} et :
v  E  A  B  C D  F G S
T(v) 0 4 3 2 5 4 5 11
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,S)
On prend Det on obtient X={E,C,B,A,F,D} et :
v  E  A  B  C  D  F G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Finalement, on prend Gpuis Set on voit que ceci ne change rien. D’où le tableau finale :
v  E  A  B  C  D  F  G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Ainsi le chemin minimum pour aller de EàSest de coût 10 et un trajet de coût minimal de EàSest : EC F DS .H. SABRI 25
3.3 Problèmes d’ordonnancement et chemin critique
Un problème d’ordonnancement peut-être représenté sous la forme d’un digraphe. Les sommets sont des évé-
nements (début et fin de la tâche) et les arcs des tâches, La longueur (ou poids) de chaque arc représente la durée
d’exécution de la tâche. Ainsi, la tâche correspondant à l’arc ( i,j) ne peut commencer que si toutes les tâches cor-
respondant à des arcs ( k,i) ont été complétées. On ajoute deux sommets pour le début (s) et de fin(t) du projet .
Le digraphe peut contenir des tâches fictives dedurée nulle afin de forcer certaines précédences (postériorité).
Ainsi, un réseau PERT est un digraphe valué G=(V,E,w,s,t) où la fonction poids (ou longueur) w:E→R+
etsle sommet source (début) et tle sommet puits (fin). Un chemin critique est un chemin de sàtdelongueur
maximale . S’il n’existe pas de chemin critique, le projet n’est pas réalisable (e.g. un circuit). Le temps minimal
requis pour l’exécution d’un projet réalisable est égal à la longueur d’un chemin critique. Les tâches figurant sur un
chemin critique sont aussi appelées critiques, ce qui s’explique par le fait que tout retard d’exécution d’une tâche
critique retarde d’autant l’exécution du projet.
3.3.1 Algorithmes de tri topologique et de chemin critique
Il faut d’abord numérotés les sommets de 1 à nde manière compatible au pré-ordre (rang) avec l’algorithme du
rang suivant (tri topologique) :
Algorithme 8 : Algorithme du rang
Entrées : Un digraphe G=(V,E) sans circuit
Output : Le rang r(v) de chaque sommet v∈Vde G
1r←0;X←V;
2R←{v∈X:Γ−
X(v)= ;} ; // l'ensemble des sommets de X sans prédécesseur dans X
3tant que X̸= ; faire
4 r(v)←rpour chaque sommet v∈R;
5 X←X−R;
6 R←l’ensemble des sommets de Xsans prédécesseur dans X;
7 r←r+1;
8fin
On supposera dorénavant que les sommets ont déjà été numérotés de 1 à nde manière compatible avec leurs
rangs, c’est-à-dire que r(j)>r(i) implique j>i(donc 1 =setn=t). Enfin, on supposera éliminés les arcs paral-
lèles par l’introduction de tâches fictives de durée nulle .
Pour un sommet i, on note tiledébut au plus tôt des tâches correspondant aux arcs i→jet par Tilafin au
plus tard des tâches correspondant aux arcs j→i.
Algorithme 9 : Algorithme du chemin critique
Entrées : Un digraphe G=(V,E) sans circuit trié topologiquement
Output : La durée du chemin critique et les dates ti,Ti
1t1←0;
2pour j=2···nfaire // Calcul des dates de début au plus tôt  récurrence en avançant
3 tj←max i∈Γ−(j){ti+w(i,j)}
4fin
5Tn←tn;
6pour j=n−1···1faire // Calcul des dates de fin au plus tard  récurrence en reculant
7 Tj←min i∈Γ+(j){Ti−w(j,i)}
8fin26 Chapitre 3. Les algorithmes de base
Définition 3.1
— Un sommet iest critique si ti=Ti.
— Un arc ( i,j) est critique les sommets ietjsont critiques ettj−ti=w(i,j).
— Un chemin critique est un chemin de 1 à nn’utilisant que des arcs critiques.
— La durée du chemin critique est donnée par Tn(ou par tn). Elle correspond à la durée minimale du
projet .
Example 3.4
L ’application de l’algorithme du chemin critique au digraphe suivant (trié topologiquement) est :
1 23
45
6B
9A
3
C
5D
8
E
4
F7G
20
H6I5
=⇒
 1
0,02
9,933,16
4
16,23513,24
6
29,29B
9A
3
C
5D
8
E
4
F7G
20
H6I5
Les tâches critiques sont BetG. La durée totale minimale du projet est donc 29.
Exercice 3.2
Les tâches ( durée et précédences ) pour la construction d’un entrepôt sont données dans le tableau suivant :
Tâches Nature Précédences Durée (jours)
A Acceptation des plans par le propriétaire – 4
B Préparation du terrain – 2
C Commande des matériaux A 1
D Creusage des fondations A, B 1
E Commande des portes et fenêtres A 2
F Livraison des matériaux C 2
G Coulage des fondations D, F 2
H Livraison des portes et fenêtres E 10
I Pose des murs, de la charpente et du toit G 4
J Mise en place des portes et fenêtres H, I 1
1. Représentez le graphe des précédences de ce projet (trié topologiquement).
2. Déterminez une durée totale minimale en exhibant un chemin critique dans ce graphe.CHAPITRE 4
Programmation linéaire
La programmation linéaire est le processus de minimiser ou maximiser une fonction objective linéaire sou-
mise à un nombre fini de contraintes d’égalités et d’inégalités linéaires.
La programmation linéaire a de nombreuses applications dans le domaine de l’informatique théorique. Elle
peut être utilisée pour résoudre de nombreux problèmes combinatoires variés, tels que la recherche de flot maxi-
mum dans un réseau, la recherche d’un couplage maximal dans un graphe et la coloration d’un graphe parfait.
Example 4.1 (Problème de régime)
On suppose qu’on a quatre plats : de la truite ( XT), un sandwich au corned-beef ( XC B), un burrito ( XBU R )
et un hamburger ( XHB). Le tableau suivant répertorie la valeur nutritionnelle de chaque plat (vitamines et
calories) et notre besoin journalier des vitamines.
Vit. A Vit. C Vit. D Calories
Truite 203 92 100 600
Corned-beef 90 84 230 350
Burrito 270 80 512 250
Humburger 500 90 210 500
Besoins 2000 300 430
Notre objectif est de minimiser le nombre total de calories consommées : 600 XT+350XC B+250XBU R+
500XHBtout en satisfaisant les trois besoins nutritionnels en vitamines. Le programme linéaire résultant
s’écrit :
min 600 XT+350XC B+250XBU R+500XHB
s.t. 203 XT+90XC B+270XBU R+500XHB≥2000, (Besoins de Vit. A),
92XT+84XC B+80XBU R+90XHB≥300, (Besoins de Vit. C),
100XT+230XC B+512XBU R+210XHB≥430, (Besoins de Vit. D),
XT,XC B,XBU R ,XHB≥0
Définition 4.1: Forme canonique – Forme standard
On peut écrire un P .L. sous deux formes spéciales :
•Canonique
max
mincTX+c0
s.t. AX≤b(≥bsi min),
X≥0•Standard
max cTX+c0
s.t. AX=b,
X≥0Avec :
cTX=¡
c1··· cn¢
x1
...
xn

cTX+c0=c1x1+c2x2+···+ cnxn+c0
2728 Chapitre 4. Programmation linéaire
Remarque 9. Un P .L. général peut être formulé selon une forme standard ou canonique par la méthode suivante :
générale =⇒ standard il faut éliminer les contraintes d’inégalité et les variables sans contrainte de positivité.
— Si dT
iX≤biest une contrainte d’inégalité, alors créer une nouvelle variable ( d’écart ) siet remplacer l’in-
égalité dT
iX≤bipar dT
iX+si=biet s i≥0.
Si dT
iX≥bi, alors on peut écrire dT
iX−si=biet s i≥0.
— Si une variable x i≶0est de signe quelconque, alors créez deux nouvelles variables x+
iet x−
iet remplacez
xipartout par x+
i−x−
i, et ajoutez les contraintes de signe : x+
i≥0,x−
i≥0.
générale =⇒ canonique
— Si dT
iX=biest une contrainte d’égalité, alors remplacer cette égalité par une paire d’inégalités :
dT
iX≥biet−dT
iX≥ −bi
— Même chose que précédemment si la variable x i≶0.
Il est facile de voir que les problèmes qui en résultent sont équivalents aux problème d’origine. Pour l’algorithme
simplexe , nous utiliserons la forme standard .
On remarque aussi qu’en utilisant la relation min f(x)= − max¡
−f(x)¢
dans laquelle f (x)représente la fonction-
nelle linéaire à optimiser, on peut toujours se ramener à un problème de minimisation (ou de maximisation).
Example 4.2
Le P .L :max 5 x+4y
s.t. x≤6
1
4x+y≤6
3x+2y≤22
x,y≥0s’écrit sous forme standard :max 5 x1+4x2
s.t. x1+e1=6
1
4x1+x2+e2=6
3x1+2x2+e3=22
x1,x2,e1,e2,e3≥0
Donc (sous la forme matricielle) on a :
cT=¡
5 4 0 0 0¢
;A=
1 0 1 0 0
1
41 0 1 0
3 2 0 0 1
;X=
x1
x2
e1
e2
e3
et b=
6
6
22

4.1 La méthode simplexe
4.1.1 Solution de base admissible
On suppose que la matrice Adu programme linéaire est de type m×netde rang m(pourquoi !). Soit Bla
matrice carrée extraite de Aformée par les mcolonnes j1,j2,..., jmlinéairement indépendants de A(les vecteurs
de base). Alors, Best une matrice inversible. Ainsi si on pose xl=0 sil∉{j1,..., jm} etxjklak-ième composante de
B−1b. Alors, on a AX B=b. Si de plus XB≥0(i.e. chaque xi≥0), alors :
Xest une solution de base admissible (ou réalisable)
Dans l’exemple 4.2, la matrice extraite B=
1 0 0
0 1 0
0 0 1
est inversible et B−1b=
6
6
22
. Donc XB=
0
0
6
6
22
≥0, par suite
XBest une solution de base admissible. On appelle les variables xjklesvariables de base . Les autres variables xl
sont les variables hors-base .
Parfois, il n’est pas évident de trouver une solution de base admissible, comme le montre l’exercice suivant :H. SABRI 29
Exercice 4.1
Écrire le programme linéaire suivant sous forme standard et montrer qu’on n’a pas une solution de base
admissible. Résoudre le programme linéaire.
max −x+y
s.t. x+y≥1,
3x+2y=6,
x,y≥0
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux
Dans cette section, on suppose qu’on a déjà trouvé une solution de base admissible X(produite avec B=Im)
du programme linéaire ( P: max z=cTX+c0etb≥0pour garantir que 0est une solution de AX≤b).
La méthode du simplexe est une méthode itérative qui génère une séquence de solutions de base réalisable
(correspondant à différentes bases) et s’arrête finalement lorsqu’elle a trouvé une solution de base réalisable opti-
male. Remarquer qu’on peut toujours prendre c0=0.
Algorithme 10 : Algorithme du simplexe
Entrées : Un P .L. standard P(max) avec une solution de base réalisable
Output : La solution optimale (ou non)
1On commence à écrire le tableau initiale (avec les variables de base xj1,..., xjm)
VB x1 ... xn b
xj1 b1
... A...
xjm bm
c1 ... cn−c0
2Sicj≤0 (∀j:xjest hors base), alors solution optimale (STOP) // min ⇝cj≥0
3Trouver la colonne s(hors base) tel que cs=max©
cj:cj>0ª// min ⇝cs=min©
cj:cj<0ª
4Siai,s≤0∀i=1... m, alors pas de solution optimale (STOP)
5Min Ratio Test : trouver la ligne rtel que
br
ar,s=min
i=1...m½bi
ai,s:ai,s>0¾
6Appliquer la procédure de Gauss autour de pivot ar,s(ar,s⇝1 et on annule les coefficients situés sous et
sur le pivot dans la colonne s, par combinaisons de lignes) // Ne pas oublier la dernière ligne
7Remplacer (dans VB) la variable de base ( sortante ) située à la ligne rpar la variable ( entrante )xs
8Retourner à l’étape 2 // l'algorithme termine si le programme linéaire est non dégénéré
Remarque 10.
— La dernière ligne représente l’équation linéaire −z+c1x1+···+ cnxn= −c0.
— La valeur de la variable de base de V Bde la ligne k est égale à la valeur b k(de la ligne k).
— La solution optimale du problème est la valeur finale (dernière cellule) (×− 1).
— Si on n’a pas au départ B =Im(à l’aide des variables d’écart) alors, on ajoute les variables artificielles (et on
applique d’abord la phase I - voir section suivante).30 Chapitre 4. Programmation linéaire
Exercice 4.2
Soit le programme linéaire :
max 2 x1+x2
s.t. x1−x2≤3,
x1+2x2≤6,
−x1+2x2≤2,
x1,x2≥0
Rajouter les variables d’écart. Puis résoudre le problème par l’algorithme du simplexe.
Remarque 11. Vérifier le résultat de l’exercice précédent, par la méthode graphique.
4.1.3 Initialisation - Phase I du simplexe
Un programme linéaire est dit sous forme simpliciale si la matrice Acontient la matrice identité Imcomme
sous matrice. On suppose que le programme linéaire P, après la mise en forme AX=b, n’est pas simpliciale
(possible dans le cas de contraintes du type ≥ou du type =). Soit Bune matrice d’ordre mextraite de Ainversible
tel que B−1b≥0et soit XBla solution de base réalisable ( XB≥0etAX B=b), alors on peut changer l’équation
matricielle :
AX B=b
⇐⇒ (B−1A)XB=B−1b
⇐⇒ A∗XB=b∗
et la matrice A∗contient la matrice identité Imcomme matrice extraite ( B−1A=B−1(H|B)=¡
B−1H|Im¢
). Ainsi, on
peut appliquer directement l’algorithme 10 en remplaçant Apar A∗etbpar b∗. Cependant, cette méthode n’est
pas efficace, car il faut trouver une matrice extraite Bréalisable correspondante. Pour une matrice Ade type m×n,
il existe¡m
n¢
matrices extraites à tester !
L ’idée est d’ajouter des variables, dites artificielles w1,w2,..., wm, pour faire apparaître une forme simpliciale
du programme linéaire P: (AX=b). Mais, il faut que w1= ··· = wm=0. Donc, il faut minimiser d’abord le pro-
gramme linéaire P0suivant :
P0=min W=w1+···+ wm
s.t. (A|Im)×(x1...xnw1...wm)T=b
x1,..., xn,w1,..., wm ≥0
On exprime Wà l’aide des autres variables (hors base) et puis on applique l’algorithme du simplexe 10 pour P0
(phase I). À la fin, si on trouve que les wi=0, alors les variables de bases xj1,..., xjmforment une première base
admissible pour démarrer le simplexe pour le programme d’origine P.H. SABRI 31
Remarque 12. On ajoute la ligne de Z :c1 ... cn−c0dans le tableau du simplexe de P0(phase I) et on lui
applique les opérations élémentaire comme avec les autres lignes. À la fin de la phase I, on supprime les colonnes des
wiet la ligne de la fonction W . Finalement, on utilise ce tableau pour résoudre le problème initiale P.
Example 4.3
Soit le programme linéaire P:
min 6 x1+3x2
s.t. x1+x2≥1,
2x1−x2≥1,
3x2≤2,
x1,x2≥0sous forme standard (max)= = = = = = = = = = = = = = = = = = ⇒max Z= −6x1−3x2
s.t. x1+x2−e1=1,
2x1−x2−e2=1,
3x2+e3=2,
x1,x2,e1,e2,e3≥0
La matrice Aest :
A=x1 x2 e1 e2 e3

1 1 −1 0 0
2−1 0 −1 0
0 3 0 0 1
est par suite Pn’est pas sous forme simpliciale (il n’ ya pas de sous matrice I3). Donc on peut ajouter 2
variables artificielles pour construire le problème initiale P0:
max −w1−w2=3x1−e1−e2−2
s.t. x1+x2−e1+w1=1,
2x1−x2−e2+w2=1,
3x2+e3=2,
x1,x2,e1,e2,e3,w1,w2≥0dont le vecteur X=

0 x1
0 x2
0 e1
0 e2
2 e3
1 w1
1 w2est une solution de base réalisable.
Ainsi, on commence notre algorithme 10 pour le programme P0. Le tableau initial est :
x1 x2 e1 e2 e3 w1 w2 b

w1 1 1 −1 0 0 1 0 1
w2 2−1 0 −1 0 0 1 1
e3 0 3 0 0 1 0 0 2
W: 3 0 −1−1 0 0 0 2
Z:−6−3 0 0 0 0 0 0
Le pivot c’est a2,1donc x1est la variable entrante et w2est sortante. On obtient après pivotement le tableau :
L2←1
2L2− − − − − − − − →
L1←L1−L2
L4←L4−3L2
L5←L5+6L2x1 x2 e1 e2 e3 w1 w2 b

w1 03
2−11
20 1−1
21
2
x1 1−1
20−1
20 01
21
2
e3 0 3 0 0 1 0 0 2
W: 03
2−11
20 0−3
21
2
Z: 0 −6 0 −3 0 0 3 3
Le pivot est a1,2(Min ratio test =1
3). On obtient alors :32 Chapitre 4. Programmation linéaire
L1←2
3L1− − − − − − − − →
L2←L2+1
2L1
L3←L3−3L1
L4←L4−3
2L1
L5←L5+6L1x1 x2 e1 e2 e3 w1 w2 b


x2 0 1−2
31
302
3−1
31
3
x1 1 0−1
3−1
301
31
32
3
e3 0 0 2 −1 1 −2 1 1
W: 0 0 0 0 0 −1−1 0
Z: 0 0 −4−1 0 4 1 5
Ainsi, la phase I se termine avec W=0 et x1=2
3,x2=1
3,e3=1 et e1=e2=w1=w2=0. Le tableau pour la
phase II est donc :
x1 x2 e1 e2 e3 b


x2 0 1−2
31
301
3
x1 1 0−1
3−1
302
3
e3 0 0 2 −1 1 1
Z: 0 0 −4−1 0 5
On remarque donc que les cj≤0, donc (STOP) la solution est optimale et le max est −5. Ainsi la solution
optimale pour le programme P=min6 x1+3x2est−(−5)=5=6×2
3+3×1
3.
4.2 Dualité
SoitPun P .L. sous forme canonique. Le programme dualDdePest définit par :
P=max z=cTX
s.t. AX ≤ b
X≥ 0le dual est= = = = = = = ⇒D=min w=bTY
s.t. ATY≥ c
Y≥ 0
Le programme Pest dit primal . On remarque que si Ade type m×n, alors X∈RnetY∈Rmpour le dual.
Théorème 4.1 Théorème de dualité
Si un problème primal ou dual admet une solution, alors l’autre problème admet aussi une solution et on a :
max z=cTX =
s.t. AX ≤ b
X≥ 0min w=bTY
s.t. ATY≥ c
Y≥ 0
Exercice 4.3
Soit le problème suivant de type régime :
D=min w=340x1+2400 x2+560x3
s.t. x1+2x2+x3≥ 1200
x1+3x2+2x3≥ 1400
x1+x2+3x3≥ 1500
x1,x2,x3≥ 0
Écrire le programme primal PdeD. Résoudre le programme Pet déduire la valeur minimale de w, a-t-on
besoin de faire les deux phases du simplexe ?
7} A B oS



HOUSSEM SABRI
Graphes et Optimisation
2`emeannée
LISI  LSI
Institut Supérieur des Sciences Appliquées et de Technologie de Sousse
A.U. 2023-2024
28 novembre 2023Table des matières
1 Les graphes 3
1.1 Définitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.1 Graphes non orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.2 Graphes orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.2 Opérations et quelques types de graphes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.3 Représentation d’un graphe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.1 Listes d’adjacences (ou de succession) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.2 Matrices d’adjacence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.3.3 Matrice d’incidence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2 La connexité 11
2.1 Les chaînes et les cycles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.2 Graphe connexe, eulérien, hamiltonien . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.3 Arbres . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.3.1 Codage et décodage d’un arbre – Prüfer code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.3.2 Arbre couvrant de poids minimum – ACM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3 Les algorithmes de base 20
3.1 Parcours en profondeur (DFS) / largeur (BFS) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
3.2 Recherche des chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.1 Matrice d’adjacence et nombre de chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.2 Plus court chemin et l’algorithme de Dijkstra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
3.3 Problèmes d’ordonnancement et chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
3.3.1 Algorithmes de tri topologique et de chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . 25
4 Programmation linéaire 27
4.1 La méthode simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.1 Solution de base admissible . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux . . . . . . . . . . . . . . . . . . . . . . . . 29
4.1.3 Initialisation - Phase I du simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
4.2 Dualité . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
2CHAPITRE 1
Les graphes
L ’exemple classique pour introduire la théorie des graphes est le problème des ponts de Königsberg, étudié par
Euler en 1736. Quel itinéraire doit-on suivre pour traverser chaque pont exactement une fois? Une telle prome-
nade n’existe pas, et c’est Euler qui donna la solution de ce problème en caractérisant les graphes que l’on appelle
aujourd’hui eulériens .
A
B
Ce1 e2
e3 e4
De5
e6e7
FIGURE 1.1 – Les ponts de Königsberg
Les graphes introduisent une simplification : les régions se transforment en des "points" (aussi appelés noeuds
ousommet ), les ponts se transforment en des lignes (aussi appelées arêtes ouarcs ), et ce principe s’applique dès
lors qu’une relation existe entre des objets. Les graphes relèvent de la combinatoire plutôt que de la géométrie (les
intersections, les longueurs, et la forme des arêtes n’ont aucune importance, sauf en ce qui concerne la lisibilité de
la représentation).
1.1 Définitions
Dans la suite, il est toujours supposé que les graphes sont finis, sauf indication contraire.
1.1.1 Graphes non orientés
Définition 1.1: Graphe
Un graphe Gest un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V{2}des pairs non ordon-
nées de V.Vest l’ensemble des noeuds (Vertices en anglais) et Ec’est l’ensemble des arêtes de G(Edges en
anglais). Lorsque e={x,y} est une arête, on dit que x, y sont les extrémités de cette arête, que eest incidente
enxet en y. On joint x et y par un trait et on dit que x, y sont adjacents (ou voisins). On note aussi e=x you
encore e=(x,y) (attention , dans ce cas : ( x,y)=(y,x)).
SiGest un graphe alors, on note par V(G) l’ensemble de noeuds et par E(G) l’ensemble des arcs.
Remarque 1.
— Une arête e ={x,x}s’appelle boucle .
— Dans un graphe, il peut exister des arêtes parallèles (on parle donc de multigraphe ).
Dans l’exemple des ponts on a : e 1=e2=(A,B).
34 Chapitre 1. Les graphes
— Un graphe est dit simple s’il ne comporte ni arêtes multiples ni de boucles, c’est-à-dire chaque paire de nœuds
distincts est reliée par au plus une arête, ou encore E (G)⊆P2(G).
Dans la plupart des cas, les graphes sont considérés comme simples par défaut.
Définition 1.2: ordre – taille – degré
Soit G=(V,E) un graphe.
1. On appelle ordre d’un graphe noté v(G) le nombre de ses sommets :
v(G)= |V|
2. On appelle taille d’un graphe noté e(G) le nombre de ses arêtes :
e(G)= |E|
3. Le degré (ou valence) d’un sommet xnoté d(x) est le nombre d’arêtes contenant x. (Attention! Une
boucle sur un sommet compte double).
Si on note par Γ(x) l’ensemble des voisins de x, i.e.
Γ(x)={y∈V:x y∈E}
alors, siGest simple , on a :
d(x)= |Γ(x)|
Example 1.1 (Graphe complet)
Un graphe d’ordre nest dit complet noté Knsi chaque sommet du graphe est relié directement à tous les
autres sommets, i.e. E(Kn)=P2(V(Kn)).
Représenter graphiquement K3,K4,k5. Calculer la taille de K3,k4,...Kn.
Example 1.2 (Graphe biparti)
Un graphe G=(V,E) est dit biparti si son ensemble de sommets V=V1˙∪V2, i.e. peut être divisé en deux
sous-ensembles disjoints V1etV2tels que chaque arête ait une extrémité dans V1et l’autre dans V2.
Si∀x∈V1,∀y∈V2;x y∈E, alors Gest dit biparti complet noté Kn,moùn= |V1|etm= |V2|.
a1
 a2
 a3
 a4
b1
 b2
 b3
FIGURE 1.2 – Un graphe biparti
Théorème 1.1 Lemme des poignées de main – Handshaking lemma
Soit Gun graphe alors, on a :X
x∈V(G)d(x)=2e(G)
Dans ce théorème d(x) est le nombre de personnes à qui xserre la main et e(G) le nombre total de poignées
de mains.H. SABRI 5
Preuve.
•Méthode simple Il y en a d(x) arêtes en un sommet xfixé. Pour tout les sommets cela fait doncP
x∈V(G)d(x).
Mais avec cette manière chaque arête est comptée deux fois, une fois à chacune de ses extrémités, d’où le
résultat en divisant par 2.
•Preuve par double dénombrement On pose
Z={(x,e)∈V×E:x∈e}⊆V×E
et les deux projections :
p:Z→V
(x,e)7→xet q:Z→E
(x,e)7→e
L ’idée est de calculer |Z|de deux manières différentes. D’abord, on rappelle que si f:A→Best une fonction
quelconque, alors :X
b∈B|f−1[b]| = | A|
oùf−1[b] désigne l’image réciproque de { b} par f(pourquoi ˙S
b∈Bf−1[b] est une union disjointe ?).
Ainsi on obtient :
|Z| =X
x∈V|p−1[x]| =X
e∈E|q−1[e]|
Or,|p−1[x]| =d(x) et|q−1[e]| = |{x∈V:x∈e}| =2. Donc :
X
x∈Vd(x)=X
e∈E2=2|E|
Remarque 2.
— Un sommet de degré 0est appelé sommet isolé .
— Un graphe tel que : ∀x∈V,d(x)=kest dit graphe k-régulier .
— Le graphe complet K nest un graphe (n−1)-régulier .
Exercice 1.1
Montrer que dans un graphe le nombre de sommets d’ordre impairs est toujours pair. En particulier un
graphe k-régulier avec kimpaire est un graphe d’ordre pair.
Voici quelques exemples comme application :
1. Est-il possible de relier 15 ordinateurs en réseau de sorte que chacun soit relié à exactement 3 autres ?
2. Une ligue de football comprenant 11 clubs organise un tournoi. Pour gagner du temps on décide que chaque
équipe ne jouera que la moitié des matches possibles. Comment organiser le tournoi ?
Proposition 1.1
Soit G=(V,E) un graphe (simple) d’ordre n≥2. Alors :
∃u,v∈V,u̸=v:d(u)=d(v)
Preuve. Supposons le contraire, c’est-à-dire ∀u,v∈V;d(u)̸=d(v). Or dans un graphe (simple) on a toujours d(x)∈
{0,1,..., n−1}. Dans ce cas, puisque tous les nsommets ont des degrés distincts, alors il existe une bijection
{d(x):x∈V}←→ {0,1,..., n−1}
Donc, il existe un sommet uavec un degré 0, et un sommet vavec degré n−1, donc vest connecté à tous les autres
sommets du graphe, ce qui signifie que une peut pas être un sommet isolé, d’où une contradiction.6 Chapitre 1. Les graphes
1.1.2 Graphes orientés
Les arêtes d’un graphe peuvent être orientées, auquel cas une flèche indique la direction. De tels graphes sont
appelés des graphes orientés ou des digraphes , et une arête ( a,b) dans un tel graphe indique que cette arête est
dirigée de sommet avers b, i.e. ( a,b)=− →ab̸=(b,a)=− →ba. D’où la définition :
Définition 1.3: Graphe orienté - digraphe
Un graphe orienté G(ou− →G) est un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V2des pairs
ordonnées de V.Eest l’ensemble des arêtes (ou flèches, arcs) de G. Lorsque e=(x,y) est une arête, on dit
que xestl’origine (ou sommet initiale) et yl’extrémité (ou sommet terminale) de e, que eest sortant en x
et incident en y, et que yest un successeur de xtandis que xest un prédécesseur de y. On note l’arête e
par :
e=(x,y)=− →x y=x→y
De la même façon, une arête x→xest une boucle. On peut toujours supprimer les boucles pour obtenir des
digraphes simples. Voici l’exemple d’un digraphe G=(V,E) d’une fonction f:E→Eoù ( x,y) est un arc si et seule-
ment si y=f(x). On l’appelle digraphe fonctionnelle.
0
3
1214
11 568
169
4
2 1
713 10
15
FIGURE 1.3 – Le digraphe fonctionnelle Gfdex7→(x2+3) mod 17.
Comme dans les graphes on peut définir les degrés (entrant, sortant) d’un sommet dans un digraphe.
Définition 1.4: indegree - outdegree
Soit G=(V,E) un digraphe. Pour v∈V, on note par :
d+(v) le degré extérieur (sortant - outdegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité initiale.
d+(v)= |{v→ •}|
d−(v) le degré intérieur (entrant - indegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité finale.
d−(v)= |{• → v}|
On définit le degré : d(v)=d−(v)+d+(v).
Un sommet de degré entrant non nul et de degré sortant nul est appelé puits , tandis qu’un sommet de
degré entrant nul et de degré sortant non nul est appelé source ouracine .
Dans un graphe orienté, les voisins d’un sommet vsont soit des successeurs ou des prédécesseurs. On les notes
par :
Γ+(x)=Succ (x)={y∈V:x→y∈E} et Γ−(x)=Pr ed (x)={y∈V:y→x∈E}H. SABRI 7
Si le digraphe est simple (ni boucle ni arcs parallèles) on a :
d−(v)= |Γ−(v)|et d+(v)= |Γ+(v)|
Proposition 1.2
Soit Gun digraphe, alors :X
v∈Vd−(v)=X
v∈Vd+(v)= |E|
Preuve. On a
E=˙[
v∈V{• → v}=˙[
v∈V{v→ •}
=⇒ | E| =X
v∈V|{• → v}| =X
v∈V|{v→ •}| =⇒ | E| =X
v∈Vd−(v)=X
v∈Vd+(v)
1.2 Opérations et quelques types de graphes
Une opération sur les graphes permet de construire un nouveau graphe comme résultat de l’opération. Les
opérations courantes sur les graphes sont la suppression, la valuation, l’union, l’intersection et le produit cartésien.
Graphe valué
Tout d’abord, on peut vouloir attribuer des valeurs aux arcs ou arêtes pour tenir compte de contraintes : dis-
tance, coût ...
Définition 1.5: (di)graphe valué
Un (di)graphe valué G=(V,E,w) est un (di)graphe muni d’une application w:E→R. L ’application west
appelée application poids ou coût. On indique sur chaque arête son poids (ou son coût). On note w(x,y)
au lieu de w((x,y)). On convient (même que ceci n’a pas de sens!) que w(x,y)= +∞ si (x,y)∉E.
ab
c
d
ef53
43
3
335
81
FIGURE 1.4 – Un digraphe valué
/pythonPython code : -
Implémenter le digraphe valué précédent avec python. Indice – use chatGPT : how to build a weighted digraph with
python8 Chapitre 1. Les graphes
Sous graphes
Soit G=(V,E) un graphe (orienté ou non). Un sous graphe de Gest un graphe de la forme G′=(V′,E′) où
V′⊆V,E′⊆Etels que toute arête de E′a ses extrémités dans V′(ou encore G′est aussi un graphe). On a :
•Sous-graphe induit Un sous-graphe G′=(V′,E′) de G=(V,E) est appelé un sous-graphe induit deGsi :
∀x,y∈V′; (x,y)∈E′⇐⇒ (x,y)∈E
En d’autres termes, deux sommets de G′qui sont connectés dans G, sont également connectés dans G′.
•Sous-graphe couvrant Un sous-graphe couvrant G′deGcontient tous les sommets de G, i.e. V′=V.
•G−vSupprimer un sommet vd’un graphe Gconsiste à supprimer vet toutes ses arêtes incidentes. Le sous-
graphe obtenu de cette opération est noté G−v, i.e.
V′=V−{v} et E′=E−{(v,y): (v,y)∈E}
De manière similaire, une arête epeut être supprimée (resp. ajoutée) d’un graphe G, et le sous-graphe
résultant est représenté par G−e(resp. G+e). Notez que la suppression d’une arête ne retire pas de sommets
du graphe.
•G−V′=G[V′] On supprimer tous les sommets v∈V′du graphe Gavec les arêtes incidentes. Le sous-graphe
obtenu de cette opération est noté G[V′], i.e.
V(G[V′])=V−V′et E(G[V′])=E−{(v,y)∈E:v∈V′}
•Clique Une clique Cd’un graphe Gest un sous-ensemble des sommets de Gdont le sous-graphe induit G′=
(C,E′) est un graphe complet, en d’autres termes, deux sommets quelconques de la clique Csont toujours
adjacents.
•Stable Un stable – appelé aussi ensemble indépendant (independent set en anglais) est un ensemble de som-
mets deux à deux non adjacents. Donc le sous-graphe induit est sans arcs.
FIGURE 1.5 – L ’ensemble des sommets en bleu dans ce graphe est un stable maximal du graphe.
Note : -
Le problème décisionnel de la clique (c’est à dire existe t-il une clique de taille k) est NP-complet . De même la
recherche d’un stable de taille maximum dans un graphe est un problème NP-complet et difficile à approximer.
Exercice 1.2
Trouver un plus grand stable et une plus grande clique du graphe suivant :
8
4
62 7
3
1 5
Indice : vérifier le résultat avec networkx.find_cliques(G) et.maximum_independent_set(G) de python.H. SABRI 9
Opérations binaires
Union L ’union de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∪H=(VF,EF) dans lequel
VF=VG∪VH et EF=EG∪EH
Intersection L ’intersection de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∩H=(VF,EF)
dans lequel
VF=VG∩VH et EF=EG∩EH
1.3 Représentation d’un graphe
Il est important de savoir comment représenter les graphes au sein d’un ordinateur. Il ya plusieurs méthodes
selon la nature des traitements que l’on souhaite appliquer au graphe considéré.
1.3.1 Listes d’adjacences (ou de succession)
Soit Gun (di)graphe. On suppose que les sommets de Gsont numérotés de S1àSn. La représentation par listes
d’adjacence de Gconsiste en un tableau (ou des listes chainées) tel que la ligne i=1... ncorrespond au sommet Si
et comporte la liste des voisins/successeurs (ou des prédécesseurs) de ce sommet notée T[Si]. Les sommets dans
chaque liste d’adjacence sont généralement listés selon un ordre arbitraire.
1
2
345
FIGURE 1.6 – Un digraphe
La liste d’adjacence de digraphe 1.6 est donc :
1 2 3 4 5
2 3
3 4
4−
5 1 410 Chapitre 1. Les graphes
1.3.2 Matrices d’adjacence
Définition 1.6: Mat. Adjacence
Soit G=(V,E) un graphe (orienté) d’ordre n. On peut numéroter V={1,2,..., n}.La matrice d’adjacence
deGest la matrice carrée A=(ai j) d’ordre n, définie par :
ai j=(
1 si ( i j)∈E;
0 sinon.
Remarque 3.
1. Si le graphe G est non orienté et simple, alors la matrice A est symétrique avec des 0sur la diagonale. Pour un
digraphe simple, on a toujours des 0sur la diagonale, mais la matrice n’est pas symétrique en général.
2. Pour les multigraphes, il peut y avoir des termes diagonaux (pour les boucles) et s’il y a plusieurs arêtes de i à
j , le coefficient de la matrice a i jest le nombre d’arêtes de i à j .
3. Pour un (di)graphe valué G =(V,E,w), on pose :
ai j=(
w(i,j)si(i j)∈E ;
∞ sinon.
La matrice d’adjacence de la figure 1.4 est :

∞ 5∞ 4 3 ∞
∞ ∞ 3∞ 1∞
∞ ∞ ∞ ∞ ∞ 5
∞ ∞ 3∞ 3 3
∞ ∞ ∞ ∞ ∞ 8
∞ ∞ ∞ ∞ ∞ ∞

1.3.3 Matrice d’incidence
Définition 1.7: Mat. Incidence
Soit G=(V,E) un graphe (simple) d’ordre net de taille m. On pose V={v1,v2,..., vn} etE={e1,e2,..., em}.
La matrice d’incidence deGest la matrice de type n×m B=(bi j), définie par :
•Si G orienté
bi j=

1 si ej=vi→ • (i.e. viest l’extrémité initiale de ej) ;
−1 si ej= • → vi(i.e. viest l’extrémité terminale de ej) ;
0 sinon.
•Si G non-orienté
bi j=(
1 si viest une extrémité de ej;
0 sinon.
Exercice 1.3
1. Donner la matrice d’incidence du graphe 1.6.
2. Montrer le théorème 1.1 avec la matrice d’incidence.CHAPITRE 2
La connexité
Il est important de savoir si on peut suivre un chemin d’un sommet donné à un autre dans un graphe donné.
Cette propriété (de connexité) doit être maintenue dans différents types de réseaux.
2.1 Les chaînes et les cycles
Définition 2.1: (chaine – cycle) (chemin – circuit)
•Graphe non orienté
1. Une chaîne (walk ) reliant xày, notée µ(x,y), est définie par une suite finie d’arêtes consécutives,
reliant xày, ou encore une séquence de sommets (puisque non multigraphe)
µ(x,y)=<v0,v1,..., vk>
tels que v0=x,vk=yet (vi−1,vi)∈E(G) pour tout i=1... k. Six=yla chaîne est dite fermée .
Lalongueur du chaîne l(µ(x,y)) est le nombre d’arcs dans la chaîne, c’est-à-dire k.
2. Une chaîne élémentaire (a path ) si tous les sommets sont distincts. Une chaîne simple (a simple
walk, a trail ) est une chaîne ne passant pas deux fois par une même arête, c’est-à-dire dont toutes
les arêtes sont distinctes. Remarquer que : élémentaire =⇒ simple.
3. Un cycle v0v1...vnde longueur n≥3 est une chaîne simple fermée ( v0=vn) tel que les sommets
v0,v1,..., vn−1sont tous distincts. Un graphe sans cycle est dit acyclique .
•Graphe orienté
Dans un graphe orienté, on parlera de chemin au lieu de chaîne, et de circuit au lieu de cycle.
Example 2.1
abxcd xa est une chaîne simple et fermée (non cycle!) de longueur 6 (mais, c’est un graphe eulérien - voir
plus loin). Y a-t-il un cycle de longueur 3,4 ?
a b
x
c dÏ
Remarque 4.
1. On peut pivoter une chaine fermée (l’orienter de manière arbitraire) , i.e.
<v0,v1,v2,..., v0>=< vk,vk+1,..., v0,v1,..., vk>
1112 Chapitre 2. La connexité
2. Soient x ,y∈V . La distance de x à y est définie par :
d(x,y)=(
k si le plus court chemin/chaîne de x vers y est de longueur k
∞ sinon
On convient que d (x,x)=0.
3. Le diamètre du graphe la plus grande distance entre deux sommets.
L ’observation suivante, bien que très facile à prouver, sera utile.
Théorème 2.1
S’il existe une chaîne du sommet yau sommet zdans le graphe G, où y̸=z, alors il existe une chaîne élé-
mentaire ( path ) dans Gavec pour premier sommet yet pour dernier sommet z.
Preuve. Soit la chaine
W1=µ(y,z)=x0x1...xn; avec x0=yetxn=z.
Si les sommets x0,x1,..., xnsont tous distincts, alors W1est une chaîne élémentaire, et nous avons terminé. Sinon,
il existe xi=xj(i<j) et on écrit :
W2=x0x1...xixj+1...xn.
Alors, l(W2)<l(W1). Si W2ne contient aucun sommet répété, alors c’est la chaîne recherché. Sinon, par la même
procédure, il existe W3(y z−chaîne) tel que
l(W3)<l(W2)<l(W1).
Ce processus doit s’arrêter à un certain stade, car chaque chaîne est plus courte que la précédente et la longueur
ne peut jamais être inférieure à 1
1< ··· < l(Wk)< ··· < l(W3)<l(W2)<l(W1).
Ainsi, pour un certain k,Wkne peut pas être réduit en longueur. Donc, la chaîne Wkne contient aucun sommet
répété et est donc une y z−chaîne élémentaire (path).
Exercice 2.1
Dans le graphe suivant, construire un path à partir de la chaîne W=v2v3v4v5v6v4v2v8v1
v1
 v2
v3
v4
v5
v6
v7
 v8
 v9
Calculer d(v1,v7) et le diamètre de G.
/pythonpython : >>G = nx.Graph([(1, 2), (2, 3), (2, 4), ...]) >>nx.diameter(G)
Les cycles fournissent la caractérisation suivante pour les graphes bipartis .H. SABRI 13
Théorème 2.2
Un graphe est biparti si et seulement s’il ne contient aucun cycle de longueur impaire.
Preuve.
⇒On suppose que G=U˙∪Vest un graphe biparti. Soit W=< x1,x2,..., x2k+1,x1>un cycle de longueur im-
paire (2 k+1). Si x1∈U, alors
x1∈U=⇒ x2∈V=⇒ x3∈U=⇒ ··· =⇒ x2k+1∈U=⇒ x1∈V/exclamati⌢n-triangle
absurde, d’où le résultat.
⇐On suppose que Gest connexe (car l’union des composantes connexes bipartis est un graphe biparti). Soit
xun sommet de Get on pose :
U={y∈V(G):d(x,y) est paire} et V={z∈V(G):d(x,z) est impaire}
S’il existe y1,y2∈Utel que y1y2∈E(G), alors on a :
W1=<x,..., y1>est une chaîne de longueur paire =2k1
W2=<x,..., y2>est une chaîne de longueur paire =2k2
=⇒ W3=<x,..., y1,y2,..., x>est un cycle de longueur impaire =2k1+2k2+1/exclamati⌢n-triangle
Donc G=U˙∪Vest un graphe biparti.
Exercice 2.2
Vérifier si le graphe maison est un graphe biparti. Faire de même pour la grille G4,4.
maison grille
2.2 Graphe connexe, eulérien, hamiltonien
Définition 2.2: Graphe connexe
Un graphe est dit connexe si deux points peuvent toujours être joints par une chaîne, i.e.
∀x,y∈V(G),d(x,y)< ∞
— Une composante connexe d’un graphe est un sous-graphe induit maximal connexe.
— Un point d’articulation d’un graphe est un sommet dont la suppression augmente le nombre de
composantes connexes.
Par exemple, le graphe suivant :14 Chapitre 2. La connexité
a
 b
d
 c
e
f
 g
n’est pas connexe car il n’existe pas de chaîne entre les sommets aete. On a donc 2 composantes connexes. En
revanche, le sous-graphe induit par les sommets { a,b,c,d} est connexe dont aest le seul point d’articulation.
Remarque 5.
1. Un graphe connexe à n sommets possède au moins n −1arêtes ( faite une preuve par récurrence ).
2. L’algorithme de parcours en profondeur permet de déterminer si un graphe est connexe ou non.
3. Même définitions dans un graphe orienté . Graphe orienté (fortement) connexe et de composante connexe .
Définition 2.3: Graphe eulérien
— Une chaîne joignant deux sommets xetyest dite chaîne eulérienne si elle emprunte chaque arête
deGune et une seule fois. On parle de chemin eulérien dans le cas d’un graphe orienté.
— Un cycle eulérien est une chaîne eulérienne dont les extrémités coïncident. Un graphe qui admet
un cycle (resp. circuit) eulérien est dit graphe eulérien .
/flushedRemarquer qu’un cycle eulérien n’est pas forcément un cycle comme définit dans la définition 2.1
Si un graphe (ou multigraphe) Gpossède une chaîne eulérienne, alors soit Gpossède deux sommets impairs, le
début et la fin de cette chaîne, soit Gn’a aucun sommet impair, et la promenade d’Euler commence et se termine
au même point (cycle eulérien). Une autre condition nécessaire évidente est que Gdoit être connexe. Ces deux
conditions sont ensemble suffisantes.
Théorème 2.3 Euler
Soit Gun graphe (multigraphe) connexe.
— Si Gn’a pas de sommets impairs, alors il possède un cycle eulérien (commençant à n’importe quel
point).
i.e.∀x,d(x)≡0 mod 2 =⇒ Gest un graphe eulérien.
— Si Ga deux sommets impairs, alors il possède une chaîne eulérienne dont le début et la fin sont les
sommets impairs.
La réciproque est aussi vraie.
Preuve.
⇐On commence par la réciproque. S’il existe une chaîne eulérienne µ(x,y), alors on peut crée une arête fictive
e=(y,x) et par la suite on obtient un cycle eulérien. Donc il suffit de montrer que si Gadmet un cycle
eulérien alors tous les sommets sont de degré pair.
Soit W=< v1,v2,..., vn,v1>un cycle eulérien. Soit le sommet vjavec j̸=1, il est donc claire que chaque
fois vjapparaît dans W, il ya deux arcs distincts incidents en vj( (•,vj) et ( vj,•)). Comme toutes les arêtes
sont utilisées, on voit que d(vj) est pair. Même chose pour v1car on ajoute deux arcs ( v1,v2) et ( v1,vn).
⇒On suppose que tous les sommets sont de degré pair. Montrons que Gadmet un cycle eulérien. Puisque
tous les sommets sont de degré pair on peut construire d’abord une chaîne simple fermée (quelconque)
W1=<v1,v2,..., vk,v1>
SiW1contient chaque arête de G, alors c’est finis, c’est un cycle eulérien. Sinon (puisque Gest connexe), il
existe une arête e=(vi,c) qui n’est pas dans W1(avec visommet de W1). On pose le sous-graphe
G′=G−{ arêtes de W1}H. SABRI 15
Il est donc claire que les sommets de G′sont aussi de degré pair. Alors, par la même procédure on construit
une chaîne simple fermée dans G′de la forme : <vi,c,d,..., vi>et par la suite on insère cette chaîne dans
W1pour obtenir :
W2=<v1,v2,..., vi,c,d,..., vi,vi+1,..., vk,v1>
Sil(W2)< |E(G)|, on construit W3de longueur plus grand. Ainsi, on a :
l(W1)<l(W2)<l(W3)< ··· ≤ | E(G)|
Donc, nécessairement, il existe Wk(chaîne simple fermée de longueur |E(G)|) donc c’est un cycle eulérien.
Finalement , si∃a,b∈V(G):d(a)≡d(b)≡1 mod 2, et tous les autres sommets sont de degré pair, alors on
pose :
G′=G+{a,b}
et donc tous les sommets de G′sont de degré pair. Avec la construction précédente, il existe un cycle eulérien
dans G′:
W=<a,b,v1,..., a>
est donc la chaîne <b,v2,..., a>est une chaîne eulérienne dans G.
Algorithme 1 : Euler
Entrées : Gun graphe eulérien
Output : Un cycle eulérien W
/* On suppose que G est eulérien, i.e. les sommets sont de degré pair */
1Gaux←G;W←µ(v,v) une chaîne simple (quelconque) de G; // Initialisation
2tant que l(W)<e(G)faire
3 Gaux←G−{ arêtes de W} ;
4 Choisir ( x,c)∈E(Gaux) tel que x∈W;
5 L←< x,c,..., x>une chaîne simple de Gaux ;
6 Dans W, remplacer (juste ce) xpar la séquence L;
7fin
8retourner W;
Exercice 2.3
1. Montrer que le graphe de l’exercice 2.1 est un graphe eulérien et donner un cycle eulérien.
2. Tracer cette maison d’un seul trait.
Remarque 6. Le théorème d’Euler dans un graphe orienté connexe s’écrit :
Admet un circuit eulérien si, et seulement si, pour tout sommet, le degré entrant est égal au degré sortant.
∀v∈V(G),d+(v)=d−(v)
Admet un chemin eulérien de a vers b si, et seulement si,


d+(v)=d−(v) ;∀v̸=a,b,
d−(a)=d+(a)−1
d−(b)=d+(b)+116 Chapitre 2. La connexité
Définition 2.4: Graphe hamiltonien
Soit Gun graphe connexe d’ordre n. On appelle :
1. On appelle cycle hamiltonien deGun cycle passant (une et une seule fois) par chacun des sommets
deG. Un graphe est dit hamiltonien s’il possède un cycle hamiltonien.
2. Une chaîne hamiltonienne est une chaîne passant une et une seule fois par chacun des sommets de
G. Un graphe ne possédant que des chaînes hamiltoniennes est semi-hamiltonien .
3. Dans un digraphe, on change cycle par circuit et chaîne par chemin .
Remarque 7.
— Une chaîne hamiltonienne est une chaîne élémentaire de longueur n −1.
— Un graphe peut être eulérien, hamiltonien, les deux à la fois, ou aucun des deux.
— De nombreux problèmes concrets peuvent être formulés en termes de recherche de parcours hamiltoniens : pro-
blème du voyageur de commerce (chercher un cycle hamiltonien de longueur totale minimale), l’ ordonancement
de tâches .
— Le problème du chaîne hamiltonienne est un problème NP-complet .
Exercice 2.4
Donner un graphe (connexe, simple) qui soit :
1. hamiltonien et eulérien.
2. hamiltonien et non eulérien.
3. eulérien et non hamiltonien.
4. non hamiltonien et non eulérien.
Aucune condition nécessaire et suffisante adéquate n’est connue pour l’existence de cycles hamiltoniens. Le
résultat suivant constitue une condition suffisante utile.
Théorème 2.4 Ore
Soit Gun graphe simple d’ordre n≥3. Si pour toute paire { x,y} de sommets non adjacents, on a d(x)+d(y)≥
n, alors Gest hamiltonien.
Preuve. On suppose que le théorème est faux. Alors, il existe un graphe Gsimple d’ordre nnon hamiltonien tel que
d(u)+d(v)≥npour tout sommets non adjacents uetv. On prend Gun tel graphe d’ordre nde taille maximale qui
vérifie cette propriété (remarquer que le graphe complet Knest hamiltonien).
Soient uetvdeux sommets non adjacents de G. Par maximalité de G, le graphe G+uv(d’ordre n) doit être
hamiltonien. Donc il existe dans G+uvun cycle hamiltonien :
W=<u,x1,x2,..., xn−2,v,u>
u
x1
xi xi+1xn−2
v
... ...
Or, si uxi+1∈E(G) etv xi∈E(G) (les arcs en rouge), alors on peut construire dans Gle cycle hamiltonien :
<u,x1,x2,..., xi,v,xn−2,..., xi+1,u>H. SABRI 17
Ceci est absurde car Gest non hamiltonien. Donc si xi+1est un sommet voisin à u, alors le sommet xin’est pas
voisin de v:
xi+1∈Γ(u)=⇒ xi∉Γ(v)
Donc :
d(u)= |Γ(u)| =p=⇒ d(v)≤(n−1)−p
et par la suite
d(u)+d(v)≤n−1
ce qui absurde par hypothèse. Donc Gest hamiltonien.
Une conséquence immédiate est le théorème de Dirac :
Proposition 2.1 Dirac
Soit Gun graphe simple d’ordre n≥3. Si pour tout sommet xdeG, on a d(x)≥n
2, alors Gest hamiltonien.
2.3 Arbres
Définition 2.5: Arbres et forêts
On appelle arbre tout graphe (non orienté) connexe et acyclique . Les composantes connexes dans un
graphe acyclique sont des arbres et le graphe est dit forêt . Une feuille ou sommet pendant est un som-
met de degré 1.
Un forêt avec deux arbres
Un graphe Gest une arborescence s’il existe un sommet Rappelé racine deGtel que, pour tout sommet
SdeG, il existe un chemin et un seul de Rvers S. Donc, c’est un arbre orienté dans lequel on choisit un
sommet Rcomme racine et on dirige les arcs vers le sens sortant de la racine.
Remarque 8.
— Un graphe G d’ordre n est un arbre ssi G est sans cycle et possède n −1arêtes.
— Un graphe G d’ordre n est un arbre ssi G est connexe et possède n −1arêtes.
— G est un arbre si pour chaque paire u ,v de sommets distincts est reliée par une seule chaîne (donc chaîne
élémentaire d’après le théorème 2.1).
— Un arbre (ou forêt) est nécessairement un graphe simple.
Pour démontrer les remarques précédentes, il suffit de prouver le théorème suivant :
Théorème 2.5
Soit Gun graphe ayant marêtes, nsommets et pcomposantes connexes, on définit nu( G) :
ν(G)=m−n+p
Alors, on a :
1.ν(G)≥0.
2.ν(G)=0⇐⇒ Gest acyclique.18 Chapitre 2. La connexité
Preuve. Par récurrence sur la taille mdu graphe. Le résultat est évident pour m=0 et m=1. On suppose le résultat
est vrai pour les graphe de taille m, et montrons que ceci est vrai pour un graphe de taille m+1. Soit donc Gun
graphe d’ordre nde taille m+1 ayant pcomposantes connexes.
•On suppose que Gest un graphe acyclique. Soit uvune arête de Gdans la composante C. Si on supprime uv,
la composante Cse transforme en deux composantes connexes (sinon on a un cycle dans G). Par la suite,
le graphe G′=G−uvest un graphe acyclique d’ordre n, de taille met ayant p+1 composantes connexes.
Donc d’après l’hypothèse de récurrence :
ν(G′)=0=(m−1)−n+(p+1)=m−n+p=ν(G)
•Maintenant, si Gcontient un cycle Wdans la composante connexe C. Soit uvune arête de W, alors si on
supprime l’arête uv, la composante Creste connexe. Donc le graphe G′=G−uvest un graphe d’ordre nde
taille m−1 ayant pcomposantes connexes. Donc, d’après l’hypothèse de récurrence :
ν(G′)=(m−1)−n−p≥0
=⇒ν(G)=m−n−p≥1>0
D’où le résultat – car si ν(G)=0,Gne peut être que acyclique, sinon 0 =ν(G)≥1/exclamati⌢n-triangle
2.3.1 Codage et décodage d’un arbre – Prüfer code
Soit Tun arbre ayant nsommet numérotés {1,2,..., n}. Le codage de Prüfer représente l’arbre Tarbre de avec
une suite P=(x1,x2,x3,..., xn−2) de n−2 termes (les n° des sommets avec répétition possible). Une suite Pdonnée
correspond à un et un seul arbre numéroté. Voici les algorithmes de codage et de décodage.
Algorithme 2 : Codage de Prüfer
Entrées : Un arbre T
Output : Séquence de Prüfer P
1P←() ; // Initialisation de P comme séquence vide
2tant que v(T)>2faire
3 x←feuille de Tayant le n° minimum ; // donc d(x)=1
4 P←(P,s) où sest le seul (n°) sommet adjacent à x;
5 T←T−x;
6fin
7retourner P;
Example 2.2
Donner le code de Prüfer de l’arbre :
126 345
Indice : on trouve, P=(2,3,3,2)
Pour faire la réciproque, étant donnée une séquence P=(x1,x2,..., xn−2) où les xi∈{1,2,..., n}, on construit
l’arbre Tdont les sommets sont {1,2,..., n} avec l’algorithme suivant (le décodage) :H. SABRI 19
Algorithme 3 : Décodage de Prüfer
Entrées : Une séquence Pde taille n−2
Output : L ’arbre Tcorrespondante
1I←{1,2,..., n};
2T←graphe tel que V(T)=IetE(T)= ; ; // T graphe à n sommets isolés
3tant que P̸=()faire
4 i←min {x∈I:x∉P};
5 T←T+(i,P[1]) ; // ajouter l'arc (i,P[1])
6 P←P−P[1];I←I−{i};
7fin
8T←T+(a,b) ; // a,b sont les deux éléments restant dans I
9retourner T;
Example 2.3
Donner l’arbre dont le code de Prüfer est : P=(2,3,3,3)
Puisqu’il ya une bijection entre les arbres d’ordre net les suites Pde longueur n−2 à coefficients dans {1,2,..., n},
on déduit le théorème de Cayley :
Théorème 2.6 Formule de Cayley
Le nombre d’arbres que l’on peut construire sur n(n≥2) sommets numérotés est égal à nn−2.
2.3.2 Arbre couvrant de poids minimum – ACM
Soit Gun graphe (non orienté). Un arbre couvrant (spanning tree) TdeGest un sous graphe couvrant de G
tel que Test un arbre. Remarquer que, Gdoit être connexe, sinon un arbre couvrant de Gn’existe pas. Le nombre
des arbres couvrant de Gest noté a(G). Remarquer que a(Kn)=nn−2(le nombre de Cayley). Un problème algo-
rithmique classique est de trouver, dans un graphe valué , un arbre couvrant de poids minimal . On dispose de
plusieurs algorithmes (l’algorithme de Prim, l’algorithme de Kruskal ...).
Algorithme 4 : Kruskal
Entrées : Un graphe Gvalué d’ordre net de taille m
Output : Arbre (ou forêt) couvrant de poids minimum
1Numéroter les arêtes de Gpar poids minimum : w(e1)≤w(e2)≤ ··· ≤ w(em)
2T←graphe tel que V(T)=V(G) etE(T)= ; ; // T graphe à n sommets isolés
3k←0;
4tant que k<m et e (T)<n−1faire
5 siT+ek+1est acyclique alors
6 T←T+ek+1;
7 k←k+1;
8fin
9retourner T;
Appliquer l’algorithme de Kruskal dans le graphe suivant :
CHAPITRE 3
Les algorithmes de base
Beaucoup de problèmes sur les graphes nécessitent que l’on parcourt l’ensemble des sommets et des arcs. Par
exemple, pour vérifier que le graphe est connexe, chercher un sommet particulier, construire un arbre couvrant,
trouver un plus court chemin ...etc.
3.1 Parcours en profondeur (DFS) / largeur (BFS)
Une manière simple de tester si un graphe Gest connexe ou non est d’exécuter l’algorithme DFS ouBFS dans
Gen commençant par n’importe quel sommet et en enregistrant les sommets visités pendant l’exécution dans une
liste. Si la liste contient tous les sommets de G, alors Gest connexe. Une petite modification permet de donner les
composantes connexes de G. L ’algorithme DFS_Component suivant donne les composantes connexes de G. Il est
donné sous forme d’implémentation récursive.
Algorithme 5 : DFS_Component
Entrées : Un graphe G=(V,E)
Output : Les composantes connexes C=(C1,C2,..., Ck) de G.
1VisitedNodes ← ; ;
2k←0 ; // k est le nombre des composantes connexes
3pour chaque u∈Vfaire
4 siu∉VisitedNodes alors
5 k←k+1;
6 DFS( u);
7 fin
8fin
9retourner (C1,C2,..., Ck);
1Procedure DFS( u )
2 VisitedNodes ←VisitedNodes ∪{u};
3 Ck←Ck∪{u};
4 pour chaque x∈Γ(u)faire
5 six∉VisitedNodes alors
6 DFS( x);
7 fin
8 fin
Note : -
Il est possible de d’implémenter la procédure DFS itérativement à l’aide d’une pile LIFO (stack) contenant les
sommets à explorer : on désempile un sommet et on empile ses voisins non encore explorés.
20H. SABRI 21
Pseudocode :
stack . push ( root )
while stack . isEmpty ( ) = f a l s e do
node = stack . pop ( ) // so mark i t as v i s i t e d
for each x in node . childNodes do
i f x i s not v i s i t e d then
stack . push ( x )
. . .
endfor
endwhile
Example 3.1 (DFS )
Ici on empile (gris) les sommets les plus à droite, alors l’ordre des sommets visité (noir) est ( a,b,d,e,g,c,f).
Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b
 c
d
 e
f
g
a
b
 c
d e
f
ga
b
 c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g
L ’utilisation d’une file (FIFO) au lieu d’une pile transforme l’algorithme du parcours en profondeur en algo-
rithme de parcours en largeur ( BFS ). Avec BFS l’exemple précédent devient (en enfile le plus à gauche) :
Example 3.2 (BFS )
Ici, avec BFS, on enfile (gris) les sommets les plus à gauche d’abord, alors l’ordre des sommets visité (noir)
est ( a,b,d,e,g,c,f). Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b c
d
 e
f
g
a
b c
d
 e
f
ga
b c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g22 Chapitre 3. Les algorithmes de base
Exercice 3.1
1. Écrire la procédure BFS .
2. Utiliser DFS (ou BFS) pour la construction d’un arbre couvrant d’un graphe connexe. L ’appliquer
pour le graphe triangle.
3. Utiliser DFS pour écrire une procédure DFS_Cycle pour détecter un cycle dans un graphe.
On sait qu’un graphe orienté G=(V,E) est fortement connexe si pour chaque paire de sommets u,v∈V, il
existe un chemin de uàvet il existe un chemin de vàu. En d’autres termes, nous avons besoin d’une connectivité
dans les deux directions .
Une procédure pour tester si un graphe orienté est fortement connexe ou non peut être conçue avec l’idée
suivante. En partant d’un sommet arbitraire vdu graphe G, on exécute l’algorithme BFS ouDFS et l’on note les
sommets visités. Ensuite, on obtient la transposée de G,GT, en inversant la direction des arêtes de G, et l’on
exécute à nouveau l’algorithme BFS ou DFS à partir du sommet v. Si les sommets visités dans les deux cas sont
égaux à V, alors le graphe orienté est fortement connexe. Cette méthode est illustrée dans l’algorithme 6.
Algorithme 6 : Fortement_connexe
Entrées : Un graphe orienté G=(V,E)
Output : true siGest fortement connexe et false sinon
1X← ; ;
2Y← ; ;
3v←un sommet quelconque de V;
4X←DFS( G,v) ; // Enregistrez les sommets visités dans X
5GT←Gavec flèches inversées;
6Y←DFS( GT,v);
7siX=Y=Valors
8 retourner TRUE.
9sinon
10 retourner FALSE.
11fin
3.2 Recherche des chemins
3.2.1 Matrice d’adjacence et nombre de chemins
La puissance de la matrice d’adjacence Amontre qu’il y a des chemins (ou chaînes) de longueur kallant de xà
ycomme le montre le théorème suivant.
Théorème 3.1
Soit G=(V,E) un (di)graphe. On note V={1,2,..., n} et Asa matrice d’adjacence et Akla puissance k-ème
deA. Alors le terme d’indices i,jdeAkest le nombre de chemins (chaînes) de longueur kallant de iàj.
Preuve. Par récurrence sur k. Pour k=1 c’est clair. On suppose le résultat est vrai à l’ordre ket montrons qu’elle
est vrai pour k+1. Soit S=(si,j)=Ak. Si on a un chemin de iàjde longueur k+1, alors on va d’abord de ià un
sommet ravec kpas et puis de ràj. Or d’après l’hypothèse de récurrence on a si,rchemins possibles pour aller de
iàret finalement ar,jpas (1 ou 0) pour aller de ràj. Ainsi, le nombre totale possibles (i.e. tous les sommets r) est :
nX
r=1si,rar,j=³
Ak×A´
i,jH. SABRI 23
ce qui est bien le terme ( i,j) de la matrice Ak+1.
3.2.2 Plus court chemin et l’algorithme de Dijkstra
Dans cette partie on suppose que le (di)graphe G=(V,E,w) est valué positivement (i.e.∀e∈E,w(e)>0). Notre
objectif est de chercher un plus court chemin (i.e., un chemin de poids minimal ) d’un sommet ufixé à un sommet
quelconque de G.
Il est clair que l’on peut restreindre ce problème au cas d’un (di)graphe simple1. On suppose aussi que Gest
connexe (sinon, certains trajets sont impossibles). Il est aussi claire (d’après théorème 2.1), qu’un plus court chemin
est nécessairement un chemin élémentaire (path).
L ’algorithme de Dijkstra (1959) permet de calculer le plus court chemin entre un sommet particulier u(racine )
et tous les autres sommets. L ’algorithme fonctionne de la manière suivante :
Pour tout sommet vdeG, on associe une valeur T(v), initialisée à w(u,v) et une liste de sommets C(v) qui
correspond à un chemin de uàv. À la fin de l’algorithme, T(v) contient le poids minimal des chemins joignant uà
v(ou T(v)= ∞ siu↛v) et la liste C(v) réalise un tel chemin. Voici donc l’algorithme de Dijkstra :
Algorithme 7 : Algorithme de Dijkstra
Entrées : Un (di)graphe valué G=(V,E,w) et un sommet racine u
Output : Le coût minimum d’un chemin de uàv(∀v∈V) et un trajet pour chaque coût minimal obtenu
1∀v∈V,T(v)←w(u,v) etC(v)←(u,v); // Initialisation de T(v) et la liste C(v)
2X←{u};
3tant que X̸=Vfaire
4 Choisir v∈V−Xtel que ∀y∈V−X,T(v)≤T(y);
5 X←X∪{v};
6 pour chaque y∈V−Xfaire // Faire les mises à jours pour les autres sommets
7 siT(y)>T(v)+w(v,y)alors
8 T(y)←T(v)+w(v,y);
9 C(y)←[C(v),y]; // On ajoute à la liste C(v) l'élément y
10
11 fin
12 fin
13fin
Example 3.3
Voici une application de l’algorithme de Dijkstra au digraphe suivant. On prend Ecomme sommet racine.
EA
B
CD
FG
S5
4
21
12
2
34
4
215
7
1. En effet, passer par une boucle ne ferait qu’augmenter inutilement le poids de ce chemin. De même, si plusieurs arcs joignent deux
sommets, il suffit de conserver l’arc de poids minimal.24 Chapitre 3. Les algorithmes de base
Ainsi, pour l’initialisation, on a : X={E} et on a les valeurs :
v  E A B C D F G S
T(v) 0 5 4 2 ∞ ∞ ∞ ∞
C(v)(E,E) ( E,A) ( E,B) ( E,C) ( E,D) ( E,F) ( E,G) ( E,S)
Maintenant, on choisit (un seul choix) le sommet C, donc X={E,C}. Le tableau est mis à jour :
v  E A B  C D F G S
T(v) 0 5 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À l’étape suivante, on est forcé de choisir B. Ainsi, X={E,C,B} et la mise à jour est :
v  E A  B  C D F G S
T(v) 0 4 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À présent, on a le choix entre AetF. On choisit A. Donc X={E,C,B,A} et on a :
v  E  A  B  C D F G S
T(v) 0 4 3 2 6 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,B,A,D) ( E,C,F) ( E,C,G) ( E,S)
Puis, on prend le sommet F. D’où X={E,C,B,A,F} et :
v  E  A  B  C D  F G S
T(v) 0 4 3 2 5 4 5 11
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,S)
On prend Det on obtient X={E,C,B,A,F,D} et :
v  E  A  B  C  D  F G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Finalement, on prend Gpuis Set on voit que ceci ne change rien. D’où le tableau finale :
v  E  A  B  C  D  F  G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Ainsi le chemin minimum pour aller de EàSest de coût 10 et un trajet de coût minimal de EàSest : EC F DS .H. SABRI 25
3.3 Problèmes d’ordonnancement et chemin critique
Un problème d’ordonnancement peut-être représenté sous la forme d’un digraphe. Les sommets sont des évé-
nements (début et fin de la tâche) et les arcs des tâches, La longueur (ou poids) de chaque arc représente la durée
d’exécution de la tâche. Ainsi, la tâche correspondant à l’arc ( i,j) ne peut commencer que si toutes les tâches cor-
respondant à des arcs ( k,i) ont été complétées. On ajoute deux sommets pour le début (s) et de fin(t) du projet .
Le digraphe peut contenir des tâches fictives dedurée nulle afin de forcer certaines précédences (postériorité).
Ainsi, un réseau PERT est un digraphe valué G=(V,E,w,s,t) où la fonction poids (ou longueur) w:E→R+
etsle sommet source (début) et tle sommet puits (fin). Un chemin critique est un chemin de sàtdelongueur
maximale . S’il n’existe pas de chemin critique, le projet n’est pas réalisable (e.g. un circuit). Le temps minimal
requis pour l’exécution d’un projet réalisable est égal à la longueur d’un chemin critique. Les tâches figurant sur un
chemin critique sont aussi appelées critiques, ce qui s’explique par le fait que tout retard d’exécution d’une tâche
critique retarde d’autant l’exécution du projet.
3.3.1 Algorithmes de tri topologique et de chemin critique
Il faut d’abord numérotés les sommets de 1 à nde manière compatible au pré-ordre (rang) avec l’algorithme du
rang suivant (tri topologique) :
Algorithme 8 : Algorithme du rang
Entrées : Un digraphe G=(V,E) sans circuit
Output : Le rang r(v) de chaque sommet v∈Vde G
1r←0;X←V;
2R←{v∈X:Γ−
X(v)= ;} ; // l'ensemble des sommets de X sans prédécesseur dans X
3tant que X̸= ; faire
4 r(v)←rpour chaque sommet v∈R;
5 X←X−R;
6 R←l’ensemble des sommets de Xsans prédécesseur dans X;
7 r←r+1;
8fin
On supposera dorénavant que les sommets ont déjà été numérotés de 1 à nde manière compatible avec leurs
rangs, c’est-à-dire que r(j)>r(i) implique j>i(donc 1 =setn=t). Enfin, on supposera éliminés les arcs paral-
lèles par l’introduction de tâches fictives de durée nulle .
Pour un sommet i, on note tiledébut au plus tôt des tâches correspondant aux arcs i→jet par Tilafin au
plus tard des tâches correspondant aux arcs j→i.
Algorithme 9 : Algorithme du chemin critique
Entrées : Un digraphe G=(V,E) sans circuit trié topologiquement
Output : La durée du chemin critique et les dates ti,Ti
1t1←0;
2pour j=2···nfaire // Calcul des dates de début au plus tôt  récurrence en avançant
3 tj←max i∈Γ−(j){ti+w(i,j)}
4fin
5Tn←tn;
6pour j=n−1···1faire // Calcul des dates de fin au plus tard  récurrence en reculant
7 Tj←min i∈Γ+(j){Ti−w(j,i)}
8fin26 Chapitre 3. Les algorithmes de base
Définition 3.1
— Un sommet iest critique si ti=Ti.
— Un arc ( i,j) est critique les sommets ietjsont critiques ettj−ti=w(i,j).
— Un chemin critique est un chemin de 1 à nn’utilisant que des arcs critiques.
— La durée du chemin critique est donnée par Tn(ou par tn). Elle correspond à la durée minimale du
projet .
Example 3.4
L ’application de l’algorithme du chemin critique au digraphe suivant (trié topologiquement) est :
1 23
45
6B
9A
3
C
5D
8
E
4
F7G
20
H6I5
=⇒
 1
0,02
9,933,16
4
16,23513,24
6
29,29B
9A
3
C
5D
8
E
4
F7G
20
H6I5
Les tâches critiques sont BetG. La durée totale minimale du projet est donc 29.
Exercice 3.2
Les tâches ( durée et précédences ) pour la construction d’un entrepôt sont données dans le tableau suivant :
Tâches Nature Précédences Durée (jours)
A Acceptation des plans par le propriétaire – 4
B Préparation du terrain – 2
C Commande des matériaux A 1
D Creusage des fondations A, B 1
E Commande des portes et fenêtres A 2
F Livraison des matériaux C 2
G Coulage des fondations D, F 2
H Livraison des portes et fenêtres E 10
I Pose des murs, de la charpente et du toit G 4
J Mise en place des portes et fenêtres H, I 1
1. Représentez le graphe des précédences de ce projet (trié topologiquement).
2. Déterminez une durée totale minimale en exhibant un chemin critique dans ce graphe.CHAPITRE 4
Programmation linéaire
La programmation linéaire est le processus de minimiser ou maximiser une fonction objective linéaire sou-
mise à un nombre fini de contraintes d’égalités et d’inégalités linéaires.
La programmation linéaire a de nombreuses applications dans le domaine de l’informatique théorique. Elle
peut être utilisée pour résoudre de nombreux problèmes combinatoires variés, tels que la recherche de flot maxi-
mum dans un réseau, la recherche d’un couplage maximal dans un graphe et la coloration d’un graphe parfait.
Example 4.1 (Problème de régime)
On suppose qu’on a quatre plats : de la truite ( XT), un sandwich au corned-beef ( XC B), un burrito ( XBU R )
et un hamburger ( XHB). Le tableau suivant répertorie la valeur nutritionnelle de chaque plat (vitamines et
calories) et notre besoin journalier des vitamines.
Vit. A Vit. C Vit. D Calories
Truite 203 92 100 600
Corned-beef 90 84 230 350
Burrito 270 80 512 250
Humburger 500 90 210 500
Besoins 2000 300 430
Notre objectif est de minimiser le nombre total de calories consommées : 600 XT+350XC B+250XBU R+
500XHBtout en satisfaisant les trois besoins nutritionnels en vitamines. Le programme linéaire résultant
s’écrit :
min 600 XT+350XC B+250XBU R+500XHB
s.t. 203 XT+90XC B+270XBU R+500XHB≥2000, (Besoins de Vit. A),
92XT+84XC B+80XBU R+90XHB≥300, (Besoins de Vit. C),
100XT+230XC B+512XBU R+210XHB≥430, (Besoins de Vit. D),
XT,XC B,XBU R ,XHB≥0
Définition 4.1: Forme canonique – Forme standard
On peut écrire un P .L. sous deux formes spéciales :
•Canonique
max
mincTX+c0
s.t. AX≤b(≥bsi min),
X≥0•Standard
max cTX+c0
s.t. AX=b,
X≥0Avec :
cTX=¡
c1··· cn¢
x1
...
xn

cTX+c0=c1x1+c2x2+···+ cnxn+c0
2728 Chapitre 4. Programmation linéaire
Remarque 9. Un P .L. général peut être formulé selon une forme standard ou canonique par la méthode suivante :
générale =⇒ standard il faut éliminer les contraintes d’inégalité et les variables sans contrainte de positivité.
— Si dT
iX≤biest une contrainte d’inégalité, alors créer une nouvelle variable ( d’écart ) siet remplacer l’in-
égalité dT
iX≤bipar dT
iX+si=biet s i≥0.
Si dT
iX≥bi, alors on peut écrire dT
iX−si=biet s i≥0.
— Si une variable x i≶0est de signe quelconque, alors créez deux nouvelles variables x+
iet x−
iet remplacez
xipartout par x+
i−x−
i, et ajoutez les contraintes de signe : x+
i≥0,x−
i≥0.
générale =⇒ canonique
— Si dT
iX=biest une contrainte d’égalité, alors remplacer cette égalité par une paire d’inégalités :
dT
iX≥biet−dT
iX≥ −bi
— Même chose que précédemment si la variable x i≶0.
Il est facile de voir que les problèmes qui en résultent sont équivalents aux problème d’origine. Pour l’algorithme
simplexe , nous utiliserons la forme standard .
On remarque aussi qu’en utilisant la relation min f(x)= − max¡
−f(x)¢
dans laquelle f (x)représente la fonction-
nelle linéaire à optimiser, on peut toujours se ramener à un problème de minimisation (ou de maximisation).
Example 4.2
Le P .L :max 5 x+4y
s.t. x≤6
1
4x+y≤6
3x+2y≤22
x,y≥0s’écrit sous forme standard :max 5 x1+4x2
s.t. x1+e1=6
1
4x1+x2+e2=6
3x1+2x2+e3=22
x1,x2,e1,e2,e3≥0
Donc (sous la forme matricielle) on a :
cT=¡
5 4 0 0 0¢
;A=
1 0 1 0 0
1
41 0 1 0
3 2 0 0 1
;X=
x1
x2
e1
e2
e3
et b=
6
6
22

4.1 La méthode simplexe
4.1.1 Solution de base admissible
On suppose que la matrice Adu programme linéaire est de type m×netde rang m(pourquoi !). Soit Bla
matrice carrée extraite de Aformée par les mcolonnes j1,j2,..., jmlinéairement indépendants de A(les vecteurs
de base). Alors, Best une matrice inversible. Ainsi si on pose xl=0 sil∉{j1,..., jm} etxjklak-ième composante de
B−1b. Alors, on a AX B=b. Si de plus XB≥0(i.e. chaque xi≥0), alors :
Xest une solution de base admissible (ou réalisable)
Dans l’exemple 4.2, la matrice extraite B=
1 0 0
0 1 0
0 0 1
est inversible et B−1b=
6
6
22
. Donc XB=
0
0
6
6
22
≥0, par suite
XBest une solution de base admissible. On appelle les variables xjklesvariables de base . Les autres variables xl
sont les variables hors-base .
Parfois, il n’est pas évident de trouver une solution de base admissible, comme le montre l’exercice suivant :H. SABRI 29
Exercice 4.1
Écrire le programme linéaire suivant sous forme standard et montrer qu’on n’a pas une solution de base
admissible. Résoudre le programme linéaire.
max −x+y
s.t. x+y≥1,
3x+2y=6,
x,y≥0
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux
Dans cette section, on suppose qu’on a déjà trouvé une solution de base admissible X(produite avec B=Im)
du programme linéaire ( P: max z=cTX+c0etb≥0pour garantir que 0est une solution de AX≤b).
La méthode du simplexe est une méthode itérative qui génère une séquence de solutions de base réalisable
(correspondant à différentes bases) et s’arrête finalement lorsqu’elle a trouvé une solution de base réalisable opti-
male. Remarquer qu’on peut toujours prendre c0=0.
Algorithme 10 : Algorithme du simplexe
Entrées : Un P .L. standard P(max) avec une solution de base réalisable
Output : La solution optimale (ou non)
1On commence à écrire le tableau initiale (avec les variables de base xj1,..., xjm)
VB x1 ... xn b
xj1 b1
... A...
xjm bm
c1 ... cn−c0
2Sicj≤0 (∀j:xjest hors base), alors solution optimale (STOP) // min ⇝cj≥0
3Trouver la colonne s(hors base) tel que cs=max©
cj:cj>0ª// min ⇝cs=min©
cj:cj<0ª
4Siai,s≤0∀i=1... m, alors pas de solution optimale (STOP)
5Min Ratio Test : trouver la ligne rtel que
br
ar,s=min
i=1...m½bi
ai,s:ai,s>0¾
6Appliquer la procédure de Gauss autour de pivot ar,s(ar,s⇝1 et on annule les coefficients situés sous et
sur le pivot dans la colonne s, par combinaisons de lignes) // Ne pas oublier la dernière ligne
7Remplacer (dans VB) la variable de base ( sortante ) située à la ligne rpar la variable ( entrante )xs
8Retourner à l’étape 2 // l'algorithme termine si le programme linéaire est non dégénéré
Remarque 10.
— La dernière ligne représente l’équation linéaire −z+c1x1+···+ cnxn= −c0.
— La valeur de la variable de base de V Bde la ligne k est égale à la valeur b k(de la ligne k).
— La solution optimale du problème est la valeur finale (dernière cellule) (×− 1).
— Si on n’a pas au départ B =Im(à l’aide des variables d’écart) alors, on ajoute les variables artificielles (et on
applique d’abord la phase I - voir section suivante).30 Chapitre 4. Programmation linéaire
Exercice 4.2
Soit le programme linéaire :
max 2 x1+x2
s.t. x1−x2≤3,
x1+2x2≤6,
−x1+2x2≤2,
x1,x2≥0
Rajouter les variables d’écart. Puis résoudre le problème par l’algorithme du simplexe.
Remarque 11. Vérifier le résultat de l’exercice précédent, par la méthode graphique.
4.1.3 Initialisation - Phase I du simplexe
Un programme linéaire est dit sous forme simpliciale si la matrice Acontient la matrice identité Imcomme
sous matrice. On suppose que le programme linéaire P, après la mise en forme AX=b, n’est pas simpliciale
(possible dans le cas de contraintes du type ≥ou du type =). Soit Bune matrice d’ordre mextraite de Ainversible
tel que B−1b≥0et soit XBla solution de base réalisable ( XB≥0etAX B=b), alors on peut changer l’équation
matricielle :
AX B=b
⇐⇒ (B−1A)XB=B−1b
⇐⇒ A∗XB=b∗
et la matrice A∗contient la matrice identité Imcomme matrice extraite ( B−1A=B−1(H|B)=¡
B−1H|Im¢
). Ainsi, on
peut appliquer directement l’algorithme 10 en remplaçant Apar A∗etbpar b∗. Cependant, cette méthode n’est
pas efficace, car il faut trouver une matrice extraite Bréalisable correspondante. Pour une matrice Ade type m×n,
il existe¡m
n¢
matrices extraites à tester !
L ’idée est d’ajouter des variables, dites artificielles w1,w2,..., wm, pour faire apparaître une forme simpliciale
du programme linéaire P: (AX=b). Mais, il faut que w1= ··· = wm=0. Donc, il faut minimiser d’abord le pro-
gramme linéaire P0suivant :
P0=min W=w1+···+ wm
s.t. (A|Im)×(x1...xnw1...wm)T=b
x1,..., xn,w1,..., wm ≥0
On exprime Wà l’aide des autres variables (hors base) et puis on applique l’algorithme du simplexe 10 pour P0
(phase I). À la fin, si on trouve que les wi=0, alors les variables de bases xj1,..., xjmforment une première base
admissible pour démarrer le simplexe pour le programme d’origine P.H. SABRI 31
Remarque 12. On ajoute la ligne de Z :c1 ... cn−c0dans le tableau du simplexe de P0(phase I) et on lui
applique les opérations élémentaire comme avec les autres lignes. À la fin de la phase I, on supprime les colonnes des
wiet la ligne de la fonction W . Finalement, on utilise ce tableau pour résoudre le problème initiale P.
Example 4.3
Soit le programme linéaire P:
min 6 x1+3x2
s.t. x1+x2≥1,
2x1−x2≥1,
3x2≤2,
x1,x2≥0sous forme standard (max)= = = = = = = = = = = = = = = = = = ⇒max Z= −6x1−3x2
s.t. x1+x2−e1=1,
2x1−x2−e2=1,
3x2+e3=2,
x1,x2,e1,e2,e3≥0
La matrice Aest :
A=x1 x2 e1 e2 e3

1 1 −1 0 0
2−1 0 −1 0
0 3 0 0 1
est par suite Pn’est pas sous forme simpliciale (il n’ ya pas de sous matrice I3). Donc on peut ajouter 2
variables artificielles pour construire le problème initiale P0:
max −w1−w2=3x1−e1−e2−2
s.t. x1+x2−e1+w1=1,
2x1−x2−e2+w2=1,
3x2+e3=2,
x1,x2,e1,e2,e3,w1,w2≥0dont le vecteur X=

0 x1
0 x2
0 e1
0 e2
2 e3
1 w1
1 w2est une solution de base réalisable.
Ainsi, on commence notre algorithme 10 pour le programme P0. Le tableau initial est :
x1 x2 e1 e2 e3 w1 w2 b

w1 1 1 −1 0 0 1 0 1
w2 2−1 0 −1 0 0 1 1
e3 0 3 0 0 1 0 0 2
W: 3 0 −1−1 0 0 0 2
Z:−6−3 0 0 0 0 0 0
Le pivot c’est a2,1donc x1est la variable entrante et w2est sortante. On obtient après pivotement le tableau :
L2←1
2L2− − − − − − − − →
L1←L1−L2
L4←L4−3L2
L5←L5+6L2x1 x2 e1 e2 e3 w1 w2 b

w1 03
2−11
20 1−1
21
2
x1 1−1
20−1
20 01
21
2
e3 0 3 0 0 1 0 0 2
W: 03
2−11
20 0−3
21
2
Z: 0 −6 0 −3 0 0 3 3
Le pivot est a1,2(Min ratio test =1
3). On obtient alors :32 Chapitre 4. Programmation linéaire
L1←2
3L1− − − − − − − − →
L2←L2+1
2L1
L3←L3−3L1
L4←L4−3
2L1
L5←L5+6L1x1 x2 e1 e2 e3 w1 w2 b


x2 0 1−2
31
302
3−1
31
3
x1 1 0−1
3−1
301
31
32
3
e3 0 0 2 −1 1 −2 1 1
W: 0 0 0 0 0 −1−1 0
Z: 0 0 −4−1 0 4 1 5
Ainsi, la phase I se termine avec W=0 et x1=2
3,x2=1
3,e3=1 et e1=e2=w1=w2=0. Le tableau pour la
phase II est donc :
x1 x2 e1 e2 e3 b


x2 0 1−2
31
301
3
x1 1 0−1
3−1
302
3
e3 0 0 2 −1 1 1
Z: 0 0 −4−1 0 5
On remarque donc que les cj≤0, donc (STOP) la solution est optimale et le max est −5. Ainsi la solution
optimale pour le programme P=min6 x1+3x2est−(−5)=5=6×2
3+3×1
3.
4.2 Dualité
SoitPun P .L. sous forme canonique. Le programme dualDdePest définit par :
P=max z=cTX
s.t. AX ≤ b
X≥ 0le dual est= = = = = = = ⇒D=min w=bTY
s.t. ATY≥ c
Y≥ 0
Le programme Pest dit primal . On remarque que si Ade type m×n, alors X∈RnetY∈Rmpour le dual.
Théorème 4.1 Théorème de dualité
Si un problème primal ou dual admet une solution, alors l’autre problème admet aussi une solution et on a :
max z=cTX =
s.t. AX ≤ b
X≥ 0min w=bTY
s.t. ATY≥ c
Y≥ 0
Exercice 4.3
Soit le problème suivant de type régime :
D=min w=340x1+2400 x2+560x3
s.t. x1+2x2+x3≥ 1200
x1+3x2+2x3≥ 1400
x1+x2+3x3≥ 1500
x1,x2,x3≥ 0
Écrire le programme primal PdeD. Résoudre le programme Pet déduire la valeur minimale de w, a-t-on
besoin de faire les deux phases du simplexe ?
7} A B oS



HOUSSEM SABRI
Graphes et Optimisation
2`emeannée
LISI  LSI
Institut Supérieur des Sciences Appliquées et de Technologie de Sousse
A.U. 2023-2024
28 novembre 2023Table des matières
1 Les graphes 3
1.1 Définitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.1 Graphes non orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.2 Graphes orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.2 Opérations et quelques types de graphes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.3 Représentation d’un graphe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.1 Listes d’adjacences (ou de succession) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.2 Matrices d’adjacence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.3.3 Matrice d’incidence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2 La connexité 11
2.1 Les chaînes et les cycles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.2 Graphe connexe, eulérien, hamiltonien . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.3 Arbres . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.3.1 Codage et décodage d’un arbre – Prüfer code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.3.2 Arbre couvrant de poids minimum – ACM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3 Les algorithmes de base 20
3.1 Parcours en profondeur (DFS) / largeur (BFS) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
3.2 Recherche des chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.1 Matrice d’adjacence et nombre de chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.2 Plus court chemin et l’algorithme de Dijkstra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
3.3 Problèmes d’ordonnancement et chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
3.3.1 Algorithmes de tri topologique et de chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . 25
4 Programmation linéaire 27
4.1 La méthode simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.1 Solution de base admissible . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux . . . . . . . . . . . . . . . . . . . . . . . . 29
4.1.3 Initialisation - Phase I du simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
4.2 Dualité . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
2CHAPITRE 1
Les graphes
L ’exemple classique pour introduire la théorie des graphes est le problème des ponts de Königsberg, étudié par
Euler en 1736. Quel itinéraire doit-on suivre pour traverser chaque pont exactement une fois? Une telle prome-
nade n’existe pas, et c’est Euler qui donna la solution de ce problème en caractérisant les graphes que l’on appelle
aujourd’hui eulériens .
A
B
Ce1 e2
e3 e4
De5
e6e7
FIGURE 1.1 – Les ponts de Königsberg
Les graphes introduisent une simplification : les régions se transforment en des "points" (aussi appelés noeuds
ousommet ), les ponts se transforment en des lignes (aussi appelées arêtes ouarcs ), et ce principe s’applique dès
lors qu’une relation existe entre des objets. Les graphes relèvent de la combinatoire plutôt que de la géométrie (les
intersections, les longueurs, et la forme des arêtes n’ont aucune importance, sauf en ce qui concerne la lisibilité de
la représentation).
1.1 Définitions
Dans la suite, il est toujours supposé que les graphes sont finis, sauf indication contraire.
1.1.1 Graphes non orientés
Définition 1.1: Graphe
Un graphe Gest un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V{2}des pairs non ordon-
nées de V.Vest l’ensemble des noeuds (Vertices en anglais) et Ec’est l’ensemble des arêtes de G(Edges en
anglais). Lorsque e={x,y} est une arête, on dit que x, y sont les extrémités de cette arête, que eest incidente
enxet en y. On joint x et y par un trait et on dit que x, y sont adjacents (ou voisins). On note aussi e=x you
encore e=(x,y) (attention , dans ce cas : ( x,y)=(y,x)).
SiGest un graphe alors, on note par V(G) l’ensemble de noeuds et par E(G) l’ensemble des arcs.
Remarque 1.
— Une arête e ={x,x}s’appelle boucle .
— Dans un graphe, il peut exister des arêtes parallèles (on parle donc de multigraphe ).
Dans l’exemple des ponts on a : e 1=e2=(A,B).
34 Chapitre 1. Les graphes
— Un graphe est dit simple s’il ne comporte ni arêtes multiples ni de boucles, c’est-à-dire chaque paire de nœuds
distincts est reliée par au plus une arête, ou encore E (G)⊆P2(G).
Dans la plupart des cas, les graphes sont considérés comme simples par défaut.
Définition 1.2: ordre – taille – degré
Soit G=(V,E) un graphe.
1. On appelle ordre d’un graphe noté v(G) le nombre de ses sommets :
v(G)= |V|
2. On appelle taille d’un graphe noté e(G) le nombre de ses arêtes :
e(G)= |E|
3. Le degré (ou valence) d’un sommet xnoté d(x) est le nombre d’arêtes contenant x. (Attention! Une
boucle sur un sommet compte double).
Si on note par Γ(x) l’ensemble des voisins de x, i.e.
Γ(x)={y∈V:x y∈E}
alors, siGest simple , on a :
d(x)= |Γ(x)|
Example 1.1 (Graphe complet)
Un graphe d’ordre nest dit complet noté Knsi chaque sommet du graphe est relié directement à tous les
autres sommets, i.e. E(Kn)=P2(V(Kn)).
Représenter graphiquement K3,K4,k5. Calculer la taille de K3,k4,...Kn.
Example 1.2 (Graphe biparti)
Un graphe G=(V,E) est dit biparti si son ensemble de sommets V=V1˙∪V2, i.e. peut être divisé en deux
sous-ensembles disjoints V1etV2tels que chaque arête ait une extrémité dans V1et l’autre dans V2.
Si∀x∈V1,∀y∈V2;x y∈E, alors Gest dit biparti complet noté Kn,moùn= |V1|etm= |V2|.
a1
 a2
 a3
 a4
b1
 b2
 b3
FIGURE 1.2 – Un graphe biparti
Théorème 1.1 Lemme des poignées de main – Handshaking lemma
Soit Gun graphe alors, on a :X
x∈V(G)d(x)=2e(G)
Dans ce théorème d(x) est le nombre de personnes à qui xserre la main et e(G) le nombre total de poignées
de mains.H. SABRI 5
Preuve.
•Méthode simple Il y en a d(x) arêtes en un sommet xfixé. Pour tout les sommets cela fait doncP
x∈V(G)d(x).
Mais avec cette manière chaque arête est comptée deux fois, une fois à chacune de ses extrémités, d’où le
résultat en divisant par 2.
•Preuve par double dénombrement On pose
Z={(x,e)∈V×E:x∈e}⊆V×E
et les deux projections :
p:Z→V
(x,e)7→xet q:Z→E
(x,e)7→e
L ’idée est de calculer |Z|de deux manières différentes. D’abord, on rappelle que si f:A→Best une fonction
quelconque, alors :X
b∈B|f−1[b]| = | A|
oùf−1[b] désigne l’image réciproque de { b} par f(pourquoi ˙S
b∈Bf−1[b] est une union disjointe ?).
Ainsi on obtient :
|Z| =X
x∈V|p−1[x]| =X
e∈E|q−1[e]|
Or,|p−1[x]| =d(x) et|q−1[e]| = |{x∈V:x∈e}| =2. Donc :
X
x∈Vd(x)=X
e∈E2=2|E|
Remarque 2.
— Un sommet de degré 0est appelé sommet isolé .
— Un graphe tel que : ∀x∈V,d(x)=kest dit graphe k-régulier .
— Le graphe complet K nest un graphe (n−1)-régulier .
Exercice 1.1
Montrer que dans un graphe le nombre de sommets d’ordre impairs est toujours pair. En particulier un
graphe k-régulier avec kimpaire est un graphe d’ordre pair.
Voici quelques exemples comme application :
1. Est-il possible de relier 15 ordinateurs en réseau de sorte que chacun soit relié à exactement 3 autres ?
2. Une ligue de football comprenant 11 clubs organise un tournoi. Pour gagner du temps on décide que chaque
équipe ne jouera que la moitié des matches possibles. Comment organiser le tournoi ?
Proposition 1.1
Soit G=(V,E) un graphe (simple) d’ordre n≥2. Alors :
∃u,v∈V,u̸=v:d(u)=d(v)
Preuve. Supposons le contraire, c’est-à-dire ∀u,v∈V;d(u)̸=d(v). Or dans un graphe (simple) on a toujours d(x)∈
{0,1,..., n−1}. Dans ce cas, puisque tous les nsommets ont des degrés distincts, alors il existe une bijection
{d(x):x∈V}←→ {0,1,..., n−1}
Donc, il existe un sommet uavec un degré 0, et un sommet vavec degré n−1, donc vest connecté à tous les autres
sommets du graphe, ce qui signifie que une peut pas être un sommet isolé, d’où une contradiction.6 Chapitre 1. Les graphes
1.1.2 Graphes orientés
Les arêtes d’un graphe peuvent être orientées, auquel cas une flèche indique la direction. De tels graphes sont
appelés des graphes orientés ou des digraphes , et une arête ( a,b) dans un tel graphe indique que cette arête est
dirigée de sommet avers b, i.e. ( a,b)=− →ab̸=(b,a)=− →ba. D’où la définition :
Définition 1.3: Graphe orienté - digraphe
Un graphe orienté G(ou− →G) est un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V2des pairs
ordonnées de V.Eest l’ensemble des arêtes (ou flèches, arcs) de G. Lorsque e=(x,y) est une arête, on dit
que xestl’origine (ou sommet initiale) et yl’extrémité (ou sommet terminale) de e, que eest sortant en x
et incident en y, et que yest un successeur de xtandis que xest un prédécesseur de y. On note l’arête e
par :
e=(x,y)=− →x y=x→y
De la même façon, une arête x→xest une boucle. On peut toujours supprimer les boucles pour obtenir des
digraphes simples. Voici l’exemple d’un digraphe G=(V,E) d’une fonction f:E→Eoù ( x,y) est un arc si et seule-
ment si y=f(x). On l’appelle digraphe fonctionnelle.
0
3
1214
11 568
169
4
2 1
713 10
15
FIGURE 1.3 – Le digraphe fonctionnelle Gfdex7→(x2+3) mod 17.
Comme dans les graphes on peut définir les degrés (entrant, sortant) d’un sommet dans un digraphe.
Définition 1.4: indegree - outdegree
Soit G=(V,E) un digraphe. Pour v∈V, on note par :
d+(v) le degré extérieur (sortant - outdegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité initiale.
d+(v)= |{v→ •}|
d−(v) le degré intérieur (entrant - indegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité finale.
d−(v)= |{• → v}|
On définit le degré : d(v)=d−(v)+d+(v).
Un sommet de degré entrant non nul et de degré sortant nul est appelé puits , tandis qu’un sommet de
degré entrant nul et de degré sortant non nul est appelé source ouracine .
Dans un graphe orienté, les voisins d’un sommet vsont soit des successeurs ou des prédécesseurs. On les notes
par :
Γ+(x)=Succ (x)={y∈V:x→y∈E} et Γ−(x)=Pr ed (x)={y∈V:y→x∈E}H. SABRI 7
Si le digraphe est simple (ni boucle ni arcs parallèles) on a :
d−(v)= |Γ−(v)|et d+(v)= |Γ+(v)|
Proposition 1.2
Soit Gun digraphe, alors :X
v∈Vd−(v)=X
v∈Vd+(v)= |E|
Preuve. On a
E=˙[
v∈V{• → v}=˙[
v∈V{v→ •}
=⇒ | E| =X
v∈V|{• → v}| =X
v∈V|{v→ •}| =⇒ | E| =X
v∈Vd−(v)=X
v∈Vd+(v)
1.2 Opérations et quelques types de graphes
Une opération sur les graphes permet de construire un nouveau graphe comme résultat de l’opération. Les
opérations courantes sur les graphes sont la suppression, la valuation, l’union, l’intersection et le produit cartésien.
Graphe valué
Tout d’abord, on peut vouloir attribuer des valeurs aux arcs ou arêtes pour tenir compte de contraintes : dis-
tance, coût ...
Définition 1.5: (di)graphe valué
Un (di)graphe valué G=(V,E,w) est un (di)graphe muni d’une application w:E→R. L ’application west
appelée application poids ou coût. On indique sur chaque arête son poids (ou son coût). On note w(x,y)
au lieu de w((x,y)). On convient (même que ceci n’a pas de sens!) que w(x,y)= +∞ si (x,y)∉E.
ab
c
d
ef53
43
3
335
81
FIGURE 1.4 – Un digraphe valué
/pythonPython code : -
Implémenter le digraphe valué précédent avec python. Indice – use chatGPT : how to build a weighted digraph with
python8 Chapitre 1. Les graphes
Sous graphes
Soit G=(V,E) un graphe (orienté ou non). Un sous graphe de Gest un graphe de la forme G′=(V′,E′) où
V′⊆V,E′⊆Etels que toute arête de E′a ses extrémités dans V′(ou encore G′est aussi un graphe). On a :
•Sous-graphe induit Un sous-graphe G′=(V′,E′) de G=(V,E) est appelé un sous-graphe induit deGsi :
∀x,y∈V′; (x,y)∈E′⇐⇒ (x,y)∈E
En d’autres termes, deux sommets de G′qui sont connectés dans G, sont également connectés dans G′.
•Sous-graphe couvrant Un sous-graphe couvrant G′deGcontient tous les sommets de G, i.e. V′=V.
•G−vSupprimer un sommet vd’un graphe Gconsiste à supprimer vet toutes ses arêtes incidentes. Le sous-
graphe obtenu de cette opération est noté G−v, i.e.
V′=V−{v} et E′=E−{(v,y): (v,y)∈E}
De manière similaire, une arête epeut être supprimée (resp. ajoutée) d’un graphe G, et le sous-graphe
résultant est représenté par G−e(resp. G+e). Notez que la suppression d’une arête ne retire pas de sommets
du graphe.
•G−V′=G[V′] On supprimer tous les sommets v∈V′du graphe Gavec les arêtes incidentes. Le sous-graphe
obtenu de cette opération est noté G[V′], i.e.
V(G[V′])=V−V′et E(G[V′])=E−{(v,y)∈E:v∈V′}
•Clique Une clique Cd’un graphe Gest un sous-ensemble des sommets de Gdont le sous-graphe induit G′=
(C,E′) est un graphe complet, en d’autres termes, deux sommets quelconques de la clique Csont toujours
adjacents.
•Stable Un stable – appelé aussi ensemble indépendant (independent set en anglais) est un ensemble de som-
mets deux à deux non adjacents. Donc le sous-graphe induit est sans arcs.
FIGURE 1.5 – L ’ensemble des sommets en bleu dans ce graphe est un stable maximal du graphe.
Note : -
Le problème décisionnel de la clique (c’est à dire existe t-il une clique de taille k) est NP-complet . De même la
recherche d’un stable de taille maximum dans un graphe est un problème NP-complet et difficile à approximer.
Exercice 1.2
Trouver un plus grand stable et une plus grande clique du graphe suivant :
8
4
62 7
3
1 5
Indice : vérifier le résultat avec networkx.find_cliques(G) et.maximum_independent_set(G) de python.H. SABRI 9
Opérations binaires
Union L ’union de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∪H=(VF,EF) dans lequel
VF=VG∪VH et EF=EG∪EH
Intersection L ’intersection de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∩H=(VF,EF)
dans lequel
VF=VG∩VH et EF=EG∩EH
1.3 Représentation d’un graphe
Il est important de savoir comment représenter les graphes au sein d’un ordinateur. Il ya plusieurs méthodes
selon la nature des traitements que l’on souhaite appliquer au graphe considéré.
1.3.1 Listes d’adjacences (ou de succession)
Soit Gun (di)graphe. On suppose que les sommets de Gsont numérotés de S1àSn. La représentation par listes
d’adjacence de Gconsiste en un tableau (ou des listes chainées) tel que la ligne i=1... ncorrespond au sommet Si
et comporte la liste des voisins/successeurs (ou des prédécesseurs) de ce sommet notée T[Si]. Les sommets dans
chaque liste d’adjacence sont généralement listés selon un ordre arbitraire.
1
2
345
FIGURE 1.6 – Un digraphe
La liste d’adjacence de digraphe 1.6 est donc :
1 2 3 4 5
2 3
3 4
4−
5 1 410 Chapitre 1. Les graphes
1.3.2 Matrices d’adjacence
Définition 1.6: Mat. Adjacence
Soit G=(V,E) un graphe (orienté) d’ordre n. On peut numéroter V={1,2,..., n}.La matrice d’adjacence
deGest la matrice carrée A=(ai j) d’ordre n, définie par :
ai j=(
1 si ( i j)∈E;
0 sinon.
Remarque 3.
1. Si le graphe G est non orienté et simple, alors la matrice A est symétrique avec des 0sur la diagonale. Pour un
digraphe simple, on a toujours des 0sur la diagonale, mais la matrice n’est pas symétrique en général.
2. Pour les multigraphes, il peut y avoir des termes diagonaux (pour les boucles) et s’il y a plusieurs arêtes de i à
j , le coefficient de la matrice a i jest le nombre d’arêtes de i à j .
3. Pour un (di)graphe valué G =(V,E,w), on pose :
ai j=(
w(i,j)si(i j)∈E ;
∞ sinon.
La matrice d’adjacence de la figure 1.4 est :

∞ 5∞ 4 3 ∞
∞ ∞ 3∞ 1∞
∞ ∞ ∞ ∞ ∞ 5
∞ ∞ 3∞ 3 3
∞ ∞ ∞ ∞ ∞ 8
∞ ∞ ∞ ∞ ∞ ∞

1.3.3 Matrice d’incidence
Définition 1.7: Mat. Incidence
Soit G=(V,E) un graphe (simple) d’ordre net de taille m. On pose V={v1,v2,..., vn} etE={e1,e2,..., em}.
La matrice d’incidence deGest la matrice de type n×m B=(bi j), définie par :
•Si G orienté
bi j=

1 si ej=vi→ • (i.e. viest l’extrémité initiale de ej) ;
−1 si ej= • → vi(i.e. viest l’extrémité terminale de ej) ;
0 sinon.
•Si G non-orienté
bi j=(
1 si viest une extrémité de ej;
0 sinon.
Exercice 1.3
1. Donner la matrice d’incidence du graphe 1.6.
2. Montrer le théorème 1.1 avec la matrice d’incidence.CHAPITRE 2
La connexité
Il est important de savoir si on peut suivre un chemin d’un sommet donné à un autre dans un graphe donné.
Cette propriété (de connexité) doit être maintenue dans différents types de réseaux.
2.1 Les chaînes et les cycles
Définition 2.1: (chaine – cycle) (chemin – circuit)
•Graphe non orienté
1. Une chaîne (walk ) reliant xày, notée µ(x,y), est définie par une suite finie d’arêtes consécutives,
reliant xày, ou encore une séquence de sommets (puisque non multigraphe)
µ(x,y)=<v0,v1,..., vk>
tels que v0=x,vk=yet (vi−1,vi)∈E(G) pour tout i=1... k. Six=yla chaîne est dite fermée .
Lalongueur du chaîne l(µ(x,y)) est le nombre d’arcs dans la chaîne, c’est-à-dire k.
2. Une chaîne élémentaire (a path ) si tous les sommets sont distincts. Une chaîne simple (a simple
walk, a trail ) est une chaîne ne passant pas deux fois par une même arête, c’est-à-dire dont toutes
les arêtes sont distinctes. Remarquer que : élémentaire =⇒ simple.
3. Un cycle v0v1...vnde longueur n≥3 est une chaîne simple fermée ( v0=vn) tel que les sommets
v0,v1,..., vn−1sont tous distincts. Un graphe sans cycle est dit acyclique .
•Graphe orienté
Dans un graphe orienté, on parlera de chemin au lieu de chaîne, et de circuit au lieu de cycle.
Example 2.1
abxcd xa est une chaîne simple et fermée (non cycle!) de longueur 6 (mais, c’est un graphe eulérien - voir
plus loin). Y a-t-il un cycle de longueur 3,4 ?
a b
x
c dÏ
Remarque 4.
1. On peut pivoter une chaine fermée (l’orienter de manière arbitraire) , i.e.
<v0,v1,v2,..., v0>=< vk,vk+1,..., v0,v1,..., vk>
1112 Chapitre 2. La connexité
2. Soient x ,y∈V . La distance de x à y est définie par :
d(x,y)=(
k si le plus court chemin/chaîne de x vers y est de longueur k
∞ sinon
On convient que d (x,x)=0.
3. Le diamètre du graphe la plus grande distance entre deux sommets.
L ’observation suivante, bien que très facile à prouver, sera utile.
Théorème 2.1
S’il existe une chaîne du sommet yau sommet zdans le graphe G, où y̸=z, alors il existe une chaîne élé-
mentaire ( path ) dans Gavec pour premier sommet yet pour dernier sommet z.
Preuve. Soit la chaine
W1=µ(y,z)=x0x1...xn; avec x0=yetxn=z.
Si les sommets x0,x1,..., xnsont tous distincts, alors W1est une chaîne élémentaire, et nous avons terminé. Sinon,
il existe xi=xj(i<j) et on écrit :
W2=x0x1...xixj+1...xn.
Alors, l(W2)<l(W1). Si W2ne contient aucun sommet répété, alors c’est la chaîne recherché. Sinon, par la même
procédure, il existe W3(y z−chaîne) tel que
l(W3)<l(W2)<l(W1).
Ce processus doit s’arrêter à un certain stade, car chaque chaîne est plus courte que la précédente et la longueur
ne peut jamais être inférieure à 1
1< ··· < l(Wk)< ··· < l(W3)<l(W2)<l(W1).
Ainsi, pour un certain k,Wkne peut pas être réduit en longueur. Donc, la chaîne Wkne contient aucun sommet
répété et est donc une y z−chaîne élémentaire (path).
Exercice 2.1
Dans le graphe suivant, construire un path à partir de la chaîne W=v2v3v4v5v6v4v2v8v1
v1
 v2
v3
v4
v5
v6
v7
 v8
 v9
Calculer d(v1,v7) et le diamètre de G.
/pythonpython : >>G = nx.Graph([(1, 2), (2, 3), (2, 4), ...]) >>nx.diameter(G)
Les cycles fournissent la caractérisation suivante pour les graphes bipartis .H. SABRI 13
Théorème 2.2
Un graphe est biparti si et seulement s’il ne contient aucun cycle de longueur impaire.
Preuve.
⇒On suppose que G=U˙∪Vest un graphe biparti. Soit W=< x1,x2,..., x2k+1,x1>un cycle de longueur im-
paire (2 k+1). Si x1∈U, alors
x1∈U=⇒ x2∈V=⇒ x3∈U=⇒ ··· =⇒ x2k+1∈U=⇒ x1∈V/exclamati⌢n-triangle
absurde, d’où le résultat.
⇐On suppose que Gest connexe (car l’union des composantes connexes bipartis est un graphe biparti). Soit
xun sommet de Get on pose :
U={y∈V(G):d(x,y) est paire} et V={z∈V(G):d(x,z) est impaire}
S’il existe y1,y2∈Utel que y1y2∈E(G), alors on a :
W1=<x,..., y1>est une chaîne de longueur paire =2k1
W2=<x,..., y2>est une chaîne de longueur paire =2k2
=⇒ W3=<x,..., y1,y2,..., x>est un cycle de longueur impaire =2k1+2k2+1/exclamati⌢n-triangle
Donc G=U˙∪Vest un graphe biparti.
Exercice 2.2
Vérifier si le graphe maison est un graphe biparti. Faire de même pour la grille G4,4.
maison grille
2.2 Graphe connexe, eulérien, hamiltonien
Définition 2.2: Graphe connexe
Un graphe est dit connexe si deux points peuvent toujours être joints par une chaîne, i.e.
∀x,y∈V(G),d(x,y)< ∞
— Une composante connexe d’un graphe est un sous-graphe induit maximal connexe.
— Un point d’articulation d’un graphe est un sommet dont la suppression augmente le nombre de
composantes connexes.
Par exemple, le graphe suivant :14 Chapitre 2. La connexité
a
 b
d
 c
e
f
 g
n’est pas connexe car il n’existe pas de chaîne entre les sommets aete. On a donc 2 composantes connexes. En
revanche, le sous-graphe induit par les sommets { a,b,c,d} est connexe dont aest le seul point d’articulation.
Remarque 5.
1. Un graphe connexe à n sommets possède au moins n −1arêtes ( faite une preuve par récurrence ).
2. L’algorithme de parcours en profondeur permet de déterminer si un graphe est connexe ou non.
3. Même définitions dans un graphe orienté . Graphe orienté (fortement) connexe et de composante connexe .
Définition 2.3: Graphe eulérien
— Une chaîne joignant deux sommets xetyest dite chaîne eulérienne si elle emprunte chaque arête
deGune et une seule fois. On parle de chemin eulérien dans le cas d’un graphe orienté.
— Un cycle eulérien est une chaîne eulérienne dont les extrémités coïncident. Un graphe qui admet
un cycle (resp. circuit) eulérien est dit graphe eulérien .
/flushedRemarquer qu’un cycle eulérien n’est pas forcément un cycle comme définit dans la définition 2.1
Si un graphe (ou multigraphe) Gpossède une chaîne eulérienne, alors soit Gpossède deux sommets impairs, le
début et la fin de cette chaîne, soit Gn’a aucun sommet impair, et la promenade d’Euler commence et se termine
au même point (cycle eulérien). Une autre condition nécessaire évidente est que Gdoit être connexe. Ces deux
conditions sont ensemble suffisantes.
Théorème 2.3 Euler
Soit Gun graphe (multigraphe) connexe.
— Si Gn’a pas de sommets impairs, alors il possède un cycle eulérien (commençant à n’importe quel
point).
i.e.∀x,d(x)≡0 mod 2 =⇒ Gest un graphe eulérien.
— Si Ga deux sommets impairs, alors il possède une chaîne eulérienne dont le début et la fin sont les
sommets impairs.
La réciproque est aussi vraie.
Preuve.
⇐On commence par la réciproque. S’il existe une chaîne eulérienne µ(x,y), alors on peut crée une arête fictive
e=(y,x) et par la suite on obtient un cycle eulérien. Donc il suffit de montrer que si Gadmet un cycle
eulérien alors tous les sommets sont de degré pair.
Soit W=< v1,v2,..., vn,v1>un cycle eulérien. Soit le sommet vjavec j̸=1, il est donc claire que chaque
fois vjapparaît dans W, il ya deux arcs distincts incidents en vj( (•,vj) et ( vj,•)). Comme toutes les arêtes
sont utilisées, on voit que d(vj) est pair. Même chose pour v1car on ajoute deux arcs ( v1,v2) et ( v1,vn).
⇒On suppose que tous les sommets sont de degré pair. Montrons que Gadmet un cycle eulérien. Puisque
tous les sommets sont de degré pair on peut construire d’abord une chaîne simple fermée (quelconque)
W1=<v1,v2,..., vk,v1>
SiW1contient chaque arête de G, alors c’est finis, c’est un cycle eulérien. Sinon (puisque Gest connexe), il
existe une arête e=(vi,c) qui n’est pas dans W1(avec visommet de W1). On pose le sous-graphe
G′=G−{ arêtes de W1}H. SABRI 15
Il est donc claire que les sommets de G′sont aussi de degré pair. Alors, par la même procédure on construit
une chaîne simple fermée dans G′de la forme : <vi,c,d,..., vi>et par la suite on insère cette chaîne dans
W1pour obtenir :
W2=<v1,v2,..., vi,c,d,..., vi,vi+1,..., vk,v1>
Sil(W2)< |E(G)|, on construit W3de longueur plus grand. Ainsi, on a :
l(W1)<l(W2)<l(W3)< ··· ≤ | E(G)|
Donc, nécessairement, il existe Wk(chaîne simple fermée de longueur |E(G)|) donc c’est un cycle eulérien.
Finalement , si∃a,b∈V(G):d(a)≡d(b)≡1 mod 2, et tous les autres sommets sont de degré pair, alors on
pose :
G′=G+{a,b}
et donc tous les sommets de G′sont de degré pair. Avec la construction précédente, il existe un cycle eulérien
dans G′:
W=<a,b,v1,..., a>
est donc la chaîne <b,v2,..., a>est une chaîne eulérienne dans G.
Algorithme 1 : Euler
Entrées : Gun graphe eulérien
Output : Un cycle eulérien W
/* On suppose que G est eulérien, i.e. les sommets sont de degré pair */
1Gaux←G;W←µ(v,v) une chaîne simple (quelconque) de G; // Initialisation
2tant que l(W)<e(G)faire
3 Gaux←G−{ arêtes de W} ;
4 Choisir ( x,c)∈E(Gaux) tel que x∈W;
5 L←< x,c,..., x>une chaîne simple de Gaux ;
6 Dans W, remplacer (juste ce) xpar la séquence L;
7fin
8retourner W;
Exercice 2.3
1. Montrer que le graphe de l’exercice 2.1 est un graphe eulérien et donner un cycle eulérien.
2. Tracer cette maison d’un seul trait.
Remarque 6. Le théorème d’Euler dans un graphe orienté connexe s’écrit :
Admet un circuit eulérien si, et seulement si, pour tout sommet, le degré entrant est égal au degré sortant.
∀v∈V(G),d+(v)=d−(v)
Admet un chemin eulérien de a vers b si, et seulement si,


d+(v)=d−(v) ;∀v̸=a,b,
d−(a)=d+(a)−1
d−(b)=d+(b)+116 Chapitre 2. La connexité
Définition 2.4: Graphe hamiltonien
Soit Gun graphe connexe d’ordre n. On appelle :
1. On appelle cycle hamiltonien deGun cycle passant (une et une seule fois) par chacun des sommets
deG. Un graphe est dit hamiltonien s’il possède un cycle hamiltonien.
2. Une chaîne hamiltonienne est une chaîne passant une et une seule fois par chacun des sommets de
G. Un graphe ne possédant que des chaînes hamiltoniennes est semi-hamiltonien .
3. Dans un digraphe, on change cycle par circuit et chaîne par chemin .
Remarque 7.
— Une chaîne hamiltonienne est une chaîne élémentaire de longueur n −1.
— Un graphe peut être eulérien, hamiltonien, les deux à la fois, ou aucun des deux.
— De nombreux problèmes concrets peuvent être formulés en termes de recherche de parcours hamiltoniens : pro-
blème du voyageur de commerce (chercher un cycle hamiltonien de longueur totale minimale), l’ ordonancement
de tâches .
— Le problème du chaîne hamiltonienne est un problème NP-complet .
Exercice 2.4
Donner un graphe (connexe, simple) qui soit :
1. hamiltonien et eulérien.
2. hamiltonien et non eulérien.
3. eulérien et non hamiltonien.
4. non hamiltonien et non eulérien.
Aucune condition nécessaire et suffisante adéquate n’est connue pour l’existence de cycles hamiltoniens. Le
résultat suivant constitue une condition suffisante utile.
Théorème 2.4 Ore
Soit Gun graphe simple d’ordre n≥3. Si pour toute paire { x,y} de sommets non adjacents, on a d(x)+d(y)≥
n, alors Gest hamiltonien.
Preuve. On suppose que le théorème est faux. Alors, il existe un graphe Gsimple d’ordre nnon hamiltonien tel que
d(u)+d(v)≥npour tout sommets non adjacents uetv. On prend Gun tel graphe d’ordre nde taille maximale qui
vérifie cette propriété (remarquer que le graphe complet Knest hamiltonien).
Soient uetvdeux sommets non adjacents de G. Par maximalité de G, le graphe G+uv(d’ordre n) doit être
hamiltonien. Donc il existe dans G+uvun cycle hamiltonien :
W=<u,x1,x2,..., xn−2,v,u>
u
x1
xi xi+1xn−2
v
... ...
Or, si uxi+1∈E(G) etv xi∈E(G) (les arcs en rouge), alors on peut construire dans Gle cycle hamiltonien :
<u,x1,x2,..., xi,v,xn−2,..., xi+1,u>H. SABRI 17
Ceci est absurde car Gest non hamiltonien. Donc si xi+1est un sommet voisin à u, alors le sommet xin’est pas
voisin de v:
xi+1∈Γ(u)=⇒ xi∉Γ(v)
Donc :
d(u)= |Γ(u)| =p=⇒ d(v)≤(n−1)−p
et par la suite
d(u)+d(v)≤n−1
ce qui absurde par hypothèse. Donc Gest hamiltonien.
Une conséquence immédiate est le théorème de Dirac :
Proposition 2.1 Dirac
Soit Gun graphe simple d’ordre n≥3. Si pour tout sommet xdeG, on a d(x)≥n
2, alors Gest hamiltonien.
2.3 Arbres
Définition 2.5: Arbres et forêts
On appelle arbre tout graphe (non orienté) connexe et acyclique . Les composantes connexes dans un
graphe acyclique sont des arbres et le graphe est dit forêt . Une feuille ou sommet pendant est un som-
met de degré 1.
Un forêt avec deux arbres
Un graphe Gest une arborescence s’il existe un sommet Rappelé racine deGtel que, pour tout sommet
SdeG, il existe un chemin et un seul de Rvers S. Donc, c’est un arbre orienté dans lequel on choisit un
sommet Rcomme racine et on dirige les arcs vers le sens sortant de la racine.
Remarque 8.
— Un graphe G d’ordre n est un arbre ssi G est sans cycle et possède n −1arêtes.
— Un graphe G d’ordre n est un arbre ssi G est connexe et possède n −1arêtes.
— G est un arbre si pour chaque paire u ,v de sommets distincts est reliée par une seule chaîne (donc chaîne
élémentaire d’après le théorème 2.1).
— Un arbre (ou forêt) est nécessairement un graphe simple.
Pour démontrer les remarques précédentes, il suffit de prouver le théorème suivant :
Théorème 2.5
Soit Gun graphe ayant marêtes, nsommets et pcomposantes connexes, on définit nu( G) :
ν(G)=m−n+p
Alors, on a :
1.ν(G)≥0.
2.ν(G)=0⇐⇒ Gest acyclique.18 Chapitre 2. La connexité
Preuve. Par récurrence sur la taille mdu graphe. Le résultat est évident pour m=0 et m=1. On suppose le résultat
est vrai pour les graphe de taille m, et montrons que ceci est vrai pour un graphe de taille m+1. Soit donc Gun
graphe d’ordre nde taille m+1 ayant pcomposantes connexes.
•On suppose que Gest un graphe acyclique. Soit uvune arête de Gdans la composante C. Si on supprime uv,
la composante Cse transforme en deux composantes connexes (sinon on a un cycle dans G). Par la suite,
le graphe G′=G−uvest un graphe acyclique d’ordre n, de taille met ayant p+1 composantes connexes.
Donc d’après l’hypothèse de récurrence :
ν(G′)=0=(m−1)−n+(p+1)=m−n+p=ν(G)
•Maintenant, si Gcontient un cycle Wdans la composante connexe C. Soit uvune arête de W, alors si on
supprime l’arête uv, la composante Creste connexe. Donc le graphe G′=G−uvest un graphe d’ordre nde
taille m−1 ayant pcomposantes connexes. Donc, d’après l’hypothèse de récurrence :
ν(G′)=(m−1)−n−p≥0
=⇒ν(G)=m−n−p≥1>0
D’où le résultat – car si ν(G)=0,Gne peut être que acyclique, sinon 0 =ν(G)≥1/exclamati⌢n-triangle
2.3.1 Codage et décodage d’un arbre – Prüfer code
Soit Tun arbre ayant nsommet numérotés {1,2,..., n}. Le codage de Prüfer représente l’arbre Tarbre de avec
une suite P=(x1,x2,x3,..., xn−2) de n−2 termes (les n° des sommets avec répétition possible). Une suite Pdonnée
correspond à un et un seul arbre numéroté. Voici les algorithmes de codage et de décodage.
Algorithme 2 : Codage de Prüfer
Entrées : Un arbre T
Output : Séquence de Prüfer P
1P←() ; // Initialisation de P comme séquence vide
2tant que v(T)>2faire
3 x←feuille de Tayant le n° minimum ; // donc d(x)=1
4 P←(P,s) où sest le seul (n°) sommet adjacent à x;
5 T←T−x;
6fin
7retourner P;
Example 2.2
Donner le code de Prüfer de l’arbre :
126 345
Indice : on trouve, P=(2,3,3,2)
Pour faire la réciproque, étant donnée une séquence P=(x1,x2,..., xn−2) où les xi∈{1,2,..., n}, on construit
l’arbre Tdont les sommets sont {1,2,..., n} avec l’algorithme suivant (le décodage) :H. SABRI 19
Algorithme 3 : Décodage de Prüfer
Entrées : Une séquence Pde taille n−2
Output : L ’arbre Tcorrespondante
1I←{1,2,..., n};
2T←graphe tel que V(T)=IetE(T)= ; ; // T graphe à n sommets isolés
3tant que P̸=()faire
4 i←min {x∈I:x∉P};
5 T←T+(i,P[1]) ; // ajouter l'arc (i,P[1])
6 P←P−P[1];I←I−{i};
7fin
8T←T+(a,b) ; // a,b sont les deux éléments restant dans I
9retourner T;
Example 2.3
Donner l’arbre dont le code de Prüfer est : P=(2,3,3,3)
Puisqu’il ya une bijection entre les arbres d’ordre net les suites Pde longueur n−2 à coefficients dans {1,2,..., n},
on déduit le théorème de Cayley :
Théorème 2.6 Formule de Cayley
Le nombre d’arbres que l’on peut construire sur n(n≥2) sommets numérotés est égal à nn−2.
2.3.2 Arbre couvrant de poids minimum – ACM
Soit Gun graphe (non orienté). Un arbre couvrant (spanning tree) TdeGest un sous graphe couvrant de G
tel que Test un arbre. Remarquer que, Gdoit être connexe, sinon un arbre couvrant de Gn’existe pas. Le nombre
des arbres couvrant de Gest noté a(G). Remarquer que a(Kn)=nn−2(le nombre de Cayley). Un problème algo-
rithmique classique est de trouver, dans un graphe valué , un arbre couvrant de poids minimal . On dispose de
plusieurs algorithmes (l’algorithme de Prim, l’algorithme de Kruskal ...).
Algorithme 4 : Kruskal
Entrées : Un graphe Gvalué d’ordre net de taille m
Output : Arbre (ou forêt) couvrant de poids minimum
1Numéroter les arêtes de Gpar poids minimum : w(e1)≤w(e2)≤ ··· ≤ w(em)
2T←graphe tel que V(T)=V(G) etE(T)= ; ; // T graphe à n sommets isolés
3k←0;
4tant que k<m et e (T)<n−1faire
5 siT+ek+1est acyclique alors
6 T←T+ek+1;
7 k←k+1;
8fin
9retourner T;
Appliquer l’algorithme de Kruskal dans le graphe suivant :
CHAPITRE 3
Les algorithmes de base
Beaucoup de problèmes sur les graphes nécessitent que l’on parcourt l’ensemble des sommets et des arcs. Par
exemple, pour vérifier que le graphe est connexe, chercher un sommet particulier, construire un arbre couvrant,
trouver un plus court chemin ...etc.
3.1 Parcours en profondeur (DFS) / largeur (BFS)
Une manière simple de tester si un graphe Gest connexe ou non est d’exécuter l’algorithme DFS ouBFS dans
Gen commençant par n’importe quel sommet et en enregistrant les sommets visités pendant l’exécution dans une
liste. Si la liste contient tous les sommets de G, alors Gest connexe. Une petite modification permet de donner les
composantes connexes de G. L ’algorithme DFS_Component suivant donne les composantes connexes de G. Il est
donné sous forme d’implémentation récursive.
Algorithme 5 : DFS_Component
Entrées : Un graphe G=(V,E)
Output : Les composantes connexes C=(C1,C2,..., Ck) de G.
1VisitedNodes ← ; ;
2k←0 ; // k est le nombre des composantes connexes
3pour chaque u∈Vfaire
4 siu∉VisitedNodes alors
5 k←k+1;
6 DFS( u);
7 fin
8fin
9retourner (C1,C2,..., Ck);
1Procedure DFS( u )
2 VisitedNodes ←VisitedNodes ∪{u};
3 Ck←Ck∪{u};
4 pour chaque x∈Γ(u)faire
5 six∉VisitedNodes alors
6 DFS( x);
7 fin
8 fin
Note : -
Il est possible de d’implémenter la procédure DFS itérativement à l’aide d’une pile LIFO (stack) contenant les
sommets à explorer : on désempile un sommet et on empile ses voisins non encore explorés.
20H. SABRI 21
Pseudocode :
stack . push ( root )
while stack . isEmpty ( ) = f a l s e do
node = stack . pop ( ) // so mark i t as v i s i t e d
for each x in node . childNodes do
i f x i s not v i s i t e d then
stack . push ( x )
. . .
endfor
endwhile
Example 3.1 (DFS )
Ici on empile (gris) les sommets les plus à droite, alors l’ordre des sommets visité (noir) est ( a,b,d,e,g,c,f).
Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b
 c
d
 e
f
g
a
b
 c
d e
f
ga
b
 c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g
L ’utilisation d’une file (FIFO) au lieu d’une pile transforme l’algorithme du parcours en profondeur en algo-
rithme de parcours en largeur ( BFS ). Avec BFS l’exemple précédent devient (en enfile le plus à gauche) :
Example 3.2 (BFS )
Ici, avec BFS, on enfile (gris) les sommets les plus à gauche d’abord, alors l’ordre des sommets visité (noir)
est ( a,b,d,e,g,c,f). Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b c
d
 e
f
g
a
b c
d
 e
f
ga
b c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g22 Chapitre 3. Les algorithmes de base
Exercice 3.1
1. Écrire la procédure BFS .
2. Utiliser DFS (ou BFS) pour la construction d’un arbre couvrant d’un graphe connexe. L ’appliquer
pour le graphe triangle.
3. Utiliser DFS pour écrire une procédure DFS_Cycle pour détecter un cycle dans un graphe.
On sait qu’un graphe orienté G=(V,E) est fortement connexe si pour chaque paire de sommets u,v∈V, il
existe un chemin de uàvet il existe un chemin de vàu. En d’autres termes, nous avons besoin d’une connectivité
dans les deux directions .
Une procédure pour tester si un graphe orienté est fortement connexe ou non peut être conçue avec l’idée
suivante. En partant d’un sommet arbitraire vdu graphe G, on exécute l’algorithme BFS ouDFS et l’on note les
sommets visités. Ensuite, on obtient la transposée de G,GT, en inversant la direction des arêtes de G, et l’on
exécute à nouveau l’algorithme BFS ou DFS à partir du sommet v. Si les sommets visités dans les deux cas sont
égaux à V, alors le graphe orienté est fortement connexe. Cette méthode est illustrée dans l’algorithme 6.
Algorithme 6 : Fortement_connexe
Entrées : Un graphe orienté G=(V,E)
Output : true siGest fortement connexe et false sinon
1X← ; ;
2Y← ; ;
3v←un sommet quelconque de V;
4X←DFS( G,v) ; // Enregistrez les sommets visités dans X
5GT←Gavec flèches inversées;
6Y←DFS( GT,v);
7siX=Y=Valors
8 retourner TRUE.
9sinon
10 retourner FALSE.
11fin
3.2 Recherche des chemins
3.2.1 Matrice d’adjacence et nombre de chemins
La puissance de la matrice d’adjacence Amontre qu’il y a des chemins (ou chaînes) de longueur kallant de xà
ycomme le montre le théorème suivant.
Théorème 3.1
Soit G=(V,E) un (di)graphe. On note V={1,2,..., n} et Asa matrice d’adjacence et Akla puissance k-ème
deA. Alors le terme d’indices i,jdeAkest le nombre de chemins (chaînes) de longueur kallant de iàj.
Preuve. Par récurrence sur k. Pour k=1 c’est clair. On suppose le résultat est vrai à l’ordre ket montrons qu’elle
est vrai pour k+1. Soit S=(si,j)=Ak. Si on a un chemin de iàjde longueur k+1, alors on va d’abord de ià un
sommet ravec kpas et puis de ràj. Or d’après l’hypothèse de récurrence on a si,rchemins possibles pour aller de
iàret finalement ar,jpas (1 ou 0) pour aller de ràj. Ainsi, le nombre totale possibles (i.e. tous les sommets r) est :
nX
r=1si,rar,j=³
Ak×A´
i,jH. SABRI 23
ce qui est bien le terme ( i,j) de la matrice Ak+1.
3.2.2 Plus court chemin et l’algorithme de Dijkstra
Dans cette partie on suppose que le (di)graphe G=(V,E,w) est valué positivement (i.e.∀e∈E,w(e)>0). Notre
objectif est de chercher un plus court chemin (i.e., un chemin de poids minimal ) d’un sommet ufixé à un sommet
quelconque de G.
Il est clair que l’on peut restreindre ce problème au cas d’un (di)graphe simple1. On suppose aussi que Gest
connexe (sinon, certains trajets sont impossibles). Il est aussi claire (d’après théorème 2.1), qu’un plus court chemin
est nécessairement un chemin élémentaire (path).
L ’algorithme de Dijkstra (1959) permet de calculer le plus court chemin entre un sommet particulier u(racine )
et tous les autres sommets. L ’algorithme fonctionne de la manière suivante :
Pour tout sommet vdeG, on associe une valeur T(v), initialisée à w(u,v) et une liste de sommets C(v) qui
correspond à un chemin de uàv. À la fin de l’algorithme, T(v) contient le poids minimal des chemins joignant uà
v(ou T(v)= ∞ siu↛v) et la liste C(v) réalise un tel chemin. Voici donc l’algorithme de Dijkstra :
Algorithme 7 : Algorithme de Dijkstra
Entrées : Un (di)graphe valué G=(V,E,w) et un sommet racine u
Output : Le coût minimum d’un chemin de uàv(∀v∈V) et un trajet pour chaque coût minimal obtenu
1∀v∈V,T(v)←w(u,v) etC(v)←(u,v); // Initialisation de T(v) et la liste C(v)
2X←{u};
3tant que X̸=Vfaire
4 Choisir v∈V−Xtel que ∀y∈V−X,T(v)≤T(y);
5 X←X∪{v};
6 pour chaque y∈V−Xfaire // Faire les mises à jours pour les autres sommets
7 siT(y)>T(v)+w(v,y)alors
8 T(y)←T(v)+w(v,y);
9 C(y)←[C(v),y]; // On ajoute à la liste C(v) l'élément y
10
11 fin
12 fin
13fin
Example 3.3
Voici une application de l’algorithme de Dijkstra au digraphe suivant. On prend Ecomme sommet racine.
EA
B
CD
FG
S5
4
21
12
2
34
4
215
7
1. En effet, passer par une boucle ne ferait qu’augmenter inutilement le poids de ce chemin. De même, si plusieurs arcs joignent deux
sommets, il suffit de conserver l’arc de poids minimal.24 Chapitre 3. Les algorithmes de base
Ainsi, pour l’initialisation, on a : X={E} et on a les valeurs :
v  E A B C D F G S
T(v) 0 5 4 2 ∞ ∞ ∞ ∞
C(v)(E,E) ( E,A) ( E,B) ( E,C) ( E,D) ( E,F) ( E,G) ( E,S)
Maintenant, on choisit (un seul choix) le sommet C, donc X={E,C}. Le tableau est mis à jour :
v  E A B  C D F G S
T(v) 0 5 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À l’étape suivante, on est forcé de choisir B. Ainsi, X={E,C,B} et la mise à jour est :
v  E A  B  C D F G S
T(v) 0 4 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À présent, on a le choix entre AetF. On choisit A. Donc X={E,C,B,A} et on a :
v  E  A  B  C D F G S
T(v) 0 4 3 2 6 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,B,A,D) ( E,C,F) ( E,C,G) ( E,S)
Puis, on prend le sommet F. D’où X={E,C,B,A,F} et :
v  E  A  B  C D  F G S
T(v) 0 4 3 2 5 4 5 11
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,S)
On prend Det on obtient X={E,C,B,A,F,D} et :
v  E  A  B  C  D  F G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Finalement, on prend Gpuis Set on voit que ceci ne change rien. D’où le tableau finale :
v  E  A  B  C  D  F  G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Ainsi le chemin minimum pour aller de EàSest de coût 10 et un trajet de coût minimal de EàSest : EC F DS .H. SABRI 25
3.3 Problèmes d’ordonnancement et chemin critique
Un problème d’ordonnancement peut-être représenté sous la forme d’un digraphe. Les sommets sont des évé-
nements (début et fin de la tâche) et les arcs des tâches, La longueur (ou poids) de chaque arc représente la durée
d’exécution de la tâche. Ainsi, la tâche correspondant à l’arc ( i,j) ne peut commencer que si toutes les tâches cor-
respondant à des arcs ( k,i) ont été complétées. On ajoute deux sommets pour le début (s) et de fin(t) du projet .
Le digraphe peut contenir des tâches fictives dedurée nulle afin de forcer certaines précédences (postériorité).
Ainsi, un réseau PERT est un digraphe valué G=(V,E,w,s,t) où la fonction poids (ou longueur) w:E→R+
etsle sommet source (début) et tle sommet puits (fin). Un chemin critique est un chemin de sàtdelongueur
maximale . S’il n’existe pas de chemin critique, le projet n’est pas réalisable (e.g. un circuit). Le temps minimal
requis pour l’exécution d’un projet réalisable est égal à la longueur d’un chemin critique. Les tâches figurant sur un
chemin critique sont aussi appelées critiques, ce qui s’explique par le fait que tout retard d’exécution d’une tâche
critique retarde d’autant l’exécution du projet.
3.3.1 Algorithmes de tri topologique et de chemin critique
Il faut d’abord numérotés les sommets de 1 à nde manière compatible au pré-ordre (rang) avec l’algorithme du
rang suivant (tri topologique) :
Algorithme 8 : Algorithme du rang
Entrées : Un digraphe G=(V,E) sans circuit
Output : Le rang r(v) de chaque sommet v∈Vde G
1r←0;X←V;
2R←{v∈X:Γ−
X(v)= ;} ; // l'ensemble des sommets de X sans prédécesseur dans X
3tant que X̸= ; faire
4 r(v)←rpour chaque sommet v∈R;
5 X←X−R;
6 R←l’ensemble des sommets de Xsans prédécesseur dans X;
7 r←r+1;
8fin
On supposera dorénavant que les sommets ont déjà été numérotés de 1 à nde manière compatible avec leurs
rangs, c’est-à-dire que r(j)>r(i) implique j>i(donc 1 =setn=t). Enfin, on supposera éliminés les arcs paral-
lèles par l’introduction de tâches fictives de durée nulle .
Pour un sommet i, on note tiledébut au plus tôt des tâches correspondant aux arcs i→jet par Tilafin au
plus tard des tâches correspondant aux arcs j→i.
Algorithme 9 : Algorithme du chemin critique
Entrées : Un digraphe G=(V,E) sans circuit trié topologiquement
Output : La durée du chemin critique et les dates ti,Ti
1t1←0;
2pour j=2···nfaire // Calcul des dates de début au plus tôt  récurrence en avançant
3 tj←max i∈Γ−(j){ti+w(i,j)}
4fin
5Tn←tn;
6pour j=n−1···1faire // Calcul des dates de fin au plus tard  récurrence en reculant
7 Tj←min i∈Γ+(j){Ti−w(j,i)}
8fin26 Chapitre 3. Les algorithmes de base
Définition 3.1
— Un sommet iest critique si ti=Ti.
— Un arc ( i,j) est critique les sommets ietjsont critiques ettj−ti=w(i,j).
— Un chemin critique est un chemin de 1 à nn’utilisant que des arcs critiques.
— La durée du chemin critique est donnée par Tn(ou par tn). Elle correspond à la durée minimale du
projet .
Example 3.4
L ’application de l’algorithme du chemin critique au digraphe suivant (trié topologiquement) est :
1 23
45
6B
9A
3
C
5D
8
E
4
F7G
20
H6I5
=⇒
 1
0,02
9,933,16
4
16,23513,24
6
29,29B
9A
3
C
5D
8
E
4
F7G
20
H6I5
Les tâches critiques sont BetG. La durée totale minimale du projet est donc 29.
Exercice 3.2
Les tâches ( durée et précédences ) pour la construction d’un entrepôt sont données dans le tableau suivant :
Tâches Nature Précédences Durée (jours)
A Acceptation des plans par le propriétaire – 4
B Préparation du terrain – 2
C Commande des matériaux A 1
D Creusage des fondations A, B 1
E Commande des portes et fenêtres A 2
F Livraison des matériaux C 2
G Coulage des fondations D, F 2
H Livraison des portes et fenêtres E 10
I Pose des murs, de la charpente et du toit G 4
J Mise en place des portes et fenêtres H, I 1
1. Représentez le graphe des précédences de ce projet (trié topologiquement).
2. Déterminez une durée totale minimale en exhibant un chemin critique dans ce graphe.CHAPITRE 4
Programmation linéaire
La programmation linéaire est le processus de minimiser ou maximiser une fonction objective linéaire sou-
mise à un nombre fini de contraintes d’égalités et d’inégalités linéaires.
La programmation linéaire a de nombreuses applications dans le domaine de l’informatique théorique. Elle
peut être utilisée pour résoudre de nombreux problèmes combinatoires variés, tels que la recherche de flot maxi-
mum dans un réseau, la recherche d’un couplage maximal dans un graphe et la coloration d’un graphe parfait.
Example 4.1 (Problème de régime)
On suppose qu’on a quatre plats : de la truite ( XT), un sandwich au corned-beef ( XC B), un burrito ( XBU R )
et un hamburger ( XHB). Le tableau suivant répertorie la valeur nutritionnelle de chaque plat (vitamines et
calories) et notre besoin journalier des vitamines.
Vit. A Vit. C Vit. D Calories
Truite 203 92 100 600
Corned-beef 90 84 230 350
Burrito 270 80 512 250
Humburger 500 90 210 500
Besoins 2000 300 430
Notre objectif est de minimiser le nombre total de calories consommées : 600 XT+350XC B+250XBU R+
500XHBtout en satisfaisant les trois besoins nutritionnels en vitamines. Le programme linéaire résultant
s’écrit :
min 600 XT+350XC B+250XBU R+500XHB
s.t. 203 XT+90XC B+270XBU R+500XHB≥2000, (Besoins de Vit. A),
92XT+84XC B+80XBU R+90XHB≥300, (Besoins de Vit. C),
100XT+230XC B+512XBU R+210XHB≥430, (Besoins de Vit. D),
XT,XC B,XBU R ,XHB≥0
Définition 4.1: Forme canonique – Forme standard
On peut écrire un P .L. sous deux formes spéciales :
•Canonique
max
mincTX+c0
s.t. AX≤b(≥bsi min),
X≥0•Standard
max cTX+c0
s.t. AX=b,
X≥0Avec :
cTX=¡
c1··· cn¢
x1
...
xn

cTX+c0=c1x1+c2x2+···+ cnxn+c0
2728 Chapitre 4. Programmation linéaire
Remarque 9. Un P .L. général peut être formulé selon une forme standard ou canonique par la méthode suivante :
générale =⇒ standard il faut éliminer les contraintes d’inégalité et les variables sans contrainte de positivité.
— Si dT
iX≤biest une contrainte d’inégalité, alors créer une nouvelle variable ( d’écart ) siet remplacer l’in-
égalité dT
iX≤bipar dT
iX+si=biet s i≥0.
Si dT
iX≥bi, alors on peut écrire dT
iX−si=biet s i≥0.
— Si une variable x i≶0est de signe quelconque, alors créez deux nouvelles variables x+
iet x−
iet remplacez
xipartout par x+
i−x−
i, et ajoutez les contraintes de signe : x+
i≥0,x−
i≥0.
générale =⇒ canonique
— Si dT
iX=biest une contrainte d’égalité, alors remplacer cette égalité par une paire d’inégalités :
dT
iX≥biet−dT
iX≥ −bi
— Même chose que précédemment si la variable x i≶0.
Il est facile de voir que les problèmes qui en résultent sont équivalents aux problème d’origine. Pour l’algorithme
simplexe , nous utiliserons la forme standard .
On remarque aussi qu’en utilisant la relation min f(x)= − max¡
−f(x)¢
dans laquelle f (x)représente la fonction-
nelle linéaire à optimiser, on peut toujours se ramener à un problème de minimisation (ou de maximisation).
Example 4.2
Le P .L :max 5 x+4y
s.t. x≤6
1
4x+y≤6
3x+2y≤22
x,y≥0s’écrit sous forme standard :max 5 x1+4x2
s.t. x1+e1=6
1
4x1+x2+e2=6
3x1+2x2+e3=22
x1,x2,e1,e2,e3≥0
Donc (sous la forme matricielle) on a :
cT=¡
5 4 0 0 0¢
;A=
1 0 1 0 0
1
41 0 1 0
3 2 0 0 1
;X=
x1
x2
e1
e2
e3
et b=
6
6
22

4.1 La méthode simplexe
4.1.1 Solution de base admissible
On suppose que la matrice Adu programme linéaire est de type m×netde rang m(pourquoi !). Soit Bla
matrice carrée extraite de Aformée par les mcolonnes j1,j2,..., jmlinéairement indépendants de A(les vecteurs
de base). Alors, Best une matrice inversible. Ainsi si on pose xl=0 sil∉{j1,..., jm} etxjklak-ième composante de
B−1b. Alors, on a AX B=b. Si de plus XB≥0(i.e. chaque xi≥0), alors :
Xest une solution de base admissible (ou réalisable)
Dans l’exemple 4.2, la matrice extraite B=
1 0 0
0 1 0
0 0 1
est inversible et B−1b=
6
6
22
. Donc XB=
0
0
6
6
22
≥0, par suite
XBest une solution de base admissible. On appelle les variables xjklesvariables de base . Les autres variables xl
sont les variables hors-base .
Parfois, il n’est pas évident de trouver une solution de base admissible, comme le montre l’exercice suivant :H. SABRI 29
Exercice 4.1
Écrire le programme linéaire suivant sous forme standard et montrer qu’on n’a pas une solution de base
admissible. Résoudre le programme linéaire.
max −x+y
s.t. x+y≥1,
3x+2y=6,
x,y≥0
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux
Dans cette section, on suppose qu’on a déjà trouvé une solution de base admissible X(produite avec B=Im)
du programme linéaire ( P: max z=cTX+c0etb≥0pour garantir que 0est une solution de AX≤b).
La méthode du simplexe est une méthode itérative qui génère une séquence de solutions de base réalisable
(correspondant à différentes bases) et s’arrête finalement lorsqu’elle a trouvé une solution de base réalisable opti-
male. Remarquer qu’on peut toujours prendre c0=0.
Algorithme 10 : Algorithme du simplexe
Entrées : Un P .L. standard P(max) avec une solution de base réalisable
Output : La solution optimale (ou non)
1On commence à écrire le tableau initiale (avec les variables de base xj1,..., xjm)
VB x1 ... xn b
xj1 b1
... A...
xjm bm
c1 ... cn−c0
2Sicj≤0 (∀j:xjest hors base), alors solution optimale (STOP) // min ⇝cj≥0
3Trouver la colonne s(hors base) tel que cs=max©
cj:cj>0ª// min ⇝cs=min©
cj:cj<0ª
4Siai,s≤0∀i=1... m, alors pas de solution optimale (STOP)
5Min Ratio Test : trouver la ligne rtel que
br
ar,s=min
i=1...m½bi
ai,s:ai,s>0¾
6Appliquer la procédure de Gauss autour de pivot ar,s(ar,s⇝1 et on annule les coefficients situés sous et
sur le pivot dans la colonne s, par combinaisons de lignes) // Ne pas oublier la dernière ligne
7Remplacer (dans VB) la variable de base ( sortante ) située à la ligne rpar la variable ( entrante )xs
8Retourner à l’étape 2 // l'algorithme termine si le programme linéaire est non dégénéré
Remarque 10.
— La dernière ligne représente l’équation linéaire −z+c1x1+···+ cnxn= −c0.
— La valeur de la variable de base de V Bde la ligne k est égale à la valeur b k(de la ligne k).
— La solution optimale du problème est la valeur finale (dernière cellule) (×− 1).
— Si on n’a pas au départ B =Im(à l’aide des variables d’écart) alors, on ajoute les variables artificielles (et on
applique d’abord la phase I - voir section suivante).30 Chapitre 4. Programmation linéaire
Exercice 4.2
Soit le programme linéaire :
max 2 x1+x2
s.t. x1−x2≤3,
x1+2x2≤6,
−x1+2x2≤2,
x1,x2≥0
Rajouter les variables d’écart. Puis résoudre le problème par l’algorithme du simplexe.
Remarque 11. Vérifier le résultat de l’exercice précédent, par la méthode graphique.
4.1.3 Initialisation - Phase I du simplexe
Un programme linéaire est dit sous forme simpliciale si la matrice Acontient la matrice identité Imcomme
sous matrice. On suppose que le programme linéaire P, après la mise en forme AX=b, n’est pas simpliciale
(possible dans le cas de contraintes du type ≥ou du type =). Soit Bune matrice d’ordre mextraite de Ainversible
tel que B−1b≥0et soit XBla solution de base réalisable ( XB≥0etAX B=b), alors on peut changer l’équation
matricielle :
AX B=b
⇐⇒ (B−1A)XB=B−1b
⇐⇒ A∗XB=b∗
et la matrice A∗contient la matrice identité Imcomme matrice extraite ( B−1A=B−1(H|B)=¡
B−1H|Im¢
). Ainsi, on
peut appliquer directement l’algorithme 10 en remplaçant Apar A∗etbpar b∗. Cependant, cette méthode n’est
pas efficace, car il faut trouver une matrice extraite Bréalisable correspondante. Pour une matrice Ade type m×n,
il existe¡m
n¢
matrices extraites à tester !
L ’idée est d’ajouter des variables, dites artificielles w1,w2,..., wm, pour faire apparaître une forme simpliciale
du programme linéaire P: (AX=b). Mais, il faut que w1= ··· = wm=0. Donc, il faut minimiser d’abord le pro-
gramme linéaire P0suivant :
P0=min W=w1+···+ wm
s.t. (A|Im)×(x1...xnw1...wm)T=b
x1,..., xn,w1,..., wm ≥0
On exprime Wà l’aide des autres variables (hors base) et puis on applique l’algorithme du simplexe 10 pour P0
(phase I). À la fin, si on trouve que les wi=0, alors les variables de bases xj1,..., xjmforment une première base
admissible pour démarrer le simplexe pour le programme d’origine P.H. SABRI 31
Remarque 12. On ajoute la ligne de Z :c1 ... cn−c0dans le tableau du simplexe de P0(phase I) et on lui
applique les opérations élémentaire comme avec les autres lignes. À la fin de la phase I, on supprime les colonnes des
wiet la ligne de la fonction W . Finalement, on utilise ce tableau pour résoudre le problème initiale P.
Example 4.3
Soit le programme linéaire P:
min 6 x1+3x2
s.t. x1+x2≥1,
2x1−x2≥1,
3x2≤2,
x1,x2≥0sous forme standard (max)= = = = = = = = = = = = = = = = = = ⇒max Z= −6x1−3x2
s.t. x1+x2−e1=1,
2x1−x2−e2=1,
3x2+e3=2,
x1,x2,e1,e2,e3≥0
La matrice Aest :
A=x1 x2 e1 e2 e3

1 1 −1 0 0
2−1 0 −1 0
0 3 0 0 1
est par suite Pn’est pas sous forme simpliciale (il n’ ya pas de sous matrice I3). Donc on peut ajouter 2
variables artificielles pour construire le problème initiale P0:
max −w1−w2=3x1−e1−e2−2
s.t. x1+x2−e1+w1=1,
2x1−x2−e2+w2=1,
3x2+e3=2,
x1,x2,e1,e2,e3,w1,w2≥0dont le vecteur X=

0 x1
0 x2
0 e1
0 e2
2 e3
1 w1
1 w2est une solution de base réalisable.
Ainsi, on commence notre algorithme 10 pour le programme P0. Le tableau initial est :
x1 x2 e1 e2 e3 w1 w2 b

w1 1 1 −1 0 0 1 0 1
w2 2−1 0 −1 0 0 1 1
e3 0 3 0 0 1 0 0 2
W: 3 0 −1−1 0 0 0 2
Z:−6−3 0 0 0 0 0 0
Le pivot c’est a2,1donc x1est la variable entrante et w2est sortante. On obtient après pivotement le tableau :
L2←1
2L2− − − − − − − − →
L1←L1−L2
L4←L4−3L2
L5←L5+6L2x1 x2 e1 e2 e3 w1 w2 b

w1 03
2−11
20 1−1
21
2
x1 1−1
20−1
20 01
21
2
e3 0 3 0 0 1 0 0 2
W: 03
2−11
20 0−3
21
2
Z: 0 −6 0 −3 0 0 3 3
Le pivot est a1,2(Min ratio test =1
3). On obtient alors :32 Chapitre 4. Programmation linéaire
L1←2
3L1− − − − − − − − →
L2←L2+1
2L1
L3←L3−3L1
L4←L4−3
2L1
L5←L5+6L1x1 x2 e1 e2 e3 w1 w2 b


x2 0 1−2
31
302
3−1
31
3
x1 1 0−1
3−1
301
31
32
3
e3 0 0 2 −1 1 −2 1 1
W: 0 0 0 0 0 −1−1 0
Z: 0 0 −4−1 0 4 1 5
Ainsi, la phase I se termine avec W=0 et x1=2
3,x2=1
3,e3=1 et e1=e2=w1=w2=0. Le tableau pour la
phase II est donc :
x1 x2 e1 e2 e3 b


x2 0 1−2
31
301
3
x1 1 0−1
3−1
302
3
e3 0 0 2 −1 1 1
Z: 0 0 −4−1 0 5
On remarque donc que les cj≤0, donc (STOP) la solution est optimale et le max est −5. Ainsi la solution
optimale pour le programme P=min6 x1+3x2est−(−5)=5=6×2
3+3×1
3.
4.2 Dualité
SoitPun P .L. sous forme canonique. Le programme dualDdePest définit par :
P=max z=cTX
s.t. AX ≤ b
X≥ 0le dual est= = = = = = = ⇒D=min w=bTY
s.t. ATY≥ c
Y≥ 0
Le programme Pest dit primal . On remarque que si Ade type m×n, alors X∈RnetY∈Rmpour le dual.
Théorème 4.1 Théorème de dualité
Si un problème primal ou dual admet une solution, alors l’autre problème admet aussi une solution et on a :
max z=cTX =
s.t. AX ≤ b
X≥ 0min w=bTY
s.t. ATY≥ c
Y≥ 0
Exercice 4.3
Soit le problème suivant de type régime :
D=min w=340x1+2400 x2+560x3
s.t. x1+2x2+x3≥ 1200
x1+3x2+2x3≥ 1400
x1+x2+3x3≥ 1500
x1,x2,x3≥ 0
Écrire le programme primal PdeD. Résoudre le programme Pet déduire la valeur minimale de w, a-t-on
besoin de faire les deux phases du simplexe ?
7} A B oS



HOUSSEM SABRI
Graphes et Optimisation
2`emeannée
LISI  LSI
Institut Supérieur des Sciences Appliquées et de Technologie de Sousse
A.U. 2023-2024
28 novembre 2023Table des matières
1 Les graphes 3
1.1 Définitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.1 Graphes non orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.2 Graphes orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.2 Opérations et quelques types de graphes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.3 Représentation d’un graphe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.1 Listes d’adjacences (ou de succession) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.2 Matrices d’adjacence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.3.3 Matrice d’incidence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2 La connexité 11
2.1 Les chaînes et les cycles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.2 Graphe connexe, eulérien, hamiltonien . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.3 Arbres . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.3.1 Codage et décodage d’un arbre – Prüfer code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.3.2 Arbre couvrant de poids minimum – ACM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3 Les algorithmes de base 20
3.1 Parcours en profondeur (DFS) / largeur (BFS) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
3.2 Recherche des chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.1 Matrice d’adjacence et nombre de chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.2 Plus court chemin et l’algorithme de Dijkstra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
3.3 Problèmes d’ordonnancement et chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
3.3.1 Algorithmes de tri topologique et de chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . 25
4 Programmation linéaire 27
4.1 La méthode simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.1 Solution de base admissible . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux . . . . . . . . . . . . . . . . . . . . . . . . 29
4.1.3 Initialisation - Phase I du simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
4.2 Dualité . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
2CHAPITRE 1
Les graphes
L ’exemple classique pour introduire la théorie des graphes est le problème des ponts de Königsberg, étudié par
Euler en 1736. Quel itinéraire doit-on suivre pour traverser chaque pont exactement une fois? Une telle prome-
nade n’existe pas, et c’est Euler qui donna la solution de ce problème en caractérisant les graphes que l’on appelle
aujourd’hui eulériens .
A
B
Ce1 e2
e3 e4
De5
e6e7
FIGURE 1.1 – Les ponts de Königsberg
Les graphes introduisent une simplification : les régions se transforment en des "points" (aussi appelés noeuds
ousommet ), les ponts se transforment en des lignes (aussi appelées arêtes ouarcs ), et ce principe s’applique dès
lors qu’une relation existe entre des objets. Les graphes relèvent de la combinatoire plutôt que de la géométrie (les
intersections, les longueurs, et la forme des arêtes n’ont aucune importance, sauf en ce qui concerne la lisibilité de
la représentation).
1.1 Définitions
Dans la suite, il est toujours supposé que les graphes sont finis, sauf indication contraire.
1.1.1 Graphes non orientés
Définition 1.1: Graphe
Un graphe Gest un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V{2}des pairs non ordon-
nées de V.Vest l’ensemble des noeuds (Vertices en anglais) et Ec’est l’ensemble des arêtes de G(Edges en
anglais). Lorsque e={x,y} est une arête, on dit que x, y sont les extrémités de cette arête, que eest incidente
enxet en y. On joint x et y par un trait et on dit que x, y sont adjacents (ou voisins). On note aussi e=x you
encore e=(x,y) (attention , dans ce cas : ( x,y)=(y,x)).
SiGest un graphe alors, on note par V(G) l’ensemble de noeuds et par E(G) l’ensemble des arcs.
Remarque 1.
— Une arête e ={x,x}s’appelle boucle .
— Dans un graphe, il peut exister des arêtes parallèles (on parle donc de multigraphe ).
Dans l’exemple des ponts on a : e 1=e2=(A,B).
34 Chapitre 1. Les graphes
— Un graphe est dit simple s’il ne comporte ni arêtes multiples ni de boucles, c’est-à-dire chaque paire de nœuds
distincts est reliée par au plus une arête, ou encore E (G)⊆P2(G).
Dans la plupart des cas, les graphes sont considérés comme simples par défaut.
Définition 1.2: ordre – taille – degré
Soit G=(V,E) un graphe.
1. On appelle ordre d’un graphe noté v(G) le nombre de ses sommets :
v(G)= |V|
2. On appelle taille d’un graphe noté e(G) le nombre de ses arêtes :
e(G)= |E|
3. Le degré (ou valence) d’un sommet xnoté d(x) est le nombre d’arêtes contenant x. (Attention! Une
boucle sur un sommet compte double).
Si on note par Γ(x) l’ensemble des voisins de x, i.e.
Γ(x)={y∈V:x y∈E}
alors, siGest simple , on a :
d(x)= |Γ(x)|
Example 1.1 (Graphe complet)
Un graphe d’ordre nest dit complet noté Knsi chaque sommet du graphe est relié directement à tous les
autres sommets, i.e. E(Kn)=P2(V(Kn)).
Représenter graphiquement K3,K4,k5. Calculer la taille de K3,k4,...Kn.
Example 1.2 (Graphe biparti)
Un graphe G=(V,E) est dit biparti si son ensemble de sommets V=V1˙∪V2, i.e. peut être divisé en deux
sous-ensembles disjoints V1etV2tels que chaque arête ait une extrémité dans V1et l’autre dans V2.
Si∀x∈V1,∀y∈V2;x y∈E, alors Gest dit biparti complet noté Kn,moùn= |V1|etm= |V2|.
a1
 a2
 a3
 a4
b1
 b2
 b3
FIGURE 1.2 – Un graphe biparti
Théorème 1.1 Lemme des poignées de main – Handshaking lemma
Soit Gun graphe alors, on a :X
x∈V(G)d(x)=2e(G)
Dans ce théorème d(x) est le nombre de personnes à qui xserre la main et e(G) le nombre total de poignées
de mains.H. SABRI 5
Preuve.
•Méthode simple Il y en a d(x) arêtes en un sommet xfixé. Pour tout les sommets cela fait doncP
x∈V(G)d(x).
Mais avec cette manière chaque arête est comptée deux fois, une fois à chacune de ses extrémités, d’où le
résultat en divisant par 2.
•Preuve par double dénombrement On pose
Z={(x,e)∈V×E:x∈e}⊆V×E
et les deux projections :
p:Z→V
(x,e)7→xet q:Z→E
(x,e)7→e
L ’idée est de calculer |Z|de deux manières différentes. D’abord, on rappelle que si f:A→Best une fonction
quelconque, alors :X
b∈B|f−1[b]| = | A|
oùf−1[b] désigne l’image réciproque de { b} par f(pourquoi ˙S
b∈Bf−1[b] est une union disjointe ?).
Ainsi on obtient :
|Z| =X
x∈V|p−1[x]| =X
e∈E|q−1[e]|
Or,|p−1[x]| =d(x) et|q−1[e]| = |{x∈V:x∈e}| =2. Donc :
X
x∈Vd(x)=X
e∈E2=2|E|
Remarque 2.
— Un sommet de degré 0est appelé sommet isolé .
— Un graphe tel que : ∀x∈V,d(x)=kest dit graphe k-régulier .
— Le graphe complet K nest un graphe (n−1)-régulier .
Exercice 1.1
Montrer que dans un graphe le nombre de sommets d’ordre impairs est toujours pair. En particulier un
graphe k-régulier avec kimpaire est un graphe d’ordre pair.
Voici quelques exemples comme application :
1. Est-il possible de relier 15 ordinateurs en réseau de sorte que chacun soit relié à exactement 3 autres ?
2. Une ligue de football comprenant 11 clubs organise un tournoi. Pour gagner du temps on décide que chaque
équipe ne jouera que la moitié des matches possibles. Comment organiser le tournoi ?
Proposition 1.1
Soit G=(V,E) un graphe (simple) d’ordre n≥2. Alors :
∃u,v∈V,u̸=v:d(u)=d(v)
Preuve. Supposons le contraire, c’est-à-dire ∀u,v∈V;d(u)̸=d(v). Or dans un graphe (simple) on a toujours d(x)∈
{0,1,..., n−1}. Dans ce cas, puisque tous les nsommets ont des degrés distincts, alors il existe une bijection
{d(x):x∈V}←→ {0,1,..., n−1}
Donc, il existe un sommet uavec un degré 0, et un sommet vavec degré n−1, donc vest connecté à tous les autres
sommets du graphe, ce qui signifie que une peut pas être un sommet isolé, d’où une contradiction.6 Chapitre 1. Les graphes
1.1.2 Graphes orientés
Les arêtes d’un graphe peuvent être orientées, auquel cas une flèche indique la direction. De tels graphes sont
appelés des graphes orientés ou des digraphes , et une arête ( a,b) dans un tel graphe indique que cette arête est
dirigée de sommet avers b, i.e. ( a,b)=− →ab̸=(b,a)=− →ba. D’où la définition :
Définition 1.3: Graphe orienté - digraphe
Un graphe orienté G(ou− →G) est un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V2des pairs
ordonnées de V.Eest l’ensemble des arêtes (ou flèches, arcs) de G. Lorsque e=(x,y) est une arête, on dit
que xestl’origine (ou sommet initiale) et yl’extrémité (ou sommet terminale) de e, que eest sortant en x
et incident en y, et que yest un successeur de xtandis que xest un prédécesseur de y. On note l’arête e
par :
e=(x,y)=− →x y=x→y
De la même façon, une arête x→xest une boucle. On peut toujours supprimer les boucles pour obtenir des
digraphes simples. Voici l’exemple d’un digraphe G=(V,E) d’une fonction f:E→Eoù ( x,y) est un arc si et seule-
ment si y=f(x). On l’appelle digraphe fonctionnelle.
0
3
1214
11 568
169
4
2 1
713 10
15
FIGURE 1.3 – Le digraphe fonctionnelle Gfdex7→(x2+3) mod 17.
Comme dans les graphes on peut définir les degrés (entrant, sortant) d’un sommet dans un digraphe.
Définition 1.4: indegree - outdegree
Soit G=(V,E) un digraphe. Pour v∈V, on note par :
d+(v) le degré extérieur (sortant - outdegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité initiale.
d+(v)= |{v→ •}|
d−(v) le degré intérieur (entrant - indegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité finale.
d−(v)= |{• → v}|
On définit le degré : d(v)=d−(v)+d+(v).
Un sommet de degré entrant non nul et de degré sortant nul est appelé puits , tandis qu’un sommet de
degré entrant nul et de degré sortant non nul est appelé source ouracine .
Dans un graphe orienté, les voisins d’un sommet vsont soit des successeurs ou des prédécesseurs. On les notes
par :
Γ+(x)=Succ (x)={y∈V:x→y∈E} et Γ−(x)=Pr ed (x)={y∈V:y→x∈E}H. SABRI 7
Si le digraphe est simple (ni boucle ni arcs parallèles) on a :
d−(v)= |Γ−(v)|et d+(v)= |Γ+(v)|
Proposition 1.2
Soit Gun digraphe, alors :X
v∈Vd−(v)=X
v∈Vd+(v)= |E|
Preuve. On a
E=˙[
v∈V{• → v}=˙[
v∈V{v→ •}
=⇒ | E| =X
v∈V|{• → v}| =X
v∈V|{v→ •}| =⇒ | E| =X
v∈Vd−(v)=X
v∈Vd+(v)
1.2 Opérations et quelques types de graphes
Une opération sur les graphes permet de construire un nouveau graphe comme résultat de l’opération. Les
opérations courantes sur les graphes sont la suppression, la valuation, l’union, l’intersection et le produit cartésien.
Graphe valué
Tout d’abord, on peut vouloir attribuer des valeurs aux arcs ou arêtes pour tenir compte de contraintes : dis-
tance, coût ...
Définition 1.5: (di)graphe valué
Un (di)graphe valué G=(V,E,w) est un (di)graphe muni d’une application w:E→R. L ’application west
appelée application poids ou coût. On indique sur chaque arête son poids (ou son coût). On note w(x,y)
au lieu de w((x,y)). On convient (même que ceci n’a pas de sens!) que w(x,y)= +∞ si (x,y)∉E.
ab
c
d
ef53
43
3
335
81
FIGURE 1.4 – Un digraphe valué
/pythonPython code : -
Implémenter le digraphe valué précédent avec python. Indice – use chatGPT : how to build a weighted digraph with
python8 Chapitre 1. Les graphes
Sous graphes
Soit G=(V,E) un graphe (orienté ou non). Un sous graphe de Gest un graphe de la forme G′=(V′,E′) où
V′⊆V,E′⊆Etels que toute arête de E′a ses extrémités dans V′(ou encore G′est aussi un graphe). On a :
•Sous-graphe induit Un sous-graphe G′=(V′,E′) de G=(V,E) est appelé un sous-graphe induit deGsi :
∀x,y∈V′; (x,y)∈E′⇐⇒ (x,y)∈E
En d’autres termes, deux sommets de G′qui sont connectés dans G, sont également connectés dans G′.
•Sous-graphe couvrant Un sous-graphe couvrant G′deGcontient tous les sommets de G, i.e. V′=V.
•G−vSupprimer un sommet vd’un graphe Gconsiste à supprimer vet toutes ses arêtes incidentes. Le sous-
graphe obtenu de cette opération est noté G−v, i.e.
V′=V−{v} et E′=E−{(v,y): (v,y)∈E}
De manière similaire, une arête epeut être supprimée (resp. ajoutée) d’un graphe G, et le sous-graphe
résultant est représenté par G−e(resp. G+e). Notez que la suppression d’une arête ne retire pas de sommets
du graphe.
•G−V′=G[V′] On supprimer tous les sommets v∈V′du graphe Gavec les arêtes incidentes. Le sous-graphe
obtenu de cette opération est noté G[V′], i.e.
V(G[V′])=V−V′et E(G[V′])=E−{(v,y)∈E:v∈V′}
•Clique Une clique Cd’un graphe Gest un sous-ensemble des sommets de Gdont le sous-graphe induit G′=
(C,E′) est un graphe complet, en d’autres termes, deux sommets quelconques de la clique Csont toujours
adjacents.
•Stable Un stable – appelé aussi ensemble indépendant (independent set en anglais) est un ensemble de som-
mets deux à deux non adjacents. Donc le sous-graphe induit est sans arcs.
FIGURE 1.5 – L ’ensemble des sommets en bleu dans ce graphe est un stable maximal du graphe.
Note : -
Le problème décisionnel de la clique (c’est à dire existe t-il une clique de taille k) est NP-complet . De même la
recherche d’un stable de taille maximum dans un graphe est un problème NP-complet et difficile à approximer.
Exercice 1.2
Trouver un plus grand stable et une plus grande clique du graphe suivant :
8
4
62 7
3
1 5
Indice : vérifier le résultat avec networkx.find_cliques(G) et.maximum_independent_set(G) de python.H. SABRI 9
Opérations binaires
Union L ’union de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∪H=(VF,EF) dans lequel
VF=VG∪VH et EF=EG∪EH
Intersection L ’intersection de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∩H=(VF,EF)
dans lequel
VF=VG∩VH et EF=EG∩EH
1.3 Représentation d’un graphe
Il est important de savoir comment représenter les graphes au sein d’un ordinateur. Il ya plusieurs méthodes
selon la nature des traitements que l’on souhaite appliquer au graphe considéré.
1.3.1 Listes d’adjacences (ou de succession)
Soit Gun (di)graphe. On suppose que les sommets de Gsont numérotés de S1àSn. La représentation par listes
d’adjacence de Gconsiste en un tableau (ou des listes chainées) tel que la ligne i=1... ncorrespond au sommet Si
et comporte la liste des voisins/successeurs (ou des prédécesseurs) de ce sommet notée T[Si]. Les sommets dans
chaque liste d’adjacence sont généralement listés selon un ordre arbitraire.
1
2
345
FIGURE 1.6 – Un digraphe
La liste d’adjacence de digraphe 1.6 est donc :
1 2 3 4 5
2 3
3 4
4−
5 1 410 Chapitre 1. Les graphes
1.3.2 Matrices d’adjacence
Définition 1.6: Mat. Adjacence
Soit G=(V,E) un graphe (orienté) d’ordre n. On peut numéroter V={1,2,..., n}.La matrice d’adjacence
deGest la matrice carrée A=(ai j) d’ordre n, définie par :
ai j=(
1 si ( i j)∈E;
0 sinon.
Remarque 3.
1. Si le graphe G est non orienté et simple, alors la matrice A est symétrique avec des 0sur la diagonale. Pour un
digraphe simple, on a toujours des 0sur la diagonale, mais la matrice n’est pas symétrique en général.
2. Pour les multigraphes, il peut y avoir des termes diagonaux (pour les boucles) et s’il y a plusieurs arêtes de i à
j , le coefficient de la matrice a i jest le nombre d’arêtes de i à j .
3. Pour un (di)graphe valué G =(V,E,w), on pose :
ai j=(
w(i,j)si(i j)∈E ;
∞ sinon.
La matrice d’adjacence de la figure 1.4 est :

∞ 5∞ 4 3 ∞
∞ ∞ 3∞ 1∞
∞ ∞ ∞ ∞ ∞ 5
∞ ∞ 3∞ 3 3
∞ ∞ ∞ ∞ ∞ 8
∞ ∞ ∞ ∞ ∞ ∞

1.3.3 Matrice d’incidence
Définition 1.7: Mat. Incidence
Soit G=(V,E) un graphe (simple) d’ordre net de taille m. On pose V={v1,v2,..., vn} etE={e1,e2,..., em}.
La matrice d’incidence deGest la matrice de type n×m B=(bi j), définie par :
•Si G orienté
bi j=

1 si ej=vi→ • (i.e. viest l’extrémité initiale de ej) ;
−1 si ej= • → vi(i.e. viest l’extrémité terminale de ej) ;
0 sinon.
•Si G non-orienté
bi j=(
1 si viest une extrémité de ej;
0 sinon.
Exercice 1.3
1. Donner la matrice d’incidence du graphe 1.6.
2. Montrer le théorème 1.1 avec la matrice d’incidence.CHAPITRE 2
La connexité
Il est important de savoir si on peut suivre un chemin d’un sommet donné à un autre dans un graphe donné.
Cette propriété (de connexité) doit être maintenue dans différents types de réseaux.
2.1 Les chaînes et les cycles
Définition 2.1: (chaine – cycle) (chemin – circuit)
•Graphe non orienté
1. Une chaîne (walk ) reliant xày, notée µ(x,y), est définie par une suite finie d’arêtes consécutives,
reliant xày, ou encore une séquence de sommets (puisque non multigraphe)
µ(x,y)=<v0,v1,..., vk>
tels que v0=x,vk=yet (vi−1,vi)∈E(G) pour tout i=1... k. Six=yla chaîne est dite fermée .
Lalongueur du chaîne l(µ(x,y)) est le nombre d’arcs dans la chaîne, c’est-à-dire k.
2. Une chaîne élémentaire (a path ) si tous les sommets sont distincts. Une chaîne simple (a simple
walk, a trail ) est une chaîne ne passant pas deux fois par une même arête, c’est-à-dire dont toutes
les arêtes sont distinctes. Remarquer que : élémentaire =⇒ simple.
3. Un cycle v0v1...vnde longueur n≥3 est une chaîne simple fermée ( v0=vn) tel que les sommets
v0,v1,..., vn−1sont tous distincts. Un graphe sans cycle est dit acyclique .
•Graphe orienté
Dans un graphe orienté, on parlera de chemin au lieu de chaîne, et de circuit au lieu de cycle.
Example 2.1
abxcd xa est une chaîne simple et fermée (non cycle!) de longueur 6 (mais, c’est un graphe eulérien - voir
plus loin). Y a-t-il un cycle de longueur 3,4 ?
a b
x
c dÏ
Remarque 4.
1. On peut pivoter une chaine fermée (l’orienter de manière arbitraire) , i.e.
<v0,v1,v2,..., v0>=< vk,vk+1,..., v0,v1,..., vk>
1112 Chapitre 2. La connexité
2. Soient x ,y∈V . La distance de x à y est définie par :
d(x,y)=(
k si le plus court chemin/chaîne de x vers y est de longueur k
∞ sinon
On convient que d (x,x)=0.
3. Le diamètre du graphe la plus grande distance entre deux sommets.
L ’observation suivante, bien que très facile à prouver, sera utile.
Théorème 2.1
S’il existe une chaîne du sommet yau sommet zdans le graphe G, où y̸=z, alors il existe une chaîne élé-
mentaire ( path ) dans Gavec pour premier sommet yet pour dernier sommet z.
Preuve. Soit la chaine
W1=µ(y,z)=x0x1...xn; avec x0=yetxn=z.
Si les sommets x0,x1,..., xnsont tous distincts, alors W1est une chaîne élémentaire, et nous avons terminé. Sinon,
il existe xi=xj(i<j) et on écrit :
W2=x0x1...xixj+1...xn.
Alors, l(W2)<l(W1). Si W2ne contient aucun sommet répété, alors c’est la chaîne recherché. Sinon, par la même
procédure, il existe W3(y z−chaîne) tel que
l(W3)<l(W2)<l(W1).
Ce processus doit s’arrêter à un certain stade, car chaque chaîne est plus courte que la précédente et la longueur
ne peut jamais être inférieure à 1
1< ··· < l(Wk)< ··· < l(W3)<l(W2)<l(W1).
Ainsi, pour un certain k,Wkne peut pas être réduit en longueur. Donc, la chaîne Wkne contient aucun sommet
répété et est donc une y z−chaîne élémentaire (path).
Exercice 2.1
Dans le graphe suivant, construire un path à partir de la chaîne W=v2v3v4v5v6v4v2v8v1
v1
 v2
v3
v4
v5
v6
v7
 v8
 v9
Calculer d(v1,v7) et le diamètre de G.
/pythonpython : >>G = nx.Graph([(1, 2), (2, 3), (2, 4), ...]) >>nx.diameter(G)
Les cycles fournissent la caractérisation suivante pour les graphes bipartis .H. SABRI 13
Théorème 2.2
Un graphe est biparti si et seulement s’il ne contient aucun cycle de longueur impaire.
Preuve.
⇒On suppose que G=U˙∪Vest un graphe biparti. Soit W=< x1,x2,..., x2k+1,x1>un cycle de longueur im-
paire (2 k+1). Si x1∈U, alors
x1∈U=⇒ x2∈V=⇒ x3∈U=⇒ ··· =⇒ x2k+1∈U=⇒ x1∈V/exclamati⌢n-triangle
absurde, d’où le résultat.
⇐On suppose que Gest connexe (car l’union des composantes connexes bipartis est un graphe biparti). Soit
xun sommet de Get on pose :
U={y∈V(G):d(x,y) est paire} et V={z∈V(G):d(x,z) est impaire}
S’il existe y1,y2∈Utel que y1y2∈E(G), alors on a :
W1=<x,..., y1>est une chaîne de longueur paire =2k1
W2=<x,..., y2>est une chaîne de longueur paire =2k2
=⇒ W3=<x,..., y1,y2,..., x>est un cycle de longueur impaire =2k1+2k2+1/exclamati⌢n-triangle
Donc G=U˙∪Vest un graphe biparti.
Exercice 2.2
Vérifier si le graphe maison est un graphe biparti. Faire de même pour la grille G4,4.
maison grille
2.2 Graphe connexe, eulérien, hamiltonien
Définition 2.2: Graphe connexe
Un graphe est dit connexe si deux points peuvent toujours être joints par une chaîne, i.e.
∀x,y∈V(G),d(x,y)< ∞
— Une composante connexe d’un graphe est un sous-graphe induit maximal connexe.
— Un point d’articulation d’un graphe est un sommet dont la suppression augmente le nombre de
composantes connexes.
Par exemple, le graphe suivant :14 Chapitre 2. La connexité
a
 b
d
 c
e
f
 g
n’est pas connexe car il n’existe pas de chaîne entre les sommets aete. On a donc 2 composantes connexes. En
revanche, le sous-graphe induit par les sommets { a,b,c,d} est connexe dont aest le seul point d’articulation.
Remarque 5.
1. Un graphe connexe à n sommets possède au moins n −1arêtes ( faite une preuve par récurrence ).
2. L’algorithme de parcours en profondeur permet de déterminer si un graphe est connexe ou non.
3. Même définitions dans un graphe orienté . Graphe orienté (fortement) connexe et de composante connexe .
Définition 2.3: Graphe eulérien
— Une chaîne joignant deux sommets xetyest dite chaîne eulérienne si elle emprunte chaque arête
deGune et une seule fois. On parle de chemin eulérien dans le cas d’un graphe orienté.
— Un cycle eulérien est une chaîne eulérienne dont les extrémités coïncident. Un graphe qui admet
un cycle (resp. circuit) eulérien est dit graphe eulérien .
/flushedRemarquer qu’un cycle eulérien n’est pas forcément un cycle comme définit dans la définition 2.1
Si un graphe (ou multigraphe) Gpossède une chaîne eulérienne, alors soit Gpossède deux sommets impairs, le
début et la fin de cette chaîne, soit Gn’a aucun sommet impair, et la promenade d’Euler commence et se termine
au même point (cycle eulérien). Une autre condition nécessaire évidente est que Gdoit être connexe. Ces deux
conditions sont ensemble suffisantes.
Théorème 2.3 Euler
Soit Gun graphe (multigraphe) connexe.
— Si Gn’a pas de sommets impairs, alors il possède un cycle eulérien (commençant à n’importe quel
point).
i.e.∀x,d(x)≡0 mod 2 =⇒ Gest un graphe eulérien.
— Si Ga deux sommets impairs, alors il possède une chaîne eulérienne dont le début et la fin sont les
sommets impairs.
La réciproque est aussi vraie.
Preuve.
⇐On commence par la réciproque. S’il existe une chaîne eulérienne µ(x,y), alors on peut crée une arête fictive
e=(y,x) et par la suite on obtient un cycle eulérien. Donc il suffit de montrer que si Gadmet un cycle
eulérien alors tous les sommets sont de degré pair.
Soit W=< v1,v2,..., vn,v1>un cycle eulérien. Soit le sommet vjavec j̸=1, il est donc claire que chaque
fois vjapparaît dans W, il ya deux arcs distincts incidents en vj( (•,vj) et ( vj,•)). Comme toutes les arêtes
sont utilisées, on voit que d(vj) est pair. Même chose pour v1car on ajoute deux arcs ( v1,v2) et ( v1,vn).
⇒On suppose que tous les sommets sont de degré pair. Montrons que Gadmet un cycle eulérien. Puisque
tous les sommets sont de degré pair on peut construire d’abord une chaîne simple fermée (quelconque)
W1=<v1,v2,..., vk,v1>
SiW1contient chaque arête de G, alors c’est finis, c’est un cycle eulérien. Sinon (puisque Gest connexe), il
existe une arête e=(vi,c) qui n’est pas dans W1(avec visommet de W1). On pose le sous-graphe
G′=G−{ arêtes de W1}H. SABRI 15
Il est donc claire que les sommets de G′sont aussi de degré pair. Alors, par la même procédure on construit
une chaîne simple fermée dans G′de la forme : <vi,c,d,..., vi>et par la suite on insère cette chaîne dans
W1pour obtenir :
W2=<v1,v2,..., vi,c,d,..., vi,vi+1,..., vk,v1>
Sil(W2)< |E(G)|, on construit W3de longueur plus grand. Ainsi, on a :
l(W1)<l(W2)<l(W3)< ··· ≤ | E(G)|
Donc, nécessairement, il existe Wk(chaîne simple fermée de longueur |E(G)|) donc c’est un cycle eulérien.
Finalement , si∃a,b∈V(G):d(a)≡d(b)≡1 mod 2, et tous les autres sommets sont de degré pair, alors on
pose :
G′=G+{a,b}
et donc tous les sommets de G′sont de degré pair. Avec la construction précédente, il existe un cycle eulérien
dans G′:
W=<a,b,v1,..., a>
est donc la chaîne <b,v2,..., a>est une chaîne eulérienne dans G.
Algorithme 1 : Euler
Entrées : Gun graphe eulérien
Output : Un cycle eulérien W
/* On suppose que G est eulérien, i.e. les sommets sont de degré pair */
1Gaux←G;W←µ(v,v) une chaîne simple (quelconque) de G; // Initialisation
2tant que l(W)<e(G)faire
3 Gaux←G−{ arêtes de W} ;
4 Choisir ( x,c)∈E(Gaux) tel que x∈W;
5 L←< x,c,..., x>une chaîne simple de Gaux ;
6 Dans W, remplacer (juste ce) xpar la séquence L;
7fin
8retourner W;
Exercice 2.3
1. Montrer que le graphe de l’exercice 2.1 est un graphe eulérien et donner un cycle eulérien.
2. Tracer cette maison d’un seul trait.
Remarque 6. Le théorème d’Euler dans un graphe orienté connexe s’écrit :
Admet un circuit eulérien si, et seulement si, pour tout sommet, le degré entrant est égal au degré sortant.
∀v∈V(G),d+(v)=d−(v)
Admet un chemin eulérien de a vers b si, et seulement si,


d+(v)=d−(v) ;∀v̸=a,b,
d−(a)=d+(a)−1
d−(b)=d+(b)+116 Chapitre 2. La connexité
Définition 2.4: Graphe hamiltonien
Soit Gun graphe connexe d’ordre n. On appelle :
1. On appelle cycle hamiltonien deGun cycle passant (une et une seule fois) par chacun des sommets
deG. Un graphe est dit hamiltonien s’il possède un cycle hamiltonien.
2. Une chaîne hamiltonienne est une chaîne passant une et une seule fois par chacun des sommets de
G. Un graphe ne possédant que des chaînes hamiltoniennes est semi-hamiltonien .
3. Dans un digraphe, on change cycle par circuit et chaîne par chemin .
Remarque 7.
— Une chaîne hamiltonienne est une chaîne élémentaire de longueur n −1.
— Un graphe peut être eulérien, hamiltonien, les deux à la fois, ou aucun des deux.
— De nombreux problèmes concrets peuvent être formulés en termes de recherche de parcours hamiltoniens : pro-
blème du voyageur de commerce (chercher un cycle hamiltonien de longueur totale minimale), l’ ordonancement
de tâches .
— Le problème du chaîne hamiltonienne est un problème NP-complet .
Exercice 2.4
Donner un graphe (connexe, simple) qui soit :
1. hamiltonien et eulérien.
2. hamiltonien et non eulérien.
3. eulérien et non hamiltonien.
4. non hamiltonien et non eulérien.
Aucune condition nécessaire et suffisante adéquate n’est connue pour l’existence de cycles hamiltoniens. Le
résultat suivant constitue une condition suffisante utile.
Théorème 2.4 Ore
Soit Gun graphe simple d’ordre n≥3. Si pour toute paire { x,y} de sommets non adjacents, on a d(x)+d(y)≥
n, alors Gest hamiltonien.
Preuve. On suppose que le théorème est faux. Alors, il existe un graphe Gsimple d’ordre nnon hamiltonien tel que
d(u)+d(v)≥npour tout sommets non adjacents uetv. On prend Gun tel graphe d’ordre nde taille maximale qui
vérifie cette propriété (remarquer que le graphe complet Knest hamiltonien).
Soient uetvdeux sommets non adjacents de G. Par maximalité de G, le graphe G+uv(d’ordre n) doit être
hamiltonien. Donc il existe dans G+uvun cycle hamiltonien :
W=<u,x1,x2,..., xn−2,v,u>
u
x1
xi xi+1xn−2
v
... ...
Or, si uxi+1∈E(G) etv xi∈E(G) (les arcs en rouge), alors on peut construire dans Gle cycle hamiltonien :
<u,x1,x2,..., xi,v,xn−2,..., xi+1,u>H. SABRI 17
Ceci est absurde car Gest non hamiltonien. Donc si xi+1est un sommet voisin à u, alors le sommet xin’est pas
voisin de v:
xi+1∈Γ(u)=⇒ xi∉Γ(v)
Donc :
d(u)= |Γ(u)| =p=⇒ d(v)≤(n−1)−p
et par la suite
d(u)+d(v)≤n−1
ce qui absurde par hypothèse. Donc Gest hamiltonien.
Une conséquence immédiate est le théorème de Dirac :
Proposition 2.1 Dirac
Soit Gun graphe simple d’ordre n≥3. Si pour tout sommet xdeG, on a d(x)≥n
2, alors Gest hamiltonien.
2.3 Arbres
Définition 2.5: Arbres et forêts
On appelle arbre tout graphe (non orienté) connexe et acyclique . Les composantes connexes dans un
graphe acyclique sont des arbres et le graphe est dit forêt . Une feuille ou sommet pendant est un som-
met de degré 1.
Un forêt avec deux arbres
Un graphe Gest une arborescence s’il existe un sommet Rappelé racine deGtel que, pour tout sommet
SdeG, il existe un chemin et un seul de Rvers S. Donc, c’est un arbre orienté dans lequel on choisit un
sommet Rcomme racine et on dirige les arcs vers le sens sortant de la racine.
Remarque 8.
— Un graphe G d’ordre n est un arbre ssi G est sans cycle et possède n −1arêtes.
— Un graphe G d’ordre n est un arbre ssi G est connexe et possède n −1arêtes.
— G est un arbre si pour chaque paire u ,v de sommets distincts est reliée par une seule chaîne (donc chaîne
élémentaire d’après le théorème 2.1).
— Un arbre (ou forêt) est nécessairement un graphe simple.
Pour démontrer les remarques précédentes, il suffit de prouver le théorème suivant :
Théorème 2.5
Soit Gun graphe ayant marêtes, nsommets et pcomposantes connexes, on définit nu( G) :
ν(G)=m−n+p
Alors, on a :
1.ν(G)≥0.
2.ν(G)=0⇐⇒ Gest acyclique.18 Chapitre 2. La connexité
Preuve. Par récurrence sur la taille mdu graphe. Le résultat est évident pour m=0 et m=1. On suppose le résultat
est vrai pour les graphe de taille m, et montrons que ceci est vrai pour un graphe de taille m+1. Soit donc Gun
graphe d’ordre nde taille m+1 ayant pcomposantes connexes.
•On suppose que Gest un graphe acyclique. Soit uvune arête de Gdans la composante C. Si on supprime uv,
la composante Cse transforme en deux composantes connexes (sinon on a un cycle dans G). Par la suite,
le graphe G′=G−uvest un graphe acyclique d’ordre n, de taille met ayant p+1 composantes connexes.
Donc d’après l’hypothèse de récurrence :
ν(G′)=0=(m−1)−n+(p+1)=m−n+p=ν(G)
•Maintenant, si Gcontient un cycle Wdans la composante connexe C. Soit uvune arête de W, alors si on
supprime l’arête uv, la composante Creste connexe. Donc le graphe G′=G−uvest un graphe d’ordre nde
taille m−1 ayant pcomposantes connexes. Donc, d’après l’hypothèse de récurrence :
ν(G′)=(m−1)−n−p≥0
=⇒ν(G)=m−n−p≥1>0
D’où le résultat – car si ν(G)=0,Gne peut être que acyclique, sinon 0 =ν(G)≥1/exclamati⌢n-triangle
2.3.1 Codage et décodage d’un arbre – Prüfer code
Soit Tun arbre ayant nsommet numérotés {1,2,..., n}. Le codage de Prüfer représente l’arbre Tarbre de avec
une suite P=(x1,x2,x3,..., xn−2) de n−2 termes (les n° des sommets avec répétition possible). Une suite Pdonnée
correspond à un et un seul arbre numéroté. Voici les algorithmes de codage et de décodage.
Algorithme 2 : Codage de Prüfer
Entrées : Un arbre T
Output : Séquence de Prüfer P
1P←() ; // Initialisation de P comme séquence vide
2tant que v(T)>2faire
3 x←feuille de Tayant le n° minimum ; // donc d(x)=1
4 P←(P,s) où sest le seul (n°) sommet adjacent à x;
5 T←T−x;
6fin
7retourner P;
Example 2.2
Donner le code de Prüfer de l’arbre :
126 345
Indice : on trouve, P=(2,3,3,2)
Pour faire la réciproque, étant donnée une séquence P=(x1,x2,..., xn−2) où les xi∈{1,2,..., n}, on construit
l’arbre Tdont les sommets sont {1,2,..., n} avec l’algorithme suivant (le décodage) :H. SABRI 19
Algorithme 3 : Décodage de Prüfer
Entrées : Une séquence Pde taille n−2
Output : L ’arbre Tcorrespondante
1I←{1,2,..., n};
2T←graphe tel que V(T)=IetE(T)= ; ; // T graphe à n sommets isolés
3tant que P̸=()faire
4 i←min {x∈I:x∉P};
5 T←T+(i,P[1]) ; // ajouter l'arc (i,P[1])
6 P←P−P[1];I←I−{i};
7fin
8T←T+(a,b) ; // a,b sont les deux éléments restant dans I
9retourner T;
Example 2.3
Donner l’arbre dont le code de Prüfer est : P=(2,3,3,3)
Puisqu’il ya une bijection entre les arbres d’ordre net les suites Pde longueur n−2 à coefficients dans {1,2,..., n},
on déduit le théorème de Cayley :
Théorème 2.6 Formule de Cayley
Le nombre d’arbres que l’on peut construire sur n(n≥2) sommets numérotés est égal à nn−2.
2.3.2 Arbre couvrant de poids minimum – ACM
Soit Gun graphe (non orienté). Un arbre couvrant (spanning tree) TdeGest un sous graphe couvrant de G
tel que Test un arbre. Remarquer que, Gdoit être connexe, sinon un arbre couvrant de Gn’existe pas. Le nombre
des arbres couvrant de Gest noté a(G). Remarquer que a(Kn)=nn−2(le nombre de Cayley). Un problème algo-
rithmique classique est de trouver, dans un graphe valué , un arbre couvrant de poids minimal . On dispose de
plusieurs algorithmes (l’algorithme de Prim, l’algorithme de Kruskal ...).
Algorithme 4 : Kruskal
Entrées : Un graphe Gvalué d’ordre net de taille m
Output : Arbre (ou forêt) couvrant de poids minimum
1Numéroter les arêtes de Gpar poids minimum : w(e1)≤w(e2)≤ ··· ≤ w(em)
2T←graphe tel que V(T)=V(G) etE(T)= ; ; // T graphe à n sommets isolés
3k←0;
4tant que k<m et e (T)<n−1faire
5 siT+ek+1est acyclique alors
6 T←T+ek+1;
7 k←k+1;
8fin
9retourner T;
Appliquer l’algorithme de Kruskal dans le graphe suivant :
CHAPITRE 3
Les algorithmes de base
Beaucoup de problèmes sur les graphes nécessitent que l’on parcourt l’ensemble des sommets et des arcs. Par
exemple, pour vérifier que le graphe est connexe, chercher un sommet particulier, construire un arbre couvrant,
trouver un plus court chemin ...etc.
3.1 Parcours en profondeur (DFS) / largeur (BFS)
Une manière simple de tester si un graphe Gest connexe ou non est d’exécuter l’algorithme DFS ouBFS dans
Gen commençant par n’importe quel sommet et en enregistrant les sommets visités pendant l’exécution dans une
liste. Si la liste contient tous les sommets de G, alors Gest connexe. Une petite modification permet de donner les
composantes connexes de G. L ’algorithme DFS_Component suivant donne les composantes connexes de G. Il est
donné sous forme d’implémentation récursive.
Algorithme 5 : DFS_Component
Entrées : Un graphe G=(V,E)
Output : Les composantes connexes C=(C1,C2,..., Ck) de G.
1VisitedNodes ← ; ;
2k←0 ; // k est le nombre des composantes connexes
3pour chaque u∈Vfaire
4 siu∉VisitedNodes alors
5 k←k+1;
6 DFS( u);
7 fin
8fin
9retourner (C1,C2,..., Ck);
1Procedure DFS( u )
2 VisitedNodes ←VisitedNodes ∪{u};
3 Ck←Ck∪{u};
4 pour chaque x∈Γ(u)faire
5 six∉VisitedNodes alors
6 DFS( x);
7 fin
8 fin
Note : -
Il est possible de d’implémenter la procédure DFS itérativement à l’aide d’une pile LIFO (stack) contenant les
sommets à explorer : on désempile un sommet et on empile ses voisins non encore explorés.
20H. SABRI 21
Pseudocode :
stack . push ( root )
while stack . isEmpty ( ) = f a l s e do
node = stack . pop ( ) // so mark i t as v i s i t e d
for each x in node . childNodes do
i f x i s not v i s i t e d then
stack . push ( x )
. . .
endfor
endwhile
Example 3.1 (DFS )
Ici on empile (gris) les sommets les plus à droite, alors l’ordre des sommets visité (noir) est ( a,b,d,e,g,c,f).
Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b
 c
d
 e
f
g
a
b
 c
d e
f
ga
b
 c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g
L ’utilisation d’une file (FIFO) au lieu d’une pile transforme l’algorithme du parcours en profondeur en algo-
rithme de parcours en largeur ( BFS ). Avec BFS l’exemple précédent devient (en enfile le plus à gauche) :
Example 3.2 (BFS )
Ici, avec BFS, on enfile (gris) les sommets les plus à gauche d’abord, alors l’ordre des sommets visité (noir)
est ( a,b,d,e,g,c,f). Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b c
d
 e
f
g
a
b c
d
 e
f
ga
b c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g22 Chapitre 3. Les algorithmes de base
Exercice 3.1
1. Écrire la procédure BFS .
2. Utiliser DFS (ou BFS) pour la construction d’un arbre couvrant d’un graphe connexe. L ’appliquer
pour le graphe triangle.
3. Utiliser DFS pour écrire une procédure DFS_Cycle pour détecter un cycle dans un graphe.
On sait qu’un graphe orienté G=(V,E) est fortement connexe si pour chaque paire de sommets u,v∈V, il
existe un chemin de uàvet il existe un chemin de vàu. En d’autres termes, nous avons besoin d’une connectivité
dans les deux directions .
Une procédure pour tester si un graphe orienté est fortement connexe ou non peut être conçue avec l’idée
suivante. En partant d’un sommet arbitraire vdu graphe G, on exécute l’algorithme BFS ouDFS et l’on note les
sommets visités. Ensuite, on obtient la transposée de G,GT, en inversant la direction des arêtes de G, et l’on
exécute à nouveau l’algorithme BFS ou DFS à partir du sommet v. Si les sommets visités dans les deux cas sont
égaux à V, alors le graphe orienté est fortement connexe. Cette méthode est illustrée dans l’algorithme 6.
Algorithme 6 : Fortement_connexe
Entrées : Un graphe orienté G=(V,E)
Output : true siGest fortement connexe et false sinon
1X← ; ;
2Y← ; ;
3v←un sommet quelconque de V;
4X←DFS( G,v) ; // Enregistrez les sommets visités dans X
5GT←Gavec flèches inversées;
6Y←DFS( GT,v);
7siX=Y=Valors
8 retourner TRUE.
9sinon
10 retourner FALSE.
11fin
3.2 Recherche des chemins
3.2.1 Matrice d’adjacence et nombre de chemins
La puissance de la matrice d’adjacence Amontre qu’il y a des chemins (ou chaînes) de longueur kallant de xà
ycomme le montre le théorème suivant.
Théorème 3.1
Soit G=(V,E) un (di)graphe. On note V={1,2,..., n} et Asa matrice d’adjacence et Akla puissance k-ème
deA. Alors le terme d’indices i,jdeAkest le nombre de chemins (chaînes) de longueur kallant de iàj.
Preuve. Par récurrence sur k. Pour k=1 c’est clair. On suppose le résultat est vrai à l’ordre ket montrons qu’elle
est vrai pour k+1. Soit S=(si,j)=Ak. Si on a un chemin de iàjde longueur k+1, alors on va d’abord de ià un
sommet ravec kpas et puis de ràj. Or d’après l’hypothèse de récurrence on a si,rchemins possibles pour aller de
iàret finalement ar,jpas (1 ou 0) pour aller de ràj. Ainsi, le nombre totale possibles (i.e. tous les sommets r) est :
nX
r=1si,rar,j=³
Ak×A´
i,jH. SABRI 23
ce qui est bien le terme ( i,j) de la matrice Ak+1.
3.2.2 Plus court chemin et l’algorithme de Dijkstra
Dans cette partie on suppose que le (di)graphe G=(V,E,w) est valué positivement (i.e.∀e∈E,w(e)>0). Notre
objectif est de chercher un plus court chemin (i.e., un chemin de poids minimal ) d’un sommet ufixé à un sommet
quelconque de G.
Il est clair que l’on peut restreindre ce problème au cas d’un (di)graphe simple1. On suppose aussi que Gest
connexe (sinon, certains trajets sont impossibles). Il est aussi claire (d’après théorème 2.1), qu’un plus court chemin
est nécessairement un chemin élémentaire (path).
L ’algorithme de Dijkstra (1959) permet de calculer le plus court chemin entre un sommet particulier u(racine )
et tous les autres sommets. L ’algorithme fonctionne de la manière suivante :
Pour tout sommet vdeG, on associe une valeur T(v), initialisée à w(u,v) et une liste de sommets C(v) qui
correspond à un chemin de uàv. À la fin de l’algorithme, T(v) contient le poids minimal des chemins joignant uà
v(ou T(v)= ∞ siu↛v) et la liste C(v) réalise un tel chemin. Voici donc l’algorithme de Dijkstra :
Algorithme 7 : Algorithme de Dijkstra
Entrées : Un (di)graphe valué G=(V,E,w) et un sommet racine u
Output : Le coût minimum d’un chemin de uàv(∀v∈V) et un trajet pour chaque coût minimal obtenu
1∀v∈V,T(v)←w(u,v) etC(v)←(u,v); // Initialisation de T(v) et la liste C(v)
2X←{u};
3tant que X̸=Vfaire
4 Choisir v∈V−Xtel que ∀y∈V−X,T(v)≤T(y);
5 X←X∪{v};
6 pour chaque y∈V−Xfaire // Faire les mises à jours pour les autres sommets
7 siT(y)>T(v)+w(v,y)alors
8 T(y)←T(v)+w(v,y);
9 C(y)←[C(v),y]; // On ajoute à la liste C(v) l'élément y
10
11 fin
12 fin
13fin
Example 3.3
Voici une application de l’algorithme de Dijkstra au digraphe suivant. On prend Ecomme sommet racine.
EA
B
CD
FG
S5
4
21
12
2
34
4
215
7
1. En effet, passer par une boucle ne ferait qu’augmenter inutilement le poids de ce chemin. De même, si plusieurs arcs joignent deux
sommets, il suffit de conserver l’arc de poids minimal.24 Chapitre 3. Les algorithmes de base
Ainsi, pour l’initialisation, on a : X={E} et on a les valeurs :
v  E A B C D F G S
T(v) 0 5 4 2 ∞ ∞ ∞ ∞
C(v)(E,E) ( E,A) ( E,B) ( E,C) ( E,D) ( E,F) ( E,G) ( E,S)
Maintenant, on choisit (un seul choix) le sommet C, donc X={E,C}. Le tableau est mis à jour :
v  E A B  C D F G S
T(v) 0 5 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À l’étape suivante, on est forcé de choisir B. Ainsi, X={E,C,B} et la mise à jour est :
v  E A  B  C D F G S
T(v) 0 4 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À présent, on a le choix entre AetF. On choisit A. Donc X={E,C,B,A} et on a :
v  E  A  B  C D F G S
T(v) 0 4 3 2 6 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,B,A,D) ( E,C,F) ( E,C,G) ( E,S)
Puis, on prend le sommet F. D’où X={E,C,B,A,F} et :
v  E  A  B  C D  F G S
T(v) 0 4 3 2 5 4 5 11
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,S)
On prend Det on obtient X={E,C,B,A,F,D} et :
v  E  A  B  C  D  F G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Finalement, on prend Gpuis Set on voit que ceci ne change rien. D’où le tableau finale :
v  E  A  B  C  D  F  G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Ainsi le chemin minimum pour aller de EàSest de coût 10 et un trajet de coût minimal de EàSest : EC F DS .H. SABRI 25
3.3 Problèmes d’ordonnancement et chemin critique
Un problème d’ordonnancement peut-être représenté sous la forme d’un digraphe. Les sommets sont des évé-
nements (début et fin de la tâche) et les arcs des tâches, La longueur (ou poids) de chaque arc représente la durée
d’exécution de la tâche. Ainsi, la tâche correspondant à l’arc ( i,j) ne peut commencer que si toutes les tâches cor-
respondant à des arcs ( k,i) ont été complétées. On ajoute deux sommets pour le début (s) et de fin(t) du projet .
Le digraphe peut contenir des tâches fictives dedurée nulle afin de forcer certaines précédences (postériorité).
Ainsi, un réseau PERT est un digraphe valué G=(V,E,w,s,t) où la fonction poids (ou longueur) w:E→R+
etsle sommet source (début) et tle sommet puits (fin). Un chemin critique est un chemin de sàtdelongueur
maximale . S’il n’existe pas de chemin critique, le projet n’est pas réalisable (e.g. un circuit). Le temps minimal
requis pour l’exécution d’un projet réalisable est égal à la longueur d’un chemin critique. Les tâches figurant sur un
chemin critique sont aussi appelées critiques, ce qui s’explique par le fait que tout retard d’exécution d’une tâche
critique retarde d’autant l’exécution du projet.
3.3.1 Algorithmes de tri topologique et de chemin critique
Il faut d’abord numérotés les sommets de 1 à nde manière compatible au pré-ordre (rang) avec l’algorithme du
rang suivant (tri topologique) :
Algorithme 8 : Algorithme du rang
Entrées : Un digraphe G=(V,E) sans circuit
Output : Le rang r(v) de chaque sommet v∈Vde G
1r←0;X←V;
2R←{v∈X:Γ−
X(v)= ;} ; // l'ensemble des sommets de X sans prédécesseur dans X
3tant que X̸= ; faire
4 r(v)←rpour chaque sommet v∈R;
5 X←X−R;
6 R←l’ensemble des sommets de Xsans prédécesseur dans X;
7 r←r+1;
8fin
On supposera dorénavant que les sommets ont déjà été numérotés de 1 à nde manière compatible avec leurs
rangs, c’est-à-dire que r(j)>r(i) implique j>i(donc 1 =setn=t). Enfin, on supposera éliminés les arcs paral-
lèles par l’introduction de tâches fictives de durée nulle .
Pour un sommet i, on note tiledébut au plus tôt des tâches correspondant aux arcs i→jet par Tilafin au
plus tard des tâches correspondant aux arcs j→i.
Algorithme 9 : Algorithme du chemin critique
Entrées : Un digraphe G=(V,E) sans circuit trié topologiquement
Output : La durée du chemin critique et les dates ti,Ti
1t1←0;
2pour j=2···nfaire // Calcul des dates de début au plus tôt  récurrence en avançant
3 tj←max i∈Γ−(j){ti+w(i,j)}
4fin
5Tn←tn;
6pour j=n−1···1faire // Calcul des dates de fin au plus tard  récurrence en reculant
7 Tj←min i∈Γ+(j){Ti−w(j,i)}
8fin26 Chapitre 3. Les algorithmes de base
Définition 3.1
— Un sommet iest critique si ti=Ti.
— Un arc ( i,j) est critique les sommets ietjsont critiques ettj−ti=w(i,j).
— Un chemin critique est un chemin de 1 à nn’utilisant que des arcs critiques.
— La durée du chemin critique est donnée par Tn(ou par tn). Elle correspond à la durée minimale du
projet .
Example 3.4
L ’application de l’algorithme du chemin critique au digraphe suivant (trié topologiquement) est :
1 23
45
6B
9A
3
C
5D
8
E
4
F7G
20
H6I5
=⇒
 1
0,02
9,933,16
4
16,23513,24
6
29,29B
9A
3
C
5D
8
E
4
F7G
20
H6I5
Les tâches critiques sont BetG. La durée totale minimale du projet est donc 29.
Exercice 3.2
Les tâches ( durée et précédences ) pour la construction d’un entrepôt sont données dans le tableau suivant :
Tâches Nature Précédences Durée (jours)
A Acceptation des plans par le propriétaire – 4
B Préparation du terrain – 2
C Commande des matériaux A 1
D Creusage des fondations A, B 1
E Commande des portes et fenêtres A 2
F Livraison des matériaux C 2
G Coulage des fondations D, F 2
H Livraison des portes et fenêtres E 10
I Pose des murs, de la charpente et du toit G 4
J Mise en place des portes et fenêtres H, I 1
1. Représentez le graphe des précédences de ce projet (trié topologiquement).
2. Déterminez une durée totale minimale en exhibant un chemin critique dans ce graphe.CHAPITRE 4
Programmation linéaire
La programmation linéaire est le processus de minimiser ou maximiser une fonction objective linéaire sou-
mise à un nombre fini de contraintes d’égalités et d’inégalités linéaires.
La programmation linéaire a de nombreuses applications dans le domaine de l’informatique théorique. Elle
peut être utilisée pour résoudre de nombreux problèmes combinatoires variés, tels que la recherche de flot maxi-
mum dans un réseau, la recherche d’un couplage maximal dans un graphe et la coloration d’un graphe parfait.
Example 4.1 (Problème de régime)
On suppose qu’on a quatre plats : de la truite ( XT), un sandwich au corned-beef ( XC B), un burrito ( XBU R )
et un hamburger ( XHB). Le tableau suivant répertorie la valeur nutritionnelle de chaque plat (vitamines et
calories) et notre besoin journalier des vitamines.
Vit. A Vit. C Vit. D Calories
Truite 203 92 100 600
Corned-beef 90 84 230 350
Burrito 270 80 512 250
Humburger 500 90 210 500
Besoins 2000 300 430
Notre objectif est de minimiser le nombre total de calories consommées : 600 XT+350XC B+250XBU R+
500XHBtout en satisfaisant les trois besoins nutritionnels en vitamines. Le programme linéaire résultant
s’écrit :
min 600 XT+350XC B+250XBU R+500XHB
s.t. 203 XT+90XC B+270XBU R+500XHB≥2000, (Besoins de Vit. A),
92XT+84XC B+80XBU R+90XHB≥300, (Besoins de Vit. C),
100XT+230XC B+512XBU R+210XHB≥430, (Besoins de Vit. D),
XT,XC B,XBU R ,XHB≥0
Définition 4.1: Forme canonique – Forme standard
On peut écrire un P .L. sous deux formes spéciales :
•Canonique
max
mincTX+c0
s.t. AX≤b(≥bsi min),
X≥0•Standard
max cTX+c0
s.t. AX=b,
X≥0Avec :
cTX=¡
c1··· cn¢
x1
...
xn

cTX+c0=c1x1+c2x2+···+ cnxn+c0
2728 Chapitre 4. Programmation linéaire
Remarque 9. Un P .L. général peut être formulé selon une forme standard ou canonique par la méthode suivante :
générale =⇒ standard il faut éliminer les contraintes d’inégalité et les variables sans contrainte de positivité.
— Si dT
iX≤biest une contrainte d’inégalité, alors créer une nouvelle variable ( d’écart ) siet remplacer l’in-
égalité dT
iX≤bipar dT
iX+si=biet s i≥0.
Si dT
iX≥bi, alors on peut écrire dT
iX−si=biet s i≥0.
— Si une variable x i≶0est de signe quelconque, alors créez deux nouvelles variables x+
iet x−
iet remplacez
xipartout par x+
i−x−
i, et ajoutez les contraintes de signe : x+
i≥0,x−
i≥0.
générale =⇒ canonique
— Si dT
iX=biest une contrainte d’égalité, alors remplacer cette égalité par une paire d’inégalités :
dT
iX≥biet−dT
iX≥ −bi
— Même chose que précédemment si la variable x i≶0.
Il est facile de voir que les problèmes qui en résultent sont équivalents aux problème d’origine. Pour l’algorithme
simplexe , nous utiliserons la forme standard .
On remarque aussi qu’en utilisant la relation min f(x)= − max¡
−f(x)¢
dans laquelle f (x)représente la fonction-
nelle linéaire à optimiser, on peut toujours se ramener à un problème de minimisation (ou de maximisation).
Example 4.2
Le P .L :max 5 x+4y
s.t. x≤6
1
4x+y≤6
3x+2y≤22
x,y≥0s’écrit sous forme standard :max 5 x1+4x2
s.t. x1+e1=6
1
4x1+x2+e2=6
3x1+2x2+e3=22
x1,x2,e1,e2,e3≥0
Donc (sous la forme matricielle) on a :
cT=¡
5 4 0 0 0¢
;A=
1 0 1 0 0
1
41 0 1 0
3 2 0 0 1
;X=
x1
x2
e1
e2
e3
et b=
6
6
22

4.1 La méthode simplexe
4.1.1 Solution de base admissible
On suppose que la matrice Adu programme linéaire est de type m×netde rang m(pourquoi !). Soit Bla
matrice carrée extraite de Aformée par les mcolonnes j1,j2,..., jmlinéairement indépendants de A(les vecteurs
de base). Alors, Best une matrice inversible. Ainsi si on pose xl=0 sil∉{j1,..., jm} etxjklak-ième composante de
B−1b. Alors, on a AX B=b. Si de plus XB≥0(i.e. chaque xi≥0), alors :
Xest une solution de base admissible (ou réalisable)
Dans l’exemple 4.2, la matrice extraite B=
1 0 0
0 1 0
0 0 1
est inversible et B−1b=
6
6
22
. Donc XB=
0
0
6
6
22
≥0, par suite
XBest une solution de base admissible. On appelle les variables xjklesvariables de base . Les autres variables xl
sont les variables hors-base .
Parfois, il n’est pas évident de trouver une solution de base admissible, comme le montre l’exercice suivant :H. SABRI 29
Exercice 4.1
Écrire le programme linéaire suivant sous forme standard et montrer qu’on n’a pas une solution de base
admissible. Résoudre le programme linéaire.
max −x+y
s.t. x+y≥1,
3x+2y=6,
x,y≥0
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux
Dans cette section, on suppose qu’on a déjà trouvé une solution de base admissible X(produite avec B=Im)
du programme linéaire ( P: max z=cTX+c0etb≥0pour garantir que 0est une solution de AX≤b).
La méthode du simplexe est une méthode itérative qui génère une séquence de solutions de base réalisable
(correspondant à différentes bases) et s’arrête finalement lorsqu’elle a trouvé une solution de base réalisable opti-
male. Remarquer qu’on peut toujours prendre c0=0.
Algorithme 10 : Algorithme du simplexe
Entrées : Un P .L. standard P(max) avec une solution de base réalisable
Output : La solution optimale (ou non)
1On commence à écrire le tableau initiale (avec les variables de base xj1,..., xjm)
VB x1 ... xn b
xj1 b1
... A...
xjm bm
c1 ... cn−c0
2Sicj≤0 (∀j:xjest hors base), alors solution optimale (STOP) // min ⇝cj≥0
3Trouver la colonne s(hors base) tel que cs=max©
cj:cj>0ª// min ⇝cs=min©
cj:cj<0ª
4Siai,s≤0∀i=1... m, alors pas de solution optimale (STOP)
5Min Ratio Test : trouver la ligne rtel que
br
ar,s=min
i=1...m½bi
ai,s:ai,s>0¾
6Appliquer la procédure de Gauss autour de pivot ar,s(ar,s⇝1 et on annule les coefficients situés sous et
sur le pivot dans la colonne s, par combinaisons de lignes) // Ne pas oublier la dernière ligne
7Remplacer (dans VB) la variable de base ( sortante ) située à la ligne rpar la variable ( entrante )xs
8Retourner à l’étape 2 // l'algorithme termine si le programme linéaire est non dégénéré
Remarque 10.
— La dernière ligne représente l’équation linéaire −z+c1x1+···+ cnxn= −c0.
— La valeur de la variable de base de V Bde la ligne k est égale à la valeur b k(de la ligne k).
— La solution optimale du problème est la valeur finale (dernière cellule) (×− 1).
— Si on n’a pas au départ B =Im(à l’aide des variables d’écart) alors, on ajoute les variables artificielles (et on
applique d’abord la phase I - voir section suivante).30 Chapitre 4. Programmation linéaire
Exercice 4.2
Soit le programme linéaire :
max 2 x1+x2
s.t. x1−x2≤3,
x1+2x2≤6,
−x1+2x2≤2,
x1,x2≥0
Rajouter les variables d’écart. Puis résoudre le problème par l’algorithme du simplexe.
Remarque 11. Vérifier le résultat de l’exercice précédent, par la méthode graphique.
4.1.3 Initialisation - Phase I du simplexe
Un programme linéaire est dit sous forme simpliciale si la matrice Acontient la matrice identité Imcomme
sous matrice. On suppose que le programme linéaire P, après la mise en forme AX=b, n’est pas simpliciale
(possible dans le cas de contraintes du type ≥ou du type =). Soit Bune matrice d’ordre mextraite de Ainversible
tel que B−1b≥0et soit XBla solution de base réalisable ( XB≥0etAX B=b), alors on peut changer l’équation
matricielle :
AX B=b
⇐⇒ (B−1A)XB=B−1b
⇐⇒ A∗XB=b∗
et la matrice A∗contient la matrice identité Imcomme matrice extraite ( B−1A=B−1(H|B)=¡
B−1H|Im¢
). Ainsi, on
peut appliquer directement l’algorithme 10 en remplaçant Apar A∗etbpar b∗. Cependant, cette méthode n’est
pas efficace, car il faut trouver une matrice extraite Bréalisable correspondante. Pour une matrice Ade type m×n,
il existe¡m
n¢
matrices extraites à tester !
L ’idée est d’ajouter des variables, dites artificielles w1,w2,..., wm, pour faire apparaître une forme simpliciale
du programme linéaire P: (AX=b). Mais, il faut que w1= ··· = wm=0. Donc, il faut minimiser d’abord le pro-
gramme linéaire P0suivant :
P0=min W=w1+···+ wm
s.t. (A|Im)×(x1...xnw1...wm)T=b
x1,..., xn,w1,..., wm ≥0
On exprime Wà l’aide des autres variables (hors base) et puis on applique l’algorithme du simplexe 10 pour P0
(phase I). À la fin, si on trouve que les wi=0, alors les variables de bases xj1,..., xjmforment une première base
admissible pour démarrer le simplexe pour le programme d’origine P.H. SABRI 31
Remarque 12. On ajoute la ligne de Z :c1 ... cn−c0dans le tableau du simplexe de P0(phase I) et on lui
applique les opérations élémentaire comme avec les autres lignes. À la fin de la phase I, on supprime les colonnes des
wiet la ligne de la fonction W . Finalement, on utilise ce tableau pour résoudre le problème initiale P.
Example 4.3
Soit le programme linéaire P:
min 6 x1+3x2
s.t. x1+x2≥1,
2x1−x2≥1,
3x2≤2,
x1,x2≥0sous forme standard (max)= = = = = = = = = = = = = = = = = = ⇒max Z= −6x1−3x2
s.t. x1+x2−e1=1,
2x1−x2−e2=1,
3x2+e3=2,
x1,x2,e1,e2,e3≥0
La matrice Aest :
A=x1 x2 e1 e2 e3

1 1 −1 0 0
2−1 0 −1 0
0 3 0 0 1
est par suite Pn’est pas sous forme simpliciale (il n’ ya pas de sous matrice I3). Donc on peut ajouter 2
variables artificielles pour construire le problème initiale P0:
max −w1−w2=3x1−e1−e2−2
s.t. x1+x2−e1+w1=1,
2x1−x2−e2+w2=1,
3x2+e3=2,
x1,x2,e1,e2,e3,w1,w2≥0dont le vecteur X=

0 x1
0 x2
0 e1
0 e2
2 e3
1 w1
1 w2est une solution de base réalisable.
Ainsi, on commence notre algorithme 10 pour le programme P0. Le tableau initial est :
x1 x2 e1 e2 e3 w1 w2 b

w1 1 1 −1 0 0 1 0 1
w2 2−1 0 −1 0 0 1 1
e3 0 3 0 0 1 0 0 2
W: 3 0 −1−1 0 0 0 2
Z:−6−3 0 0 0 0 0 0
Le pivot c’est a2,1donc x1est la variable entrante et w2est sortante. On obtient après pivotement le tableau :
L2←1
2L2− − − − − − − − →
L1←L1−L2
L4←L4−3L2
L5←L5+6L2x1 x2 e1 e2 e3 w1 w2 b

w1 03
2−11
20 1−1
21
2
x1 1−1
20−1
20 01
21
2
e3 0 3 0 0 1 0 0 2
W: 03
2−11
20 0−3
21
2
Z: 0 −6 0 −3 0 0 3 3
Le pivot est a1,2(Min ratio test =1
3). On obtient alors :32 Chapitre 4. Programmation linéaire
L1←2
3L1− − − − − − − − →
L2←L2+1
2L1
L3←L3−3L1
L4←L4−3
2L1
L5←L5+6L1x1 x2 e1 e2 e3 w1 w2 b


x2 0 1−2
31
302
3−1
31
3
x1 1 0−1
3−1
301
31
32
3
e3 0 0 2 −1 1 −2 1 1
W: 0 0 0 0 0 −1−1 0
Z: 0 0 −4−1 0 4 1 5
Ainsi, la phase I se termine avec W=0 et x1=2
3,x2=1
3,e3=1 et e1=e2=w1=w2=0. Le tableau pour la
phase II est donc :
x1 x2 e1 e2 e3 b


x2 0 1−2
31
301
3
x1 1 0−1
3−1
302
3
e3 0 0 2 −1 1 1
Z: 0 0 −4−1 0 5
On remarque donc que les cj≤0, donc (STOP) la solution est optimale et le max est −5. Ainsi la solution
optimale pour le programme P=min6 x1+3x2est−(−5)=5=6×2
3+3×1
3.
4.2 Dualité
SoitPun P .L. sous forme canonique. Le programme dualDdePest définit par :
P=max z=cTX
s.t. AX ≤ b
X≥ 0le dual est= = = = = = = ⇒D=min w=bTY
s.t. ATY≥ c
Y≥ 0
Le programme Pest dit primal . On remarque que si Ade type m×n, alors X∈RnetY∈Rmpour le dual.
Théorème 4.1 Théorème de dualité
Si un problème primal ou dual admet une solution, alors l’autre problème admet aussi une solution et on a :
max z=cTX =
s.t. AX ≤ b
X≥ 0min w=bTY
s.t. ATY≥ c
Y≥ 0
Exercice 4.3
Soit le problème suivant de type régime :
D=min w=340x1+2400 x2+560x3
s.t. x1+2x2+x3≥ 1200
x1+3x2+2x3≥ 1400
x1+x2+3x3≥ 1500
x1,x2,x3≥ 0
Écrire le programme primal PdeD. Résoudre le programme Pet déduire la valeur minimale de w, a-t-on
besoin de faire les deux phases du simplexe ?
7} A B oS



HOUSSEM SABRI
Graphes et Optimisation
2`emeannée
LISI  LSI
Institut Supérieur des Sciences Appliquées et de Technologie de Sousse
A.U. 2023-2024
28 novembre 2023Table des matières
1 Les graphes 3
1.1 Définitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.1 Graphes non orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.2 Graphes orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.2 Opérations et quelques types de graphes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.3 Représentation d’un graphe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.1 Listes d’adjacences (ou de succession) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.2 Matrices d’adjacence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.3.3 Matrice d’incidence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2 La connexité 11
2.1 Les chaînes et les cycles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.2 Graphe connexe, eulérien, hamiltonien . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.3 Arbres . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.3.1 Codage et décodage d’un arbre – Prüfer code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.3.2 Arbre couvrant de poids minimum – ACM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3 Les algorithmes de base 20
3.1 Parcours en profondeur (DFS) / largeur (BFS) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
3.2 Recherche des chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.1 Matrice d’adjacence et nombre de chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.2 Plus court chemin et l’algorithme de Dijkstra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
3.3 Problèmes d’ordonnancement et chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
3.3.1 Algorithmes de tri topologique et de chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . 25
4 Programmation linéaire 27
4.1 La méthode simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.1 Solution de base admissible . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux . . . . . . . . . . . . . . . . . . . . . . . . 29
4.1.3 Initialisation - Phase I du simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
4.2 Dualité . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
2CHAPITRE 1
Les graphes
L ’exemple classique pour introduire la théorie des graphes est le problème des ponts de Königsberg, étudié par
Euler en 1736. Quel itinéraire doit-on suivre pour traverser chaque pont exactement une fois? Une telle prome-
nade n’existe pas, et c’est Euler qui donna la solution de ce problème en caractérisant les graphes que l’on appelle
aujourd’hui eulériens .
A
B
Ce1 e2
e3 e4
De5
e6e7
FIGURE 1.1 – Les ponts de Königsberg
Les graphes introduisent une simplification : les régions se transforment en des "points" (aussi appelés noeuds
ousommet ), les ponts se transforment en des lignes (aussi appelées arêtes ouarcs ), et ce principe s’applique dès
lors qu’une relation existe entre des objets. Les graphes relèvent de la combinatoire plutôt que de la géométrie (les
intersections, les longueurs, et la forme des arêtes n’ont aucune importance, sauf en ce qui concerne la lisibilité de
la représentation).
1.1 Définitions
Dans la suite, il est toujours supposé que les graphes sont finis, sauf indication contraire.
1.1.1 Graphes non orientés
Définition 1.1: Graphe
Un graphe Gest un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V{2}des pairs non ordon-
nées de V.Vest l’ensemble des noeuds (Vertices en anglais) et Ec’est l’ensemble des arêtes de G(Edges en
anglais). Lorsque e={x,y} est une arête, on dit que x, y sont les extrémités de cette arête, que eest incidente
enxet en y. On joint x et y par un trait et on dit que x, y sont adjacents (ou voisins). On note aussi e=x you
encore e=(x,y) (attention , dans ce cas : ( x,y)=(y,x)).
SiGest un graphe alors, on note par V(G) l’ensemble de noeuds et par E(G) l’ensemble des arcs.
Remarque 1.
— Une arête e ={x,x}s’appelle boucle .
— Dans un graphe, il peut exister des arêtes parallèles (on parle donc de multigraphe ).
Dans l’exemple des ponts on a : e 1=e2=(A,B).
34 Chapitre 1. Les graphes
— Un graphe est dit simple s’il ne comporte ni arêtes multiples ni de boucles, c’est-à-dire chaque paire de nœuds
distincts est reliée par au plus une arête, ou encore E (G)⊆P2(G).
Dans la plupart des cas, les graphes sont considérés comme simples par défaut.
Définition 1.2: ordre – taille – degré
Soit G=(V,E) un graphe.
1. On appelle ordre d’un graphe noté v(G) le nombre de ses sommets :
v(G)= |V|
2. On appelle taille d’un graphe noté e(G) le nombre de ses arêtes :
e(G)= |E|
3. Le degré (ou valence) d’un sommet xnoté d(x) est le nombre d’arêtes contenant x. (Attention! Une
boucle sur un sommet compte double).
Si on note par Γ(x) l’ensemble des voisins de x, i.e.
Γ(x)={y∈V:x y∈E}
alors, siGest simple , on a :
d(x)= |Γ(x)|
Example 1.1 (Graphe complet)
Un graphe d’ordre nest dit complet noté Knsi chaque sommet du graphe est relié directement à tous les
autres sommets, i.e. E(Kn)=P2(V(Kn)).
Représenter graphiquement K3,K4,k5. Calculer la taille de K3,k4,...Kn.
Example 1.2 (Graphe biparti)
Un graphe G=(V,E) est dit biparti si son ensemble de sommets V=V1˙∪V2, i.e. peut être divisé en deux
sous-ensembles disjoints V1etV2tels que chaque arête ait une extrémité dans V1et l’autre dans V2.
Si∀x∈V1,∀y∈V2;x y∈E, alors Gest dit biparti complet noté Kn,moùn= |V1|etm= |V2|.
a1
 a2
 a3
 a4
b1
 b2
 b3
FIGURE 1.2 – Un graphe biparti
Théorème 1.1 Lemme des poignées de main – Handshaking lemma
Soit Gun graphe alors, on a :X
x∈V(G)d(x)=2e(G)
Dans ce théorème d(x) est le nombre de personnes à qui xserre la main et e(G) le nombre total de poignées
de mains.H. SABRI 5
Preuve.
•Méthode simple Il y en a d(x) arêtes en un sommet xfixé. Pour tout les sommets cela fait doncP
x∈V(G)d(x).
Mais avec cette manière chaque arête est comptée deux fois, une fois à chacune de ses extrémités, d’où le
résultat en divisant par 2.
•Preuve par double dénombrement On pose
Z={(x,e)∈V×E:x∈e}⊆V×E
et les deux projections :
p:Z→V
(x,e)7→xet q:Z→E
(x,e)7→e
L ’idée est de calculer |Z|de deux manières différentes. D’abord, on rappelle que si f:A→Best une fonction
quelconque, alors :X
b∈B|f−1[b]| = | A|
oùf−1[b] désigne l’image réciproque de { b} par f(pourquoi ˙S
b∈Bf−1[b] est une union disjointe ?).
Ainsi on obtient :
|Z| =X
x∈V|p−1[x]| =X
e∈E|q−1[e]|
Or,|p−1[x]| =d(x) et|q−1[e]| = |{x∈V:x∈e}| =2. Donc :
X
x∈Vd(x)=X
e∈E2=2|E|
Remarque 2.
— Un sommet de degré 0est appelé sommet isolé .
— Un graphe tel que : ∀x∈V,d(x)=kest dit graphe k-régulier .
— Le graphe complet K nest un graphe (n−1)-régulier .
Exercice 1.1
Montrer que dans un graphe le nombre de sommets d’ordre impairs est toujours pair. En particulier un
graphe k-régulier avec kimpaire est un graphe d’ordre pair.
Voici quelques exemples comme application :
1. Est-il possible de relier 15 ordinateurs en réseau de sorte que chacun soit relié à exactement 3 autres ?
2. Une ligue de football comprenant 11 clubs organise un tournoi. Pour gagner du temps on décide que chaque
équipe ne jouera que la moitié des matches possibles. Comment organiser le tournoi ?
Proposition 1.1
Soit G=(V,E) un graphe (simple) d’ordre n≥2. Alors :
∃u,v∈V,u̸=v:d(u)=d(v)
Preuve. Supposons le contraire, c’est-à-dire ∀u,v∈V;d(u)̸=d(v). Or dans un graphe (simple) on a toujours d(x)∈
{0,1,..., n−1}. Dans ce cas, puisque tous les nsommets ont des degrés distincts, alors il existe une bijection
{d(x):x∈V}←→ {0,1,..., n−1}
Donc, il existe un sommet uavec un degré 0, et un sommet vavec degré n−1, donc vest connecté à tous les autres
sommets du graphe, ce qui signifie que une peut pas être un sommet isolé, d’où une contradiction.6 Chapitre 1. Les graphes
1.1.2 Graphes orientés
Les arêtes d’un graphe peuvent être orientées, auquel cas une flèche indique la direction. De tels graphes sont
appelés des graphes orientés ou des digraphes , et une arête ( a,b) dans un tel graphe indique que cette arête est
dirigée de sommet avers b, i.e. ( a,b)=− →ab̸=(b,a)=− →ba. D’où la définition :
Définition 1.3: Graphe orienté - digraphe
Un graphe orienté G(ou− →G) est un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V2des pairs
ordonnées de V.Eest l’ensemble des arêtes (ou flèches, arcs) de G. Lorsque e=(x,y) est une arête, on dit
que xestl’origine (ou sommet initiale) et yl’extrémité (ou sommet terminale) de e, que eest sortant en x
et incident en y, et que yest un successeur de xtandis que xest un prédécesseur de y. On note l’arête e
par :
e=(x,y)=− →x y=x→y
De la même façon, une arête x→xest une boucle. On peut toujours supprimer les boucles pour obtenir des
digraphes simples. Voici l’exemple d’un digraphe G=(V,E) d’une fonction f:E→Eoù ( x,y) est un arc si et seule-
ment si y=f(x). On l’appelle digraphe fonctionnelle.
0
3
1214
11 568
169
4
2 1
713 10
15
FIGURE 1.3 – Le digraphe fonctionnelle Gfdex7→(x2+3) mod 17.
Comme dans les graphes on peut définir les degrés (entrant, sortant) d’un sommet dans un digraphe.
Définition 1.4: indegree - outdegree
Soit G=(V,E) un digraphe. Pour v∈V, on note par :
d+(v) le degré extérieur (sortant - outdegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité initiale.
d+(v)= |{v→ •}|
d−(v) le degré intérieur (entrant - indegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité finale.
d−(v)= |{• → v}|
On définit le degré : d(v)=d−(v)+d+(v).
Un sommet de degré entrant non nul et de degré sortant nul est appelé puits , tandis qu’un sommet de
degré entrant nul et de degré sortant non nul est appelé source ouracine .
Dans un graphe orienté, les voisins d’un sommet vsont soit des successeurs ou des prédécesseurs. On les notes
par :
Γ+(x)=Succ (x)={y∈V:x→y∈E} et Γ−(x)=Pr ed (x)={y∈V:y→x∈E}H. SABRI 7
Si le digraphe est simple (ni boucle ni arcs parallèles) on a :
d−(v)= |Γ−(v)|et d+(v)= |Γ+(v)|
Proposition 1.2
Soit Gun digraphe, alors :X
v∈Vd−(v)=X
v∈Vd+(v)= |E|
Preuve. On a
E=˙[
v∈V{• → v}=˙[
v∈V{v→ •}
=⇒ | E| =X
v∈V|{• → v}| =X
v∈V|{v→ •}| =⇒ | E| =X
v∈Vd−(v)=X
v∈Vd+(v)
1.2 Opérations et quelques types de graphes
Une opération sur les graphes permet de construire un nouveau graphe comme résultat de l’opération. Les
opérations courantes sur les graphes sont la suppression, la valuation, l’union, l’intersection et le produit cartésien.
Graphe valué
Tout d’abord, on peut vouloir attribuer des valeurs aux arcs ou arêtes pour tenir compte de contraintes : dis-
tance, coût ...
Définition 1.5: (di)graphe valué
Un (di)graphe valué G=(V,E,w) est un (di)graphe muni d’une application w:E→R. L ’application west
appelée application poids ou coût. On indique sur chaque arête son poids (ou son coût). On note w(x,y)
au lieu de w((x,y)). On convient (même que ceci n’a pas de sens!) que w(x,y)= +∞ si (x,y)∉E.
ab
c
d
ef53
43
3
335
81
FIGURE 1.4 – Un digraphe valué
/pythonPython code : -
Implémenter le digraphe valué précédent avec python. Indice – use chatGPT : how to build a weighted digraph with
python8 Chapitre 1. Les graphes
Sous graphes
Soit G=(V,E) un graphe (orienté ou non). Un sous graphe de Gest un graphe de la forme G′=(V′,E′) où
V′⊆V,E′⊆Etels que toute arête de E′a ses extrémités dans V′(ou encore G′est aussi un graphe). On a :
•Sous-graphe induit Un sous-graphe G′=(V′,E′) de G=(V,E) est appelé un sous-graphe induit deGsi :
∀x,y∈V′; (x,y)∈E′⇐⇒ (x,y)∈E
En d’autres termes, deux sommets de G′qui sont connectés dans G, sont également connectés dans G′.
•Sous-graphe couvrant Un sous-graphe couvrant G′deGcontient tous les sommets de G, i.e. V′=V.
•G−vSupprimer un sommet vd’un graphe Gconsiste à supprimer vet toutes ses arêtes incidentes. Le sous-
graphe obtenu de cette opération est noté G−v, i.e.
V′=V−{v} et E′=E−{(v,y): (v,y)∈E}
De manière similaire, une arête epeut être supprimée (resp. ajoutée) d’un graphe G, et le sous-graphe
résultant est représenté par G−e(resp. G+e). Notez que la suppression d’une arête ne retire pas de sommets
du graphe.
•G−V′=G[V′] On supprimer tous les sommets v∈V′du graphe Gavec les arêtes incidentes. Le sous-graphe
obtenu de cette opération est noté G[V′], i.e.
V(G[V′])=V−V′et E(G[V′])=E−{(v,y)∈E:v∈V′}
•Clique Une clique Cd’un graphe Gest un sous-ensemble des sommets de Gdont le sous-graphe induit G′=
(C,E′) est un graphe complet, en d’autres termes, deux sommets quelconques de la clique Csont toujours
adjacents.
•Stable Un stable – appelé aussi ensemble indépendant (independent set en anglais) est un ensemble de som-
mets deux à deux non adjacents. Donc le sous-graphe induit est sans arcs.
FIGURE 1.5 – L ’ensemble des sommets en bleu dans ce graphe est un stable maximal du graphe.
Note : -
Le problème décisionnel de la clique (c’est à dire existe t-il une clique de taille k) est NP-complet . De même la
recherche d’un stable de taille maximum dans un graphe est un problème NP-complet et difficile à approximer.
Exercice 1.2
Trouver un plus grand stable et une plus grande clique du graphe suivant :
8
4
62 7
3
1 5
Indice : vérifier le résultat avec networkx.find_cliques(G) et.maximum_independent_set(G) de python.H. SABRI 9
Opérations binaires
Union L ’union de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∪H=(VF,EF) dans lequel
VF=VG∪VH et EF=EG∪EH
Intersection L ’intersection de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∩H=(VF,EF)
dans lequel
VF=VG∩VH et EF=EG∩EH
1.3 Représentation d’un graphe
Il est important de savoir comment représenter les graphes au sein d’un ordinateur. Il ya plusieurs méthodes
selon la nature des traitements que l’on souhaite appliquer au graphe considéré.
1.3.1 Listes d’adjacences (ou de succession)
Soit Gun (di)graphe. On suppose que les sommets de Gsont numérotés de S1àSn. La représentation par listes
d’adjacence de Gconsiste en un tableau (ou des listes chainées) tel que la ligne i=1... ncorrespond au sommet Si
et comporte la liste des voisins/successeurs (ou des prédécesseurs) de ce sommet notée T[Si]. Les sommets dans
chaque liste d’adjacence sont généralement listés selon un ordre arbitraire.
1
2
345
FIGURE 1.6 – Un digraphe
La liste d’adjacence de digraphe 1.6 est donc :
1 2 3 4 5
2 3
3 4
4−
5 1 410 Chapitre 1. Les graphes
1.3.2 Matrices d’adjacence
Définition 1.6: Mat. Adjacence
Soit G=(V,E) un graphe (orienté) d’ordre n. On peut numéroter V={1,2,..., n}.La matrice d’adjacence
deGest la matrice carrée A=(ai j) d’ordre n, définie par :
ai j=(
1 si ( i j)∈E;
0 sinon.
Remarque 3.
1. Si le graphe G est non orienté et simple, alors la matrice A est symétrique avec des 0sur la diagonale. Pour un
digraphe simple, on a toujours des 0sur la diagonale, mais la matrice n’est pas symétrique en général.
2. Pour les multigraphes, il peut y avoir des termes diagonaux (pour les boucles) et s’il y a plusieurs arêtes de i à
j , le coefficient de la matrice a i jest le nombre d’arêtes de i à j .
3. Pour un (di)graphe valué G =(V,E,w), on pose :
ai j=(
w(i,j)si(i j)∈E ;
∞ sinon.
La matrice d’adjacence de la figure 1.4 est :

∞ 5∞ 4 3 ∞
∞ ∞ 3∞ 1∞
∞ ∞ ∞ ∞ ∞ 5
∞ ∞ 3∞ 3 3
∞ ∞ ∞ ∞ ∞ 8
∞ ∞ ∞ ∞ ∞ ∞

1.3.3 Matrice d’incidence
Définition 1.7: Mat. Incidence
Soit G=(V,E) un graphe (simple) d’ordre net de taille m. On pose V={v1,v2,..., vn} etE={e1,e2,..., em}.
La matrice d’incidence deGest la matrice de type n×m B=(bi j), définie par :
•Si G orienté
bi j=

1 si ej=vi→ • (i.e. viest l’extrémité initiale de ej) ;
−1 si ej= • → vi(i.e. viest l’extrémité terminale de ej) ;
0 sinon.
•Si G non-orienté
bi j=(
1 si viest une extrémité de ej;
0 sinon.
Exercice 1.3
1. Donner la matrice d’incidence du graphe 1.6.
2. Montrer le théorème 1.1 avec la matrice d’incidence.CHAPITRE 2
La connexité
Il est important de savoir si on peut suivre un chemin d’un sommet donné à un autre dans un graphe donné.
Cette propriété (de connexité) doit être maintenue dans différents types de réseaux.
2.1 Les chaînes et les cycles
Définition 2.1: (chaine – cycle) (chemin – circuit)
•Graphe non orienté
1. Une chaîne (walk ) reliant xày, notée µ(x,y), est définie par une suite finie d’arêtes consécutives,
reliant xày, ou encore une séquence de sommets (puisque non multigraphe)
µ(x,y)=<v0,v1,..., vk>
tels que v0=x,vk=yet (vi−1,vi)∈E(G) pour tout i=1... k. Six=yla chaîne est dite fermée .
Lalongueur du chaîne l(µ(x,y)) est le nombre d’arcs dans la chaîne, c’est-à-dire k.
2. Une chaîne élémentaire (a path ) si tous les sommets sont distincts. Une chaîne simple (a simple
walk, a trail ) est une chaîne ne passant pas deux fois par une même arête, c’est-à-dire dont toutes
les arêtes sont distinctes. Remarquer que : élémentaire =⇒ simple.
3. Un cycle v0v1...vnde longueur n≥3 est une chaîne simple fermée ( v0=vn) tel que les sommets
v0,v1,..., vn−1sont tous distincts. Un graphe sans cycle est dit acyclique .
•Graphe orienté
Dans un graphe orienté, on parlera de chemin au lieu de chaîne, et de circuit au lieu de cycle.
Example 2.1
abxcd xa est une chaîne simple et fermée (non cycle!) de longueur 6 (mais, c’est un graphe eulérien - voir
plus loin). Y a-t-il un cycle de longueur 3,4 ?
a b
x
c dÏ
Remarque 4.
1. On peut pivoter une chaine fermée (l’orienter de manière arbitraire) , i.e.
<v0,v1,v2,..., v0>=< vk,vk+1,..., v0,v1,..., vk>
1112 Chapitre 2. La connexité
2. Soient x ,y∈V . La distance de x à y est définie par :
d(x,y)=(
k si le plus court chemin/chaîne de x vers y est de longueur k
∞ sinon
On convient que d (x,x)=0.
3. Le diamètre du graphe la plus grande distance entre deux sommets.
L ’observation suivante, bien que très facile à prouver, sera utile.
Théorème 2.1
S’il existe une chaîne du sommet yau sommet zdans le graphe G, où y̸=z, alors il existe une chaîne élé-
mentaire ( path ) dans Gavec pour premier sommet yet pour dernier sommet z.
Preuve. Soit la chaine
W1=µ(y,z)=x0x1...xn; avec x0=yetxn=z.
Si les sommets x0,x1,..., xnsont tous distincts, alors W1est une chaîne élémentaire, et nous avons terminé. Sinon,
il existe xi=xj(i<j) et on écrit :
W2=x0x1...xixj+1...xn.
Alors, l(W2)<l(W1). Si W2ne contient aucun sommet répété, alors c’est la chaîne recherché. Sinon, par la même
procédure, il existe W3(y z−chaîne) tel que
l(W3)<l(W2)<l(W1).
Ce processus doit s’arrêter à un certain stade, car chaque chaîne est plus courte que la précédente et la longueur
ne peut jamais être inférieure à 1
1< ··· < l(Wk)< ··· < l(W3)<l(W2)<l(W1).
Ainsi, pour un certain k,Wkne peut pas être réduit en longueur. Donc, la chaîne Wkne contient aucun sommet
répété et est donc une y z−chaîne élémentaire (path).
Exercice 2.1
Dans le graphe suivant, construire un path à partir de la chaîne W=v2v3v4v5v6v4v2v8v1
v1
 v2
v3
v4
v5
v6
v7
 v8
 v9
Calculer d(v1,v7) et le diamètre de G.
/pythonpython : >>G = nx.Graph([(1, 2), (2, 3), (2, 4), ...]) >>nx.diameter(G)
Les cycles fournissent la caractérisation suivante pour les graphes bipartis .H. SABRI 13
Théorème 2.2
Un graphe est biparti si et seulement s’il ne contient aucun cycle de longueur impaire.
Preuve.
⇒On suppose que G=U˙∪Vest un graphe biparti. Soit W=< x1,x2,..., x2k+1,x1>un cycle de longueur im-
paire (2 k+1). Si x1∈U, alors
x1∈U=⇒ x2∈V=⇒ x3∈U=⇒ ··· =⇒ x2k+1∈U=⇒ x1∈V/exclamati⌢n-triangle
absurde, d’où le résultat.
⇐On suppose que Gest connexe (car l’union des composantes connexes bipartis est un graphe biparti). Soit
xun sommet de Get on pose :
U={y∈V(G):d(x,y) est paire} et V={z∈V(G):d(x,z) est impaire}
S’il existe y1,y2∈Utel que y1y2∈E(G), alors on a :
W1=<x,..., y1>est une chaîne de longueur paire =2k1
W2=<x,..., y2>est une chaîne de longueur paire =2k2
=⇒ W3=<x,..., y1,y2,..., x>est un cycle de longueur impaire =2k1+2k2+1/exclamati⌢n-triangle
Donc G=U˙∪Vest un graphe biparti.
Exercice 2.2
Vérifier si le graphe maison est un graphe biparti. Faire de même pour la grille G4,4.
maison grille
2.2 Graphe connexe, eulérien, hamiltonien
Définition 2.2: Graphe connexe
Un graphe est dit connexe si deux points peuvent toujours être joints par une chaîne, i.e.
∀x,y∈V(G),d(x,y)< ∞
— Une composante connexe d’un graphe est un sous-graphe induit maximal connexe.
— Un point d’articulation d’un graphe est un sommet dont la suppression augmente le nombre de
composantes connexes.
Par exemple, le graphe suivant :14 Chapitre 2. La connexité
a
 b
d
 c
e
f
 g
n’est pas connexe car il n’existe pas de chaîne entre les sommets aete. On a donc 2 composantes connexes. En
revanche, le sous-graphe induit par les sommets { a,b,c,d} est connexe dont aest le seul point d’articulation.
Remarque 5.
1. Un graphe connexe à n sommets possède au moins n −1arêtes ( faite une preuve par récurrence ).
2. L’algorithme de parcours en profondeur permet de déterminer si un graphe est connexe ou non.
3. Même définitions dans un graphe orienté . Graphe orienté (fortement) connexe et de composante connexe .
Définition 2.3: Graphe eulérien
— Une chaîne joignant deux sommets xetyest dite chaîne eulérienne si elle emprunte chaque arête
deGune et une seule fois. On parle de chemin eulérien dans le cas d’un graphe orienté.
— Un cycle eulérien est une chaîne eulérienne dont les extrémités coïncident. Un graphe qui admet
un cycle (resp. circuit) eulérien est dit graphe eulérien .
/flushedRemarquer qu’un cycle eulérien n’est pas forcément un cycle comme définit dans la définition 2.1
Si un graphe (ou multigraphe) Gpossède une chaîne eulérienne, alors soit Gpossède deux sommets impairs, le
début et la fin de cette chaîne, soit Gn’a aucun sommet impair, et la promenade d’Euler commence et se termine
au même point (cycle eulérien). Une autre condition nécessaire évidente est que Gdoit être connexe. Ces deux
conditions sont ensemble suffisantes.
Théorème 2.3 Euler
Soit Gun graphe (multigraphe) connexe.
— Si Gn’a pas de sommets impairs, alors il possède un cycle eulérien (commençant à n’importe quel
point).
i.e.∀x,d(x)≡0 mod 2 =⇒ Gest un graphe eulérien.
— Si Ga deux sommets impairs, alors il possède une chaîne eulérienne dont le début et la fin sont les
sommets impairs.
La réciproque est aussi vraie.
Preuve.
⇐On commence par la réciproque. S’il existe une chaîne eulérienne µ(x,y), alors on peut crée une arête fictive
e=(y,x) et par la suite on obtient un cycle eulérien. Donc il suffit de montrer que si Gadmet un cycle
eulérien alors tous les sommets sont de degré pair.
Soit W=< v1,v2,..., vn,v1>un cycle eulérien. Soit le sommet vjavec j̸=1, il est donc claire que chaque
fois vjapparaît dans W, il ya deux arcs distincts incidents en vj( (•,vj) et ( vj,•)). Comme toutes les arêtes
sont utilisées, on voit que d(vj) est pair. Même chose pour v1car on ajoute deux arcs ( v1,v2) et ( v1,vn).
⇒On suppose que tous les sommets sont de degré pair. Montrons que Gadmet un cycle eulérien. Puisque
tous les sommets sont de degré pair on peut construire d’abord une chaîne simple fermée (quelconque)
W1=<v1,v2,..., vk,v1>
SiW1contient chaque arête de G, alors c’est finis, c’est un cycle eulérien. Sinon (puisque Gest connexe), il
existe une arête e=(vi,c) qui n’est pas dans W1(avec visommet de W1). On pose le sous-graphe
G′=G−{ arêtes de W1}H. SABRI 15
Il est donc claire que les sommets de G′sont aussi de degré pair. Alors, par la même procédure on construit
une chaîne simple fermée dans G′de la forme : <vi,c,d,..., vi>et par la suite on insère cette chaîne dans
W1pour obtenir :
W2=<v1,v2,..., vi,c,d,..., vi,vi+1,..., vk,v1>
Sil(W2)< |E(G)|, on construit W3de longueur plus grand. Ainsi, on a :
l(W1)<l(W2)<l(W3)< ··· ≤ | E(G)|
Donc, nécessairement, il existe Wk(chaîne simple fermée de longueur |E(G)|) donc c’est un cycle eulérien.
Finalement , si∃a,b∈V(G):d(a)≡d(b)≡1 mod 2, et tous les autres sommets sont de degré pair, alors on
pose :
G′=G+{a,b}
et donc tous les sommets de G′sont de degré pair. Avec la construction précédente, il existe un cycle eulérien
dans G′:
W=<a,b,v1,..., a>
est donc la chaîne <b,v2,..., a>est une chaîne eulérienne dans G.
Algorithme 1 : Euler
Entrées : Gun graphe eulérien
Output : Un cycle eulérien W
/* On suppose que G est eulérien, i.e. les sommets sont de degré pair */
1Gaux←G;W←µ(v,v) une chaîne simple (quelconque) de G; // Initialisation
2tant que l(W)<e(G)faire
3 Gaux←G−{ arêtes de W} ;
4 Choisir ( x,c)∈E(Gaux) tel que x∈W;
5 L←< x,c,..., x>une chaîne simple de Gaux ;
6 Dans W, remplacer (juste ce) xpar la séquence L;
7fin
8retourner W;
Exercice 2.3
1. Montrer que le graphe de l’exercice 2.1 est un graphe eulérien et donner un cycle eulérien.
2. Tracer cette maison d’un seul trait.
Remarque 6. Le théorème d’Euler dans un graphe orienté connexe s’écrit :
Admet un circuit eulérien si, et seulement si, pour tout sommet, le degré entrant est égal au degré sortant.
∀v∈V(G),d+(v)=d−(v)
Admet un chemin eulérien de a vers b si, et seulement si,


d+(v)=d−(v) ;∀v̸=a,b,
d−(a)=d+(a)−1
d−(b)=d+(b)+116 Chapitre 2. La connexité
Définition 2.4: Graphe hamiltonien
Soit Gun graphe connexe d’ordre n. On appelle :
1. On appelle cycle hamiltonien deGun cycle passant (une et une seule fois) par chacun des sommets
deG. Un graphe est dit hamiltonien s’il possède un cycle hamiltonien.
2. Une chaîne hamiltonienne est une chaîne passant une et une seule fois par chacun des sommets de
G. Un graphe ne possédant que des chaînes hamiltoniennes est semi-hamiltonien .
3. Dans un digraphe, on change cycle par circuit et chaîne par chemin .
Remarque 7.
— Une chaîne hamiltonienne est une chaîne élémentaire de longueur n −1.
— Un graphe peut être eulérien, hamiltonien, les deux à la fois, ou aucun des deux.
— De nombreux problèmes concrets peuvent être formulés en termes de recherche de parcours hamiltoniens : pro-
blème du voyageur de commerce (chercher un cycle hamiltonien de longueur totale minimale), l’ ordonancement
de tâches .
— Le problème du chaîne hamiltonienne est un problème NP-complet .
Exercice 2.4
Donner un graphe (connexe, simple) qui soit :
1. hamiltonien et eulérien.
2. hamiltonien et non eulérien.
3. eulérien et non hamiltonien.
4. non hamiltonien et non eulérien.
Aucune condition nécessaire et suffisante adéquate n’est connue pour l’existence de cycles hamiltoniens. Le
résultat suivant constitue une condition suffisante utile.
Théorème 2.4 Ore
Soit Gun graphe simple d’ordre n≥3. Si pour toute paire { x,y} de sommets non adjacents, on a d(x)+d(y)≥
n, alors Gest hamiltonien.
Preuve. On suppose que le théorème est faux. Alors, il existe un graphe Gsimple d’ordre nnon hamiltonien tel que
d(u)+d(v)≥npour tout sommets non adjacents uetv. On prend Gun tel graphe d’ordre nde taille maximale qui
vérifie cette propriété (remarquer que le graphe complet Knest hamiltonien).
Soient uetvdeux sommets non adjacents de G. Par maximalité de G, le graphe G+uv(d’ordre n) doit être
hamiltonien. Donc il existe dans G+uvun cycle hamiltonien :
W=<u,x1,x2,..., xn−2,v,u>
u
x1
xi xi+1xn−2
v
... ...
Or, si uxi+1∈E(G) etv xi∈E(G) (les arcs en rouge), alors on peut construire dans Gle cycle hamiltonien :
<u,x1,x2,..., xi,v,xn−2,..., xi+1,u>H. SABRI 17
Ceci est absurde car Gest non hamiltonien. Donc si xi+1est un sommet voisin à u, alors le sommet xin’est pas
voisin de v:
xi+1∈Γ(u)=⇒ xi∉Γ(v)
Donc :
d(u)= |Γ(u)| =p=⇒ d(v)≤(n−1)−p
et par la suite
d(u)+d(v)≤n−1
ce qui absurde par hypothèse. Donc Gest hamiltonien.
Une conséquence immédiate est le théorème de Dirac :
Proposition 2.1 Dirac
Soit Gun graphe simple d’ordre n≥3. Si pour tout sommet xdeG, on a d(x)≥n
2, alors Gest hamiltonien.
2.3 Arbres
Définition 2.5: Arbres et forêts
On appelle arbre tout graphe (non orienté) connexe et acyclique . Les composantes connexes dans un
graphe acyclique sont des arbres et le graphe est dit forêt . Une feuille ou sommet pendant est un som-
met de degré 1.
Un forêt avec deux arbres
Un graphe Gest une arborescence s’il existe un sommet Rappelé racine deGtel que, pour tout sommet
SdeG, il existe un chemin et un seul de Rvers S. Donc, c’est un arbre orienté dans lequel on choisit un
sommet Rcomme racine et on dirige les arcs vers le sens sortant de la racine.
Remarque 8.
— Un graphe G d’ordre n est un arbre ssi G est sans cycle et possède n −1arêtes.
— Un graphe G d’ordre n est un arbre ssi G est connexe et possède n −1arêtes.
— G est un arbre si pour chaque paire u ,v de sommets distincts est reliée par une seule chaîne (donc chaîne
élémentaire d’après le théorème 2.1).
— Un arbre (ou forêt) est nécessairement un graphe simple.
Pour démontrer les remarques précédentes, il suffit de prouver le théorème suivant :
Théorème 2.5
Soit Gun graphe ayant marêtes, nsommets et pcomposantes connexes, on définit nu( G) :
ν(G)=m−n+p
Alors, on a :
1.ν(G)≥0.
2.ν(G)=0⇐⇒ Gest acyclique.18 Chapitre 2. La connexité
Preuve. Par récurrence sur la taille mdu graphe. Le résultat est évident pour m=0 et m=1. On suppose le résultat
est vrai pour les graphe de taille m, et montrons que ceci est vrai pour un graphe de taille m+1. Soit donc Gun
graphe d’ordre nde taille m+1 ayant pcomposantes connexes.
•On suppose que Gest un graphe acyclique. Soit uvune arête de Gdans la composante C. Si on supprime uv,
la composante Cse transforme en deux composantes connexes (sinon on a un cycle dans G). Par la suite,
le graphe G′=G−uvest un graphe acyclique d’ordre n, de taille met ayant p+1 composantes connexes.
Donc d’après l’hypothèse de récurrence :
ν(G′)=0=(m−1)−n+(p+1)=m−n+p=ν(G)
•Maintenant, si Gcontient un cycle Wdans la composante connexe C. Soit uvune arête de W, alors si on
supprime l’arête uv, la composante Creste connexe. Donc le graphe G′=G−uvest un graphe d’ordre nde
taille m−1 ayant pcomposantes connexes. Donc, d’après l’hypothèse de récurrence :
ν(G′)=(m−1)−n−p≥0
=⇒ν(G)=m−n−p≥1>0
D’où le résultat – car si ν(G)=0,Gne peut être que acyclique, sinon 0 =ν(G)≥1/exclamati⌢n-triangle
2.3.1 Codage et décodage d’un arbre – Prüfer code
Soit Tun arbre ayant nsommet numérotés {1,2,..., n}. Le codage de Prüfer représente l’arbre Tarbre de avec
une suite P=(x1,x2,x3,..., xn−2) de n−2 termes (les n° des sommets avec répétition possible). Une suite Pdonnée
correspond à un et un seul arbre numéroté. Voici les algorithmes de codage et de décodage.
Algorithme 2 : Codage de Prüfer
Entrées : Un arbre T
Output : Séquence de Prüfer P
1P←() ; // Initialisation de P comme séquence vide
2tant que v(T)>2faire
3 x←feuille de Tayant le n° minimum ; // donc d(x)=1
4 P←(P,s) où sest le seul (n°) sommet adjacent à x;
5 T←T−x;
6fin
7retourner P;
Example 2.2
Donner le code de Prüfer de l’arbre :
126 345
Indice : on trouve, P=(2,3,3,2)
Pour faire la réciproque, étant donnée une séquence P=(x1,x2,..., xn−2) où les xi∈{1,2,..., n}, on construit
l’arbre Tdont les sommets sont {1,2,..., n} avec l’algorithme suivant (le décodage) :H. SABRI 19
Algorithme 3 : Décodage de Prüfer
Entrées : Une séquence Pde taille n−2
Output : L ’arbre Tcorrespondante
1I←{1,2,..., n};
2T←graphe tel que V(T)=IetE(T)= ; ; // T graphe à n sommets isolés
3tant que P̸=()faire
4 i←min {x∈I:x∉P};
5 T←T+(i,P[1]) ; // ajouter l'arc (i,P[1])
6 P←P−P[1];I←I−{i};
7fin
8T←T+(a,b) ; // a,b sont les deux éléments restant dans I
9retourner T;
Example 2.3
Donner l’arbre dont le code de Prüfer est : P=(2,3,3,3)
Puisqu’il ya une bijection entre les arbres d’ordre net les suites Pde longueur n−2 à coefficients dans {1,2,..., n},
on déduit le théorème de Cayley :
Théorème 2.6 Formule de Cayley
Le nombre d’arbres que l’on peut construire sur n(n≥2) sommets numérotés est égal à nn−2.
2.3.2 Arbre couvrant de poids minimum – ACM
Soit Gun graphe (non orienté). Un arbre couvrant (spanning tree) TdeGest un sous graphe couvrant de G
tel que Test un arbre. Remarquer que, Gdoit être connexe, sinon un arbre couvrant de Gn’existe pas. Le nombre
des arbres couvrant de Gest noté a(G). Remarquer que a(Kn)=nn−2(le nombre de Cayley). Un problème algo-
rithmique classique est de trouver, dans un graphe valué , un arbre couvrant de poids minimal . On dispose de
plusieurs algorithmes (l’algorithme de Prim, l’algorithme de Kruskal ...).
Algorithme 4 : Kruskal
Entrées : Un graphe Gvalué d’ordre net de taille m
Output : Arbre (ou forêt) couvrant de poids minimum
1Numéroter les arêtes de Gpar poids minimum : w(e1)≤w(e2)≤ ··· ≤ w(em)
2T←graphe tel que V(T)=V(G) etE(T)= ; ; // T graphe à n sommets isolés
3k←0;
4tant que k<m et e (T)<n−1faire
5 siT+ek+1est acyclique alors
6 T←T+ek+1;
7 k←k+1;
8fin
9retourner T;
Appliquer l’algorithme de Kruskal dans le graphe suivant :
CHAPITRE 3
Les algorithmes de base
Beaucoup de problèmes sur les graphes nécessitent que l’on parcourt l’ensemble des sommets et des arcs. Par
exemple, pour vérifier que le graphe est connexe, chercher un sommet particulier, construire un arbre couvrant,
trouver un plus court chemin ...etc.
3.1 Parcours en profondeur (DFS) / largeur (BFS)
Une manière simple de tester si un graphe Gest connexe ou non est d’exécuter l’algorithme DFS ouBFS dans
Gen commençant par n’importe quel sommet et en enregistrant les sommets visités pendant l’exécution dans une
liste. Si la liste contient tous les sommets de G, alors Gest connexe. Une petite modification permet de donner les
composantes connexes de G. L ’algorithme DFS_Component suivant donne les composantes connexes de G. Il est
donné sous forme d’implémentation récursive.
Algorithme 5 : DFS_Component
Entrées : Un graphe G=(V,E)
Output : Les composantes connexes C=(C1,C2,..., Ck) de G.
1VisitedNodes ← ; ;
2k←0 ; // k est le nombre des composantes connexes
3pour chaque u∈Vfaire
4 siu∉VisitedNodes alors
5 k←k+1;
6 DFS( u);
7 fin
8fin
9retourner (C1,C2,..., Ck);
1Procedure DFS( u )
2 VisitedNodes ←VisitedNodes ∪{u};
3 Ck←Ck∪{u};
4 pour chaque x∈Γ(u)faire
5 six∉VisitedNodes alors
6 DFS( x);
7 fin
8 fin
Note : -
Il est possible de d’implémenter la procédure DFS itérativement à l’aide d’une pile LIFO (stack) contenant les
sommets à explorer : on désempile un sommet et on empile ses voisins non encore explorés.
20H. SABRI 21
Pseudocode :
stack . push ( root )
while stack . isEmpty ( ) = f a l s e do
node = stack . pop ( ) // so mark i t as v i s i t e d
for each x in node . childNodes do
i f x i s not v i s i t e d then
stack . push ( x )
. . .
endfor
endwhile
Example 3.1 (DFS )
Ici on empile (gris) les sommets les plus à droite, alors l’ordre des sommets visité (noir) est ( a,b,d,e,g,c,f).
Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b
 c
d
 e
f
g
a
b
 c
d e
f
ga
b
 c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g
L ’utilisation d’une file (FIFO) au lieu d’une pile transforme l’algorithme du parcours en profondeur en algo-
rithme de parcours en largeur ( BFS ). Avec BFS l’exemple précédent devient (en enfile le plus à gauche) :
Example 3.2 (BFS )
Ici, avec BFS, on enfile (gris) les sommets les plus à gauche d’abord, alors l’ordre des sommets visité (noir)
est ( a,b,d,e,g,c,f). Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b c
d
 e
f
g
a
b c
d
 e
f
ga
b c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g22 Chapitre 3. Les algorithmes de base
Exercice 3.1
1. Écrire la procédure BFS .
2. Utiliser DFS (ou BFS) pour la construction d’un arbre couvrant d’un graphe connexe. L ’appliquer
pour le graphe triangle.
3. Utiliser DFS pour écrire une procédure DFS_Cycle pour détecter un cycle dans un graphe.
On sait qu’un graphe orienté G=(V,E) est fortement connexe si pour chaque paire de sommets u,v∈V, il
existe un chemin de uàvet il existe un chemin de vàu. En d’autres termes, nous avons besoin d’une connectivité
dans les deux directions .
Une procédure pour tester si un graphe orienté est fortement connexe ou non peut être conçue avec l’idée
suivante. En partant d’un sommet arbitraire vdu graphe G, on exécute l’algorithme BFS ouDFS et l’on note les
sommets visités. Ensuite, on obtient la transposée de G,GT, en inversant la direction des arêtes de G, et l’on
exécute à nouveau l’algorithme BFS ou DFS à partir du sommet v. Si les sommets visités dans les deux cas sont
égaux à V, alors le graphe orienté est fortement connexe. Cette méthode est illustrée dans l’algorithme 6.
Algorithme 6 : Fortement_connexe
Entrées : Un graphe orienté G=(V,E)
Output : true siGest fortement connexe et false sinon
1X← ; ;
2Y← ; ;
3v←un sommet quelconque de V;
4X←DFS( G,v) ; // Enregistrez les sommets visités dans X
5GT←Gavec flèches inversées;
6Y←DFS( GT,v);
7siX=Y=Valors
8 retourner TRUE.
9sinon
10 retourner FALSE.
11fin
3.2 Recherche des chemins
3.2.1 Matrice d’adjacence et nombre de chemins
La puissance de la matrice d’adjacence Amontre qu’il y a des chemins (ou chaînes) de longueur kallant de xà
ycomme le montre le théorème suivant.
Théorème 3.1
Soit G=(V,E) un (di)graphe. On note V={1,2,..., n} et Asa matrice d’adjacence et Akla puissance k-ème
deA. Alors le terme d’indices i,jdeAkest le nombre de chemins (chaînes) de longueur kallant de iàj.
Preuve. Par récurrence sur k. Pour k=1 c’est clair. On suppose le résultat est vrai à l’ordre ket montrons qu’elle
est vrai pour k+1. Soit S=(si,j)=Ak. Si on a un chemin de iàjde longueur k+1, alors on va d’abord de ià un
sommet ravec kpas et puis de ràj. Or d’après l’hypothèse de récurrence on a si,rchemins possibles pour aller de
iàret finalement ar,jpas (1 ou 0) pour aller de ràj. Ainsi, le nombre totale possibles (i.e. tous les sommets r) est :
nX
r=1si,rar,j=³
Ak×A´
i,jH. SABRI 23
ce qui est bien le terme ( i,j) de la matrice Ak+1.
3.2.2 Plus court chemin et l’algorithme de Dijkstra
Dans cette partie on suppose que le (di)graphe G=(V,E,w) est valué positivement (i.e.∀e∈E,w(e)>0). Notre
objectif est de chercher un plus court chemin (i.e., un chemin de poids minimal ) d’un sommet ufixé à un sommet
quelconque de G.
Il est clair que l’on peut restreindre ce problème au cas d’un (di)graphe simple1. On suppose aussi que Gest
connexe (sinon, certains trajets sont impossibles). Il est aussi claire (d’après théorème 2.1), qu’un plus court chemin
est nécessairement un chemin élémentaire (path).
L ’algorithme de Dijkstra (1959) permet de calculer le plus court chemin entre un sommet particulier u(racine )
et tous les autres sommets. L ’algorithme fonctionne de la manière suivante :
Pour tout sommet vdeG, on associe une valeur T(v), initialisée à w(u,v) et une liste de sommets C(v) qui
correspond à un chemin de uàv. À la fin de l’algorithme, T(v) contient le poids minimal des chemins joignant uà
v(ou T(v)= ∞ siu↛v) et la liste C(v) réalise un tel chemin. Voici donc l’algorithme de Dijkstra :
Algorithme 7 : Algorithme de Dijkstra
Entrées : Un (di)graphe valué G=(V,E,w) et un sommet racine u
Output : Le coût minimum d’un chemin de uàv(∀v∈V) et un trajet pour chaque coût minimal obtenu
1∀v∈V,T(v)←w(u,v) etC(v)←(u,v); // Initialisation de T(v) et la liste C(v)
2X←{u};
3tant que X̸=Vfaire
4 Choisir v∈V−Xtel que ∀y∈V−X,T(v)≤T(y);
5 X←X∪{v};
6 pour chaque y∈V−Xfaire // Faire les mises à jours pour les autres sommets
7 siT(y)>T(v)+w(v,y)alors
8 T(y)←T(v)+w(v,y);
9 C(y)←[C(v),y]; // On ajoute à la liste C(v) l'élément y
10
11 fin
12 fin
13fin
Example 3.3
Voici une application de l’algorithme de Dijkstra au digraphe suivant. On prend Ecomme sommet racine.
EA
B
CD
FG
S5
4
21
12
2
34
4
215
7
1. En effet, passer par une boucle ne ferait qu’augmenter inutilement le poids de ce chemin. De même, si plusieurs arcs joignent deux
sommets, il suffit de conserver l’arc de poids minimal.24 Chapitre 3. Les algorithmes de base
Ainsi, pour l’initialisation, on a : X={E} et on a les valeurs :
v  E A B C D F G S
T(v) 0 5 4 2 ∞ ∞ ∞ ∞
C(v)(E,E) ( E,A) ( E,B) ( E,C) ( E,D) ( E,F) ( E,G) ( E,S)
Maintenant, on choisit (un seul choix) le sommet C, donc X={E,C}. Le tableau est mis à jour :
v  E A B  C D F G S
T(v) 0 5 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À l’étape suivante, on est forcé de choisir B. Ainsi, X={E,C,B} et la mise à jour est :
v  E A  B  C D F G S
T(v) 0 4 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À présent, on a le choix entre AetF. On choisit A. Donc X={E,C,B,A} et on a :
v  E  A  B  C D F G S
T(v) 0 4 3 2 6 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,B,A,D) ( E,C,F) ( E,C,G) ( E,S)
Puis, on prend le sommet F. D’où X={E,C,B,A,F} et :
v  E  A  B  C D  F G S
T(v) 0 4 3 2 5 4 5 11
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,S)
On prend Det on obtient X={E,C,B,A,F,D} et :
v  E  A  B  C  D  F G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Finalement, on prend Gpuis Set on voit que ceci ne change rien. D’où le tableau finale :
v  E  A  B  C  D  F  G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Ainsi le chemin minimum pour aller de EàSest de coût 10 et un trajet de coût minimal de EàSest : EC F DS .H. SABRI 25
3.3 Problèmes d’ordonnancement et chemin critique
Un problème d’ordonnancement peut-être représenté sous la forme d’un digraphe. Les sommets sont des évé-
nements (début et fin de la tâche) et les arcs des tâches, La longueur (ou poids) de chaque arc représente la durée
d’exécution de la tâche. Ainsi, la tâche correspondant à l’arc ( i,j) ne peut commencer que si toutes les tâches cor-
respondant à des arcs ( k,i) ont été complétées. On ajoute deux sommets pour le début (s) et de fin(t) du projet .
Le digraphe peut contenir des tâches fictives dedurée nulle afin de forcer certaines précédences (postériorité).
Ainsi, un réseau PERT est un digraphe valué G=(V,E,w,s,t) où la fonction poids (ou longueur) w:E→R+
etsle sommet source (début) et tle sommet puits (fin). Un chemin critique est un chemin de sàtdelongueur
maximale . S’il n’existe pas de chemin critique, le projet n’est pas réalisable (e.g. un circuit). Le temps minimal
requis pour l’exécution d’un projet réalisable est égal à la longueur d’un chemin critique. Les tâches figurant sur un
chemin critique sont aussi appelées critiques, ce qui s’explique par le fait que tout retard d’exécution d’une tâche
critique retarde d’autant l’exécution du projet.
3.3.1 Algorithmes de tri topologique et de chemin critique
Il faut d’abord numérotés les sommets de 1 à nde manière compatible au pré-ordre (rang) avec l’algorithme du
rang suivant (tri topologique) :
Algorithme 8 : Algorithme du rang
Entrées : Un digraphe G=(V,E) sans circuit
Output : Le rang r(v) de chaque sommet v∈Vde G
1r←0;X←V;
2R←{v∈X:Γ−
X(v)= ;} ; // l'ensemble des sommets de X sans prédécesseur dans X
3tant que X̸= ; faire
4 r(v)←rpour chaque sommet v∈R;
5 X←X−R;
6 R←l’ensemble des sommets de Xsans prédécesseur dans X;
7 r←r+1;
8fin
On supposera dorénavant que les sommets ont déjà été numérotés de 1 à nde manière compatible avec leurs
rangs, c’est-à-dire que r(j)>r(i) implique j>i(donc 1 =setn=t). Enfin, on supposera éliminés les arcs paral-
lèles par l’introduction de tâches fictives de durée nulle .
Pour un sommet i, on note tiledébut au plus tôt des tâches correspondant aux arcs i→jet par Tilafin au
plus tard des tâches correspondant aux arcs j→i.
Algorithme 9 : Algorithme du chemin critique
Entrées : Un digraphe G=(V,E) sans circuit trié topologiquement
Output : La durée du chemin critique et les dates ti,Ti
1t1←0;
2pour j=2···nfaire // Calcul des dates de début au plus tôt  récurrence en avançant
3 tj←max i∈Γ−(j){ti+w(i,j)}
4fin
5Tn←tn;
6pour j=n−1···1faire // Calcul des dates de fin au plus tard  récurrence en reculant
7 Tj←min i∈Γ+(j){Ti−w(j,i)}
8fin26 Chapitre 3. Les algorithmes de base
Définition 3.1
— Un sommet iest critique si ti=Ti.
— Un arc ( i,j) est critique les sommets ietjsont critiques ettj−ti=w(i,j).
— Un chemin critique est un chemin de 1 à nn’utilisant que des arcs critiques.
— La durée du chemin critique est donnée par Tn(ou par tn). Elle correspond à la durée minimale du
projet .
Example 3.4
L ’application de l’algorithme du chemin critique au digraphe suivant (trié topologiquement) est :
1 23
45
6B
9A
3
C
5D
8
E
4
F7G
20
H6I5
=⇒
 1
0,02
9,933,16
4
16,23513,24
6
29,29B
9A
3
C
5D
8
E
4
F7G
20
H6I5
Les tâches critiques sont BetG. La durée totale minimale du projet est donc 29.
Exercice 3.2
Les tâches ( durée et précédences ) pour la construction d’un entrepôt sont données dans le tableau suivant :
Tâches Nature Précédences Durée (jours)
A Acceptation des plans par le propriétaire – 4
B Préparation du terrain – 2
C Commande des matériaux A 1
D Creusage des fondations A, B 1
E Commande des portes et fenêtres A 2
F Livraison des matériaux C 2
G Coulage des fondations D, F 2
H Livraison des portes et fenêtres E 10
I Pose des murs, de la charpente et du toit G 4
J Mise en place des portes et fenêtres H, I 1
1. Représentez le graphe des précédences de ce projet (trié topologiquement).
2. Déterminez une durée totale minimale en exhibant un chemin critique dans ce graphe.CHAPITRE 4
Programmation linéaire
La programmation linéaire est le processus de minimiser ou maximiser une fonction objective linéaire sou-
mise à un nombre fini de contraintes d’égalités et d’inégalités linéaires.
La programmation linéaire a de nombreuses applications dans le domaine de l’informatique théorique. Elle
peut être utilisée pour résoudre de nombreux problèmes combinatoires variés, tels que la recherche de flot maxi-
mum dans un réseau, la recherche d’un couplage maximal dans un graphe et la coloration d’un graphe parfait.
Example 4.1 (Problème de régime)
On suppose qu’on a quatre plats : de la truite ( XT), un sandwich au corned-beef ( XC B), un burrito ( XBU R )
et un hamburger ( XHB). Le tableau suivant répertorie la valeur nutritionnelle de chaque plat (vitamines et
calories) et notre besoin journalier des vitamines.
Vit. A Vit. C Vit. D Calories
Truite 203 92 100 600
Corned-beef 90 84 230 350
Burrito 270 80 512 250
Humburger 500 90 210 500
Besoins 2000 300 430
Notre objectif est de minimiser le nombre total de calories consommées : 600 XT+350XC B+250XBU R+
500XHBtout en satisfaisant les trois besoins nutritionnels en vitamines. Le programme linéaire résultant
s’écrit :
min 600 XT+350XC B+250XBU R+500XHB
s.t. 203 XT+90XC B+270XBU R+500XHB≥2000, (Besoins de Vit. A),
92XT+84XC B+80XBU R+90XHB≥300, (Besoins de Vit. C),
100XT+230XC B+512XBU R+210XHB≥430, (Besoins de Vit. D),
XT,XC B,XBU R ,XHB≥0
Définition 4.1: Forme canonique – Forme standard
On peut écrire un P .L. sous deux formes spéciales :
•Canonique
max
mincTX+c0
s.t. AX≤b(≥bsi min),
X≥0•Standard
max cTX+c0
s.t. AX=b,
X≥0Avec :
cTX=¡
c1··· cn¢
x1
...
xn

cTX+c0=c1x1+c2x2+···+ cnxn+c0
2728 Chapitre 4. Programmation linéaire
Remarque 9. Un P .L. général peut être formulé selon une forme standard ou canonique par la méthode suivante :
générale =⇒ standard il faut éliminer les contraintes d’inégalité et les variables sans contrainte de positivité.
— Si dT
iX≤biest une contrainte d’inégalité, alors créer une nouvelle variable ( d’écart ) siet remplacer l’in-
égalité dT
iX≤bipar dT
iX+si=biet s i≥0.
Si dT
iX≥bi, alors on peut écrire dT
iX−si=biet s i≥0.
— Si une variable x i≶0est de signe quelconque, alors créez deux nouvelles variables x+
iet x−
iet remplacez
xipartout par x+
i−x−
i, et ajoutez les contraintes de signe : x+
i≥0,x−
i≥0.
générale =⇒ canonique
— Si dT
iX=biest une contrainte d’égalité, alors remplacer cette égalité par une paire d’inégalités :
dT
iX≥biet−dT
iX≥ −bi
— Même chose que précédemment si la variable x i≶0.
Il est facile de voir que les problèmes qui en résultent sont équivalents aux problème d’origine. Pour l’algorithme
simplexe , nous utiliserons la forme standard .
On remarque aussi qu’en utilisant la relation min f(x)= − max¡
−f(x)¢
dans laquelle f (x)représente la fonction-
nelle linéaire à optimiser, on peut toujours se ramener à un problème de minimisation (ou de maximisation).
Example 4.2
Le P .L :max 5 x+4y
s.t. x≤6
1
4x+y≤6
3x+2y≤22
x,y≥0s’écrit sous forme standard :max 5 x1+4x2
s.t. x1+e1=6
1
4x1+x2+e2=6
3x1+2x2+e3=22
x1,x2,e1,e2,e3≥0
Donc (sous la forme matricielle) on a :
cT=¡
5 4 0 0 0¢
;A=
1 0 1 0 0
1
41 0 1 0
3 2 0 0 1
;X=
x1
x2
e1
e2
e3
et b=
6
6
22

4.1 La méthode simplexe
4.1.1 Solution de base admissible
On suppose que la matrice Adu programme linéaire est de type m×netde rang m(pourquoi !). Soit Bla
matrice carrée extraite de Aformée par les mcolonnes j1,j2,..., jmlinéairement indépendants de A(les vecteurs
de base). Alors, Best une matrice inversible. Ainsi si on pose xl=0 sil∉{j1,..., jm} etxjklak-ième composante de
B−1b. Alors, on a AX B=b. Si de plus XB≥0(i.e. chaque xi≥0), alors :
Xest une solution de base admissible (ou réalisable)
Dans l’exemple 4.2, la matrice extraite B=
1 0 0
0 1 0
0 0 1
est inversible et B−1b=
6
6
22
. Donc XB=
0
0
6
6
22
≥0, par suite
XBest une solution de base admissible. On appelle les variables xjklesvariables de base . Les autres variables xl
sont les variables hors-base .
Parfois, il n’est pas évident de trouver une solution de base admissible, comme le montre l’exercice suivant :H. SABRI 29
Exercice 4.1
Écrire le programme linéaire suivant sous forme standard et montrer qu’on n’a pas une solution de base
admissible. Résoudre le programme linéaire.
max −x+y
s.t. x+y≥1,
3x+2y=6,
x,y≥0
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux
Dans cette section, on suppose qu’on a déjà trouvé une solution de base admissible X(produite avec B=Im)
du programme linéaire ( P: max z=cTX+c0etb≥0pour garantir que 0est une solution de AX≤b).
La méthode du simplexe est une méthode itérative qui génère une séquence de solutions de base réalisable
(correspondant à différentes bases) et s’arrête finalement lorsqu’elle a trouvé une solution de base réalisable opti-
male. Remarquer qu’on peut toujours prendre c0=0.
Algorithme 10 : Algorithme du simplexe
Entrées : Un P .L. standard P(max) avec une solution de base réalisable
Output : La solution optimale (ou non)
1On commence à écrire le tableau initiale (avec les variables de base xj1,..., xjm)
VB x1 ... xn b
xj1 b1
... A...
xjm bm
c1 ... cn−c0
2Sicj≤0 (∀j:xjest hors base), alors solution optimale (STOP) // min ⇝cj≥0
3Trouver la colonne s(hors base) tel que cs=max©
cj:cj>0ª// min ⇝cs=min©
cj:cj<0ª
4Siai,s≤0∀i=1... m, alors pas de solution optimale (STOP)
5Min Ratio Test : trouver la ligne rtel que
br
ar,s=min
i=1...m½bi
ai,s:ai,s>0¾
6Appliquer la procédure de Gauss autour de pivot ar,s(ar,s⇝1 et on annule les coefficients situés sous et
sur le pivot dans la colonne s, par combinaisons de lignes) // Ne pas oublier la dernière ligne
7Remplacer (dans VB) la variable de base ( sortante ) située à la ligne rpar la variable ( entrante )xs
8Retourner à l’étape 2 // l'algorithme termine si le programme linéaire est non dégénéré
Remarque 10.
— La dernière ligne représente l’équation linéaire −z+c1x1+···+ cnxn= −c0.
— La valeur de la variable de base de V Bde la ligne k est égale à la valeur b k(de la ligne k).
— La solution optimale du problème est la valeur finale (dernière cellule) (×− 1).
— Si on n’a pas au départ B =Im(à l’aide des variables d’écart) alors, on ajoute les variables artificielles (et on
applique d’abord la phase I - voir section suivante).30 Chapitre 4. Programmation linéaire
Exercice 4.2
Soit le programme linéaire :
max 2 x1+x2
s.t. x1−x2≤3,
x1+2x2≤6,
−x1+2x2≤2,
x1,x2≥0
Rajouter les variables d’écart. Puis résoudre le problème par l’algorithme du simplexe.
Remarque 11. Vérifier le résultat de l’exercice précédent, par la méthode graphique.
4.1.3 Initialisation - Phase I du simplexe
Un programme linéaire est dit sous forme simpliciale si la matrice Acontient la matrice identité Imcomme
sous matrice. On suppose que le programme linéaire P, après la mise en forme AX=b, n’est pas simpliciale
(possible dans le cas de contraintes du type ≥ou du type =). Soit Bune matrice d’ordre mextraite de Ainversible
tel que B−1b≥0et soit XBla solution de base réalisable ( XB≥0etAX B=b), alors on peut changer l’équation
matricielle :
AX B=b
⇐⇒ (B−1A)XB=B−1b
⇐⇒ A∗XB=b∗
et la matrice A∗contient la matrice identité Imcomme matrice extraite ( B−1A=B−1(H|B)=¡
B−1H|Im¢
). Ainsi, on
peut appliquer directement l’algorithme 10 en remplaçant Apar A∗etbpar b∗. Cependant, cette méthode n’est
pas efficace, car il faut trouver une matrice extraite Bréalisable correspondante. Pour une matrice Ade type m×n,
il existe¡m
n¢
matrices extraites à tester !
L ’idée est d’ajouter des variables, dites artificielles w1,w2,..., wm, pour faire apparaître une forme simpliciale
du programme linéaire P: (AX=b). Mais, il faut que w1= ··· = wm=0. Donc, il faut minimiser d’abord le pro-
gramme linéaire P0suivant :
P0=min W=w1+···+ wm
s.t. (A|Im)×(x1...xnw1...wm)T=b
x1,..., xn,w1,..., wm ≥0
On exprime Wà l’aide des autres variables (hors base) et puis on applique l’algorithme du simplexe 10 pour P0
(phase I). À la fin, si on trouve que les wi=0, alors les variables de bases xj1,..., xjmforment une première base
admissible pour démarrer le simplexe pour le programme d’origine P.H. SABRI 31
Remarque 12. On ajoute la ligne de Z :c1 ... cn−c0dans le tableau du simplexe de P0(phase I) et on lui
applique les opérations élémentaire comme avec les autres lignes. À la fin de la phase I, on supprime les colonnes des
wiet la ligne de la fonction W . Finalement, on utilise ce tableau pour résoudre le problème initiale P.
Example 4.3
Soit le programme linéaire P:
min 6 x1+3x2
s.t. x1+x2≥1,
2x1−x2≥1,
3x2≤2,
x1,x2≥0sous forme standard (max)= = = = = = = = = = = = = = = = = = ⇒max Z= −6x1−3x2
s.t. x1+x2−e1=1,
2x1−x2−e2=1,
3x2+e3=2,
x1,x2,e1,e2,e3≥0
La matrice Aest :
A=x1 x2 e1 e2 e3

1 1 −1 0 0
2−1 0 −1 0
0 3 0 0 1
est par suite Pn’est pas sous forme simpliciale (il n’ ya pas de sous matrice I3). Donc on peut ajouter 2
variables artificielles pour construire le problème initiale P0:
max −w1−w2=3x1−e1−e2−2
s.t. x1+x2−e1+w1=1,
2x1−x2−e2+w2=1,
3x2+e3=2,
x1,x2,e1,e2,e3,w1,w2≥0dont le vecteur X=

0 x1
0 x2
0 e1
0 e2
2 e3
1 w1
1 w2est une solution de base réalisable.
Ainsi, on commence notre algorithme 10 pour le programme P0. Le tableau initial est :
x1 x2 e1 e2 e3 w1 w2 b

w1 1 1 −1 0 0 1 0 1
w2 2−1 0 −1 0 0 1 1
e3 0 3 0 0 1 0 0 2
W: 3 0 −1−1 0 0 0 2
Z:−6−3 0 0 0 0 0 0
Le pivot c’est a2,1donc x1est la variable entrante et w2est sortante. On obtient après pivotement le tableau :
L2←1
2L2− − − − − − − − →
L1←L1−L2
L4←L4−3L2
L5←L5+6L2x1 x2 e1 e2 e3 w1 w2 b

w1 03
2−11
20 1−1
21
2
x1 1−1
20−1
20 01
21
2
e3 0 3 0 0 1 0 0 2
W: 03
2−11
20 0−3
21
2
Z: 0 −6 0 −3 0 0 3 3
Le pivot est a1,2(Min ratio test =1
3). On obtient alors :32 Chapitre 4. Programmation linéaire
L1←2
3L1− − − − − − − − →
L2←L2+1
2L1
L3←L3−3L1
L4←L4−3
2L1
L5←L5+6L1x1 x2 e1 e2 e3 w1 w2 b


x2 0 1−2
31
302
3−1
31
3
x1 1 0−1
3−1
301
31
32
3
e3 0 0 2 −1 1 −2 1 1
W: 0 0 0 0 0 −1−1 0
Z: 0 0 −4−1 0 4 1 5
Ainsi, la phase I se termine avec W=0 et x1=2
3,x2=1
3,e3=1 et e1=e2=w1=w2=0. Le tableau pour la
phase II est donc :
x1 x2 e1 e2 e3 b


x2 0 1−2
31
301
3
x1 1 0−1
3−1
302
3
e3 0 0 2 −1 1 1
Z: 0 0 −4−1 0 5
On remarque donc que les cj≤0, donc (STOP) la solution est optimale et le max est −5. Ainsi la solution
optimale pour le programme P=min6 x1+3x2est−(−5)=5=6×2
3+3×1
3.
4.2 Dualité
SoitPun P .L. sous forme canonique. Le programme dualDdePest définit par :
P=max z=cTX
s.t. AX ≤ b
X≥ 0le dual est= = = = = = = ⇒D=min w=bTY
s.t. ATY≥ c
Y≥ 0
Le programme Pest dit primal . On remarque que si Ade type m×n, alors X∈RnetY∈Rmpour le dual.
Théorème 4.1 Théorème de dualité
Si un problème primal ou dual admet une solution, alors l’autre problème admet aussi une solution et on a :
max z=cTX =
s.t. AX ≤ b
X≥ 0min w=bTY
s.t. ATY≥ c
Y≥ 0
Exercice 4.3
Soit le problème suivant de type régime :
D=min w=340x1+2400 x2+560x3
s.t. x1+2x2+x3≥ 1200
x1+3x2+2x3≥ 1400
x1+x2+3x3≥ 1500
x1,x2,x3≥ 0
Écrire le programme primal PdeD. Résoudre le programme Pet déduire la valeur minimale de w, a-t-on
besoin de faire les deux phases du simplexe ?
7} A B oS



HOUSSEM SABRI
Graphes et Optimisation
2`emeannée
LISI  LSI
Institut Supérieur des Sciences Appliquées et de Technologie de Sousse
A.U. 2023-2024
28 novembre 2023Table des matières
1 Les graphes 3
1.1 Définitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.1 Graphes non orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.2 Graphes orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.2 Opérations et quelques types de graphes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.3 Représentation d’un graphe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.1 Listes d’adjacences (ou de succession) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.2 Matrices d’adjacence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.3.3 Matrice d’incidence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2 La connexité 11
2.1 Les chaînes et les cycles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.2 Graphe connexe, eulérien, hamiltonien . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.3 Arbres . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.3.1 Codage et décodage d’un arbre – Prüfer code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.3.2 Arbre couvrant de poids minimum – ACM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3 Les algorithmes de base 20
3.1 Parcours en profondeur (DFS) / largeur (BFS) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
3.2 Recherche des chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.1 Matrice d’adjacence et nombre de chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.2 Plus court chemin et l’algorithme de Dijkstra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
3.3 Problèmes d’ordonnancement et chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
3.3.1 Algorithmes de tri topologique et de chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . 25
4 Programmation linéaire 27
4.1 La méthode simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.1 Solution de base admissible . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux . . . . . . . . . . . . . . . . . . . . . . . . 29
4.1.3 Initialisation - Phase I du simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
4.2 Dualité . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
2CHAPITRE 1
Les graphes
L ’exemple classique pour introduire la théorie des graphes est le problème des ponts de Königsberg, étudié par
Euler en 1736. Quel itinéraire doit-on suivre pour traverser chaque pont exactement une fois? Une telle prome-
nade n’existe pas, et c’est Euler qui donna la solution de ce problème en caractérisant les graphes que l’on appelle
aujourd’hui eulériens .
A
B
Ce1 e2
e3 e4
De5
e6e7
FIGURE 1.1 – Les ponts de Königsberg
Les graphes introduisent une simplification : les régions se transforment en des "points" (aussi appelés noeuds
ousommet ), les ponts se transforment en des lignes (aussi appelées arêtes ouarcs ), et ce principe s’applique dès
lors qu’une relation existe entre des objets. Les graphes relèvent de la combinatoire plutôt que de la géométrie (les
intersections, les longueurs, et la forme des arêtes n’ont aucune importance, sauf en ce qui concerne la lisibilité de
la représentation).
1.1 Définitions
Dans la suite, il est toujours supposé que les graphes sont finis, sauf indication contraire.
1.1.1 Graphes non orientés
Définition 1.1: Graphe
Un graphe Gest un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V{2}des pairs non ordon-
nées de V.Vest l’ensemble des noeuds (Vertices en anglais) et Ec’est l’ensemble des arêtes de G(Edges en
anglais). Lorsque e={x,y} est une arête, on dit que x, y sont les extrémités de cette arête, que eest incidente
enxet en y. On joint x et y par un trait et on dit que x, y sont adjacents (ou voisins). On note aussi e=x you
encore e=(x,y) (attention , dans ce cas : ( x,y)=(y,x)).
SiGest un graphe alors, on note par V(G) l’ensemble de noeuds et par E(G) l’ensemble des arcs.
Remarque 1.
— Une arête e ={x,x}s’appelle boucle .
— Dans un graphe, il peut exister des arêtes parallèles (on parle donc de multigraphe ).
Dans l’exemple des ponts on a : e 1=e2=(A,B).
34 Chapitre 1. Les graphes
— Un graphe est dit simple s’il ne comporte ni arêtes multiples ni de boucles, c’est-à-dire chaque paire de nœuds
distincts est reliée par au plus une arête, ou encore E (G)⊆P2(G).
Dans la plupart des cas, les graphes sont considérés comme simples par défaut.
Définition 1.2: ordre – taille – degré
Soit G=(V,E) un graphe.
1. On appelle ordre d’un graphe noté v(G) le nombre de ses sommets :
v(G)= |V|
2. On appelle taille d’un graphe noté e(G) le nombre de ses arêtes :
e(G)= |E|
3. Le degré (ou valence) d’un sommet xnoté d(x) est le nombre d’arêtes contenant x. (Attention! Une
boucle sur un sommet compte double).
Si on note par Γ(x) l’ensemble des voisins de x, i.e.
Γ(x)={y∈V:x y∈E}
alors, siGest simple , on a :
d(x)= |Γ(x)|
Example 1.1 (Graphe complet)
Un graphe d’ordre nest dit complet noté Knsi chaque sommet du graphe est relié directement à tous les
autres sommets, i.e. E(Kn)=P2(V(Kn)).
Représenter graphiquement K3,K4,k5. Calculer la taille de K3,k4,...Kn.
Example 1.2 (Graphe biparti)
Un graphe G=(V,E) est dit biparti si son ensemble de sommets V=V1˙∪V2, i.e. peut être divisé en deux
sous-ensembles disjoints V1etV2tels que chaque arête ait une extrémité dans V1et l’autre dans V2.
Si∀x∈V1,∀y∈V2;x y∈E, alors Gest dit biparti complet noté Kn,moùn= |V1|etm= |V2|.
a1
 a2
 a3
 a4
b1
 b2
 b3
FIGURE 1.2 – Un graphe biparti
Théorème 1.1 Lemme des poignées de main – Handshaking lemma
Soit Gun graphe alors, on a :X
x∈V(G)d(x)=2e(G)
Dans ce théorème d(x) est le nombre de personnes à qui xserre la main et e(G) le nombre total de poignées
de mains.H. SABRI 5
Preuve.
•Méthode simple Il y en a d(x) arêtes en un sommet xfixé. Pour tout les sommets cela fait doncP
x∈V(G)d(x).
Mais avec cette manière chaque arête est comptée deux fois, une fois à chacune de ses extrémités, d’où le
résultat en divisant par 2.
•Preuve par double dénombrement On pose
Z={(x,e)∈V×E:x∈e}⊆V×E
et les deux projections :
p:Z→V
(x,e)7→xet q:Z→E
(x,e)7→e
L ’idée est de calculer |Z|de deux manières différentes. D’abord, on rappelle que si f:A→Best une fonction
quelconque, alors :X
b∈B|f−1[b]| = | A|
oùf−1[b] désigne l’image réciproque de { b} par f(pourquoi ˙S
b∈Bf−1[b] est une union disjointe ?).
Ainsi on obtient :
|Z| =X
x∈V|p−1[x]| =X
e∈E|q−1[e]|
Or,|p−1[x]| =d(x) et|q−1[e]| = |{x∈V:x∈e}| =2. Donc :
X
x∈Vd(x)=X
e∈E2=2|E|
Remarque 2.
— Un sommet de degré 0est appelé sommet isolé .
— Un graphe tel que : ∀x∈V,d(x)=kest dit graphe k-régulier .
— Le graphe complet K nest un graphe (n−1)-régulier .
Exercice 1.1
Montrer que dans un graphe le nombre de sommets d’ordre impairs est toujours pair. En particulier un
graphe k-régulier avec kimpaire est un graphe d’ordre pair.
Voici quelques exemples comme application :
1. Est-il possible de relier 15 ordinateurs en réseau de sorte que chacun soit relié à exactement 3 autres ?
2. Une ligue de football comprenant 11 clubs organise un tournoi. Pour gagner du temps on décide que chaque
équipe ne jouera que la moitié des matches possibles. Comment organiser le tournoi ?
Proposition 1.1
Soit G=(V,E) un graphe (simple) d’ordre n≥2. Alors :
∃u,v∈V,u̸=v:d(u)=d(v)
Preuve. Supposons le contraire, c’est-à-dire ∀u,v∈V;d(u)̸=d(v). Or dans un graphe (simple) on a toujours d(x)∈
{0,1,..., n−1}. Dans ce cas, puisque tous les nsommets ont des degrés distincts, alors il existe une bijection
{d(x):x∈V}←→ {0,1,..., n−1}
Donc, il existe un sommet uavec un degré 0, et un sommet vavec degré n−1, donc vest connecté à tous les autres
sommets du graphe, ce qui signifie que une peut pas être un sommet isolé, d’où une contradiction.6 Chapitre 1. Les graphes
1.1.2 Graphes orientés
Les arêtes d’un graphe peuvent être orientées, auquel cas une flèche indique la direction. De tels graphes sont
appelés des graphes orientés ou des digraphes , et une arête ( a,b) dans un tel graphe indique que cette arête est
dirigée de sommet avers b, i.e. ( a,b)=− →ab̸=(b,a)=− →ba. D’où la définition :
Définition 1.3: Graphe orienté - digraphe
Un graphe orienté G(ou− →G) est un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V2des pairs
ordonnées de V.Eest l’ensemble des arêtes (ou flèches, arcs) de G. Lorsque e=(x,y) est une arête, on dit
que xestl’origine (ou sommet initiale) et yl’extrémité (ou sommet terminale) de e, que eest sortant en x
et incident en y, et que yest un successeur de xtandis que xest un prédécesseur de y. On note l’arête e
par :
e=(x,y)=− →x y=x→y
De la même façon, une arête x→xest une boucle. On peut toujours supprimer les boucles pour obtenir des
digraphes simples. Voici l’exemple d’un digraphe G=(V,E) d’une fonction f:E→Eoù ( x,y) est un arc si et seule-
ment si y=f(x). On l’appelle digraphe fonctionnelle.
0
3
1214
11 568
169
4
2 1
713 10
15
FIGURE 1.3 – Le digraphe fonctionnelle Gfdex7→(x2+3) mod 17.
Comme dans les graphes on peut définir les degrés (entrant, sortant) d’un sommet dans un digraphe.
Définition 1.4: indegree - outdegree
Soit G=(V,E) un digraphe. Pour v∈V, on note par :
d+(v) le degré extérieur (sortant - outdegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité initiale.
d+(v)= |{v→ •}|
d−(v) le degré intérieur (entrant - indegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité finale.
d−(v)= |{• → v}|
On définit le degré : d(v)=d−(v)+d+(v).
Un sommet de degré entrant non nul et de degré sortant nul est appelé puits , tandis qu’un sommet de
degré entrant nul et de degré sortant non nul est appelé source ouracine .
Dans un graphe orienté, les voisins d’un sommet vsont soit des successeurs ou des prédécesseurs. On les notes
par :
Γ+(x)=Succ (x)={y∈V:x→y∈E} et Γ−(x)=Pr ed (x)={y∈V:y→x∈E}H. SABRI 7
Si le digraphe est simple (ni boucle ni arcs parallèles) on a :
d−(v)= |Γ−(v)|et d+(v)= |Γ+(v)|
Proposition 1.2
Soit Gun digraphe, alors :X
v∈Vd−(v)=X
v∈Vd+(v)= |E|
Preuve. On a
E=˙[
v∈V{• → v}=˙[
v∈V{v→ •}
=⇒ | E| =X
v∈V|{• → v}| =X
v∈V|{v→ •}| =⇒ | E| =X
v∈Vd−(v)=X
v∈Vd+(v)
1.2 Opérations et quelques types de graphes
Une opération sur les graphes permet de construire un nouveau graphe comme résultat de l’opération. Les
opérations courantes sur les graphes sont la suppression, la valuation, l’union, l’intersection et le produit cartésien.
Graphe valué
Tout d’abord, on peut vouloir attribuer des valeurs aux arcs ou arêtes pour tenir compte de contraintes : dis-
tance, coût ...
Définition 1.5: (di)graphe valué
Un (di)graphe valué G=(V,E,w) est un (di)graphe muni d’une application w:E→R. L ’application west
appelée application poids ou coût. On indique sur chaque arête son poids (ou son coût). On note w(x,y)
au lieu de w((x,y)). On convient (même que ceci n’a pas de sens!) que w(x,y)= +∞ si (x,y)∉E.
ab
c
d
ef53
43
3
335
81
FIGURE 1.4 – Un digraphe valué
/pythonPython code : -
Implémenter le digraphe valué précédent avec python. Indice – use chatGPT : how to build a weighted digraph with
python8 Chapitre 1. Les graphes
Sous graphes
Soit G=(V,E) un graphe (orienté ou non). Un sous graphe de Gest un graphe de la forme G′=(V′,E′) où
V′⊆V,E′⊆Etels que toute arête de E′a ses extrémités dans V′(ou encore G′est aussi un graphe). On a :
•Sous-graphe induit Un sous-graphe G′=(V′,E′) de G=(V,E) est appelé un sous-graphe induit deGsi :
∀x,y∈V′; (x,y)∈E′⇐⇒ (x,y)∈E
En d’autres termes, deux sommets de G′qui sont connectés dans G, sont également connectés dans G′.
•Sous-graphe couvrant Un sous-graphe couvrant G′deGcontient tous les sommets de G, i.e. V′=V.
•G−vSupprimer un sommet vd’un graphe Gconsiste à supprimer vet toutes ses arêtes incidentes. Le sous-
graphe obtenu de cette opération est noté G−v, i.e.
V′=V−{v} et E′=E−{(v,y): (v,y)∈E}
De manière similaire, une arête epeut être supprimée (resp. ajoutée) d’un graphe G, et le sous-graphe
résultant est représenté par G−e(resp. G+e). Notez que la suppression d’une arête ne retire pas de sommets
du graphe.
•G−V′=G[V′] On supprimer tous les sommets v∈V′du graphe Gavec les arêtes incidentes. Le sous-graphe
obtenu de cette opération est noté G[V′], i.e.
V(G[V′])=V−V′et E(G[V′])=E−{(v,y)∈E:v∈V′}
•Clique Une clique Cd’un graphe Gest un sous-ensemble des sommets de Gdont le sous-graphe induit G′=
(C,E′) est un graphe complet, en d’autres termes, deux sommets quelconques de la clique Csont toujours
adjacents.
•Stable Un stable – appelé aussi ensemble indépendant (independent set en anglais) est un ensemble de som-
mets deux à deux non adjacents. Donc le sous-graphe induit est sans arcs.
FIGURE 1.5 – L ’ensemble des sommets en bleu dans ce graphe est un stable maximal du graphe.
Note : -
Le problème décisionnel de la clique (c’est à dire existe t-il une clique de taille k) est NP-complet . De même la
recherche d’un stable de taille maximum dans un graphe est un problème NP-complet et difficile à approximer.
Exercice 1.2
Trouver un plus grand stable et une plus grande clique du graphe suivant :
8
4
62 7
3
1 5
Indice : vérifier le résultat avec networkx.find_cliques(G) et.maximum_independent_set(G) de python.H. SABRI 9
Opérations binaires
Union L ’union de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∪H=(VF,EF) dans lequel
VF=VG∪VH et EF=EG∪EH
Intersection L ’intersection de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∩H=(VF,EF)
dans lequel
VF=VG∩VH et EF=EG∩EH
1.3 Représentation d’un graphe
Il est important de savoir comment représenter les graphes au sein d’un ordinateur. Il ya plusieurs méthodes
selon la nature des traitements que l’on souhaite appliquer au graphe considéré.
1.3.1 Listes d’adjacences (ou de succession)
Soit Gun (di)graphe. On suppose que les sommets de Gsont numérotés de S1àSn. La représentation par listes
d’adjacence de Gconsiste en un tableau (ou des listes chainées) tel que la ligne i=1... ncorrespond au sommet Si
et comporte la liste des voisins/successeurs (ou des prédécesseurs) de ce sommet notée T[Si]. Les sommets dans
chaque liste d’adjacence sont généralement listés selon un ordre arbitraire.
1
2
345
FIGURE 1.6 – Un digraphe
La liste d’adjacence de digraphe 1.6 est donc :
1 2 3 4 5
2 3
3 4
4−
5 1 410 Chapitre 1. Les graphes
1.3.2 Matrices d’adjacence
Définition 1.6: Mat. Adjacence
Soit G=(V,E) un graphe (orienté) d’ordre n. On peut numéroter V={1,2,..., n}.La matrice d’adjacence
deGest la matrice carrée A=(ai j) d’ordre n, définie par :
ai j=(
1 si ( i j)∈E;
0 sinon.
Remarque 3.
1. Si le graphe G est non orienté et simple, alors la matrice A est symétrique avec des 0sur la diagonale. Pour un
digraphe simple, on a toujours des 0sur la diagonale, mais la matrice n’est pas symétrique en général.
2. Pour les multigraphes, il peut y avoir des termes diagonaux (pour les boucles) et s’il y a plusieurs arêtes de i à
j , le coefficient de la matrice a i jest le nombre d’arêtes de i à j .
3. Pour un (di)graphe valué G =(V,E,w), on pose :
ai j=(
w(i,j)si(i j)∈E ;
∞ sinon.
La matrice d’adjacence de la figure 1.4 est :

∞ 5∞ 4 3 ∞
∞ ∞ 3∞ 1∞
∞ ∞ ∞ ∞ ∞ 5
∞ ∞ 3∞ 3 3
∞ ∞ ∞ ∞ ∞ 8
∞ ∞ ∞ ∞ ∞ ∞

1.3.3 Matrice d’incidence
Définition 1.7: Mat. Incidence
Soit G=(V,E) un graphe (simple) d’ordre net de taille m. On pose V={v1,v2,..., vn} etE={e1,e2,..., em}.
La matrice d’incidence deGest la matrice de type n×m B=(bi j), définie par :
•Si G orienté
bi j=

1 si ej=vi→ • (i.e. viest l’extrémité initiale de ej) ;
−1 si ej= • → vi(i.e. viest l’extrémité terminale de ej) ;
0 sinon.
•Si G non-orienté
bi j=(
1 si viest une extrémité de ej;
0 sinon.
Exercice 1.3
1. Donner la matrice d’incidence du graphe 1.6.
2. Montrer le théorème 1.1 avec la matrice d’incidence.CHAPITRE 2
La connexité
Il est important de savoir si on peut suivre un chemin d’un sommet donné à un autre dans un graphe donné.
Cette propriété (de connexité) doit être maintenue dans différents types de réseaux.
2.1 Les chaînes et les cycles
Définition 2.1: (chaine – cycle) (chemin – circuit)
•Graphe non orienté
1. Une chaîne (walk ) reliant xày, notée µ(x,y), est définie par une suite finie d’arêtes consécutives,
reliant xày, ou encore une séquence de sommets (puisque non multigraphe)
µ(x,y)=<v0,v1,..., vk>
tels que v0=x,vk=yet (vi−1,vi)∈E(G) pour tout i=1... k. Six=yla chaîne est dite fermée .
Lalongueur du chaîne l(µ(x,y)) est le nombre d’arcs dans la chaîne, c’est-à-dire k.
2. Une chaîne élémentaire (a path ) si tous les sommets sont distincts. Une chaîne simple (a simple
walk, a trail ) est une chaîne ne passant pas deux fois par une même arête, c’est-à-dire dont toutes
les arêtes sont distinctes. Remarquer que : élémentaire =⇒ simple.
3. Un cycle v0v1...vnde longueur n≥3 est une chaîne simple fermée ( v0=vn) tel que les sommets
v0,v1,..., vn−1sont tous distincts. Un graphe sans cycle est dit acyclique .
•Graphe orienté
Dans un graphe orienté, on parlera de chemin au lieu de chaîne, et de circuit au lieu de cycle.
Example 2.1
abxcd xa est une chaîne simple et fermée (non cycle!) de longueur 6 (mais, c’est un graphe eulérien - voir
plus loin). Y a-t-il un cycle de longueur 3,4 ?
a b
x
c dÏ
Remarque 4.
1. On peut pivoter une chaine fermée (l’orienter de manière arbitraire) , i.e.
<v0,v1,v2,..., v0>=< vk,vk+1,..., v0,v1,..., vk>
1112 Chapitre 2. La connexité
2. Soient x ,y∈V . La distance de x à y est définie par :
d(x,y)=(
k si le plus court chemin/chaîne de x vers y est de longueur k
∞ sinon
On convient que d (x,x)=0.
3. Le diamètre du graphe la plus grande distance entre deux sommets.
L ’observation suivante, bien que très facile à prouver, sera utile.
Théorème 2.1
S’il existe une chaîne du sommet yau sommet zdans le graphe G, où y̸=z, alors il existe une chaîne élé-
mentaire ( path ) dans Gavec pour premier sommet yet pour dernier sommet z.
Preuve. Soit la chaine
W1=µ(y,z)=x0x1...xn; avec x0=yetxn=z.
Si les sommets x0,x1,..., xnsont tous distincts, alors W1est une chaîne élémentaire, et nous avons terminé. Sinon,
il existe xi=xj(i<j) et on écrit :
W2=x0x1...xixj+1...xn.
Alors, l(W2)<l(W1). Si W2ne contient aucun sommet répété, alors c’est la chaîne recherché. Sinon, par la même
procédure, il existe W3(y z−chaîne) tel que
l(W3)<l(W2)<l(W1).
Ce processus doit s’arrêter à un certain stade, car chaque chaîne est plus courte que la précédente et la longueur
ne peut jamais être inférieure à 1
1< ··· < l(Wk)< ··· < l(W3)<l(W2)<l(W1).
Ainsi, pour un certain k,Wkne peut pas être réduit en longueur. Donc, la chaîne Wkne contient aucun sommet
répété et est donc une y z−chaîne élémentaire (path).
Exercice 2.1
Dans le graphe suivant, construire un path à partir de la chaîne W=v2v3v4v5v6v4v2v8v1
v1
 v2
v3
v4
v5
v6
v7
 v8
 v9
Calculer d(v1,v7) et le diamètre de G.
/pythonpython : >>G = nx.Graph([(1, 2), (2, 3), (2, 4), ...]) >>nx.diameter(G)
Les cycles fournissent la caractérisation suivante pour les graphes bipartis .H. SABRI 13
Théorème 2.2
Un graphe est biparti si et seulement s’il ne contient aucun cycle de longueur impaire.
Preuve.
⇒On suppose que G=U˙∪Vest un graphe biparti. Soit W=< x1,x2,..., x2k+1,x1>un cycle de longueur im-
paire (2 k+1). Si x1∈U, alors
x1∈U=⇒ x2∈V=⇒ x3∈U=⇒ ··· =⇒ x2k+1∈U=⇒ x1∈V/exclamati⌢n-triangle
absurde, d’où le résultat.
⇐On suppose que Gest connexe (car l’union des composantes connexes bipartis est un graphe biparti). Soit
xun sommet de Get on pose :
U={y∈V(G):d(x,y) est paire} et V={z∈V(G):d(x,z) est impaire}
S’il existe y1,y2∈Utel que y1y2∈E(G), alors on a :
W1=<x,..., y1>est une chaîne de longueur paire =2k1
W2=<x,..., y2>est une chaîne de longueur paire =2k2
=⇒ W3=<x,..., y1,y2,..., x>est un cycle de longueur impaire =2k1+2k2+1/exclamati⌢n-triangle
Donc G=U˙∪Vest un graphe biparti.
Exercice 2.2
Vérifier si le graphe maison est un graphe biparti. Faire de même pour la grille G4,4.
maison grille
2.2 Graphe connexe, eulérien, hamiltonien
Définition 2.2: Graphe connexe
Un graphe est dit connexe si deux points peuvent toujours être joints par une chaîne, i.e.
∀x,y∈V(G),d(x,y)< ∞
— Une composante connexe d’un graphe est un sous-graphe induit maximal connexe.
— Un point d’articulation d’un graphe est un sommet dont la suppression augmente le nombre de
composantes connexes.
Par exemple, le graphe suivant :14 Chapitre 2. La connexité
a
 b
d
 c
e
f
 g
n’est pas connexe car il n’existe pas de chaîne entre les sommets aete. On a donc 2 composantes connexes. En
revanche, le sous-graphe induit par les sommets { a,b,c,d} est connexe dont aest le seul point d’articulation.
Remarque 5.
1. Un graphe connexe à n sommets possède au moins n −1arêtes ( faite une preuve par récurrence ).
2. L’algorithme de parcours en profondeur permet de déterminer si un graphe est connexe ou non.
3. Même définitions dans un graphe orienté . Graphe orienté (fortement) connexe et de composante connexe .
Définition 2.3: Graphe eulérien
— Une chaîne joignant deux sommets xetyest dite chaîne eulérienne si elle emprunte chaque arête
deGune et une seule fois. On parle de chemin eulérien dans le cas d’un graphe orienté.
— Un cycle eulérien est une chaîne eulérienne dont les extrémités coïncident. Un graphe qui admet
un cycle (resp. circuit) eulérien est dit graphe eulérien .
/flushedRemarquer qu’un cycle eulérien n’est pas forcément un cycle comme définit dans la définition 2.1
Si un graphe (ou multigraphe) Gpossède une chaîne eulérienne, alors soit Gpossède deux sommets impairs, le
début et la fin de cette chaîne, soit Gn’a aucun sommet impair, et la promenade d’Euler commence et se termine
au même point (cycle eulérien). Une autre condition nécessaire évidente est que Gdoit être connexe. Ces deux
conditions sont ensemble suffisantes.
Théorème 2.3 Euler
Soit Gun graphe (multigraphe) connexe.
— Si Gn’a pas de sommets impairs, alors il possède un cycle eulérien (commençant à n’importe quel
point).
i.e.∀x,d(x)≡0 mod 2 =⇒ Gest un graphe eulérien.
— Si Ga deux sommets impairs, alors il possède une chaîne eulérienne dont le début et la fin sont les
sommets impairs.
La réciproque est aussi vraie.
Preuve.
⇐On commence par la réciproque. S’il existe une chaîne eulérienne µ(x,y), alors on peut crée une arête fictive
e=(y,x) et par la suite on obtient un cycle eulérien. Donc il suffit de montrer que si Gadmet un cycle
eulérien alors tous les sommets sont de degré pair.
Soit W=< v1,v2,..., vn,v1>un cycle eulérien. Soit le sommet vjavec j̸=1, il est donc claire que chaque
fois vjapparaît dans W, il ya deux arcs distincts incidents en vj( (•,vj) et ( vj,•)). Comme toutes les arêtes
sont utilisées, on voit que d(vj) est pair. Même chose pour v1car on ajoute deux arcs ( v1,v2) et ( v1,vn).
⇒On suppose que tous les sommets sont de degré pair. Montrons que Gadmet un cycle eulérien. Puisque
tous les sommets sont de degré pair on peut construire d’abord une chaîne simple fermée (quelconque)
W1=<v1,v2,..., vk,v1>
SiW1contient chaque arête de G, alors c’est finis, c’est un cycle eulérien. Sinon (puisque Gest connexe), il
existe une arête e=(vi,c) qui n’est pas dans W1(avec visommet de W1). On pose le sous-graphe
G′=G−{ arêtes de W1}H. SABRI 15
Il est donc claire que les sommets de G′sont aussi de degré pair. Alors, par la même procédure on construit
une chaîne simple fermée dans G′de la forme : <vi,c,d,..., vi>et par la suite on insère cette chaîne dans
W1pour obtenir :
W2=<v1,v2,..., vi,c,d,..., vi,vi+1,..., vk,v1>
Sil(W2)< |E(G)|, on construit W3de longueur plus grand. Ainsi, on a :
l(W1)<l(W2)<l(W3)< ··· ≤ | E(G)|
Donc, nécessairement, il existe Wk(chaîne simple fermée de longueur |E(G)|) donc c’est un cycle eulérien.
Finalement , si∃a,b∈V(G):d(a)≡d(b)≡1 mod 2, et tous les autres sommets sont de degré pair, alors on
pose :
G′=G+{a,b}
et donc tous les sommets de G′sont de degré pair. Avec la construction précédente, il existe un cycle eulérien
dans G′:
W=<a,b,v1,..., a>
est donc la chaîne <b,v2,..., a>est une chaîne eulérienne dans G.
Algorithme 1 : Euler
Entrées : Gun graphe eulérien
Output : Un cycle eulérien W
/* On suppose que G est eulérien, i.e. les sommets sont de degré pair */
1Gaux←G;W←µ(v,v) une chaîne simple (quelconque) de G; // Initialisation
2tant que l(W)<e(G)faire
3 Gaux←G−{ arêtes de W} ;
4 Choisir ( x,c)∈E(Gaux) tel que x∈W;
5 L←< x,c,..., x>une chaîne simple de Gaux ;
6 Dans W, remplacer (juste ce) xpar la séquence L;
7fin
8retourner W;
Exercice 2.3
1. Montrer que le graphe de l’exercice 2.1 est un graphe eulérien et donner un cycle eulérien.
2. Tracer cette maison d’un seul trait.
Remarque 6. Le théorème d’Euler dans un graphe orienté connexe s’écrit :
Admet un circuit eulérien si, et seulement si, pour tout sommet, le degré entrant est égal au degré sortant.
∀v∈V(G),d+(v)=d−(v)
Admet un chemin eulérien de a vers b si, et seulement si,


d+(v)=d−(v) ;∀v̸=a,b,
d−(a)=d+(a)−1
d−(b)=d+(b)+116 Chapitre 2. La connexité
Définition 2.4: Graphe hamiltonien
Soit Gun graphe connexe d’ordre n. On appelle :
1. On appelle cycle hamiltonien deGun cycle passant (une et une seule fois) par chacun des sommets
deG. Un graphe est dit hamiltonien s’il possède un cycle hamiltonien.
2. Une chaîne hamiltonienne est une chaîne passant une et une seule fois par chacun des sommets de
G. Un graphe ne possédant que des chaînes hamiltoniennes est semi-hamiltonien .
3. Dans un digraphe, on change cycle par circuit et chaîne par chemin .
Remarque 7.
— Une chaîne hamiltonienne est une chaîne élémentaire de longueur n −1.
— Un graphe peut être eulérien, hamiltonien, les deux à la fois, ou aucun des deux.
— De nombreux problèmes concrets peuvent être formulés en termes de recherche de parcours hamiltoniens : pro-
blème du voyageur de commerce (chercher un cycle hamiltonien de longueur totale minimale), l’ ordonancement
de tâches .
— Le problème du chaîne hamiltonienne est un problème NP-complet .
Exercice 2.4
Donner un graphe (connexe, simple) qui soit :
1. hamiltonien et eulérien.
2. hamiltonien et non eulérien.
3. eulérien et non hamiltonien.
4. non hamiltonien et non eulérien.
Aucune condition nécessaire et suffisante adéquate n’est connue pour l’existence de cycles hamiltoniens. Le
résultat suivant constitue une condition suffisante utile.
Théorème 2.4 Ore
Soit Gun graphe simple d’ordre n≥3. Si pour toute paire { x,y} de sommets non adjacents, on a d(x)+d(y)≥
n, alors Gest hamiltonien.
Preuve. On suppose que le théorème est faux. Alors, il existe un graphe Gsimple d’ordre nnon hamiltonien tel que
d(u)+d(v)≥npour tout sommets non adjacents uetv. On prend Gun tel graphe d’ordre nde taille maximale qui
vérifie cette propriété (remarquer que le graphe complet Knest hamiltonien).
Soient uetvdeux sommets non adjacents de G. Par maximalité de G, le graphe G+uv(d’ordre n) doit être
hamiltonien. Donc il existe dans G+uvun cycle hamiltonien :
W=<u,x1,x2,..., xn−2,v,u>
u
x1
xi xi+1xn−2
v
... ...
Or, si uxi+1∈E(G) etv xi∈E(G) (les arcs en rouge), alors on peut construire dans Gle cycle hamiltonien :
<u,x1,x2,..., xi,v,xn−2,..., xi+1,u>H. SABRI 17
Ceci est absurde car Gest non hamiltonien. Donc si xi+1est un sommet voisin à u, alors le sommet xin’est pas
voisin de v:
xi+1∈Γ(u)=⇒ xi∉Γ(v)
Donc :
d(u)= |Γ(u)| =p=⇒ d(v)≤(n−1)−p
et par la suite
d(u)+d(v)≤n−1
ce qui absurde par hypothèse. Donc Gest hamiltonien.
Une conséquence immédiate est le théorème de Dirac :
Proposition 2.1 Dirac
Soit Gun graphe simple d’ordre n≥3. Si pour tout sommet xdeG, on a d(x)≥n
2, alors Gest hamiltonien.
2.3 Arbres
Définition 2.5: Arbres et forêts
On appelle arbre tout graphe (non orienté) connexe et acyclique . Les composantes connexes dans un
graphe acyclique sont des arbres et le graphe est dit forêt . Une feuille ou sommet pendant est un som-
met de degré 1.
Un forêt avec deux arbres
Un graphe Gest une arborescence s’il existe un sommet Rappelé racine deGtel que, pour tout sommet
SdeG, il existe un chemin et un seul de Rvers S. Donc, c’est un arbre orienté dans lequel on choisit un
sommet Rcomme racine et on dirige les arcs vers le sens sortant de la racine.
Remarque 8.
— Un graphe G d’ordre n est un arbre ssi G est sans cycle et possède n −1arêtes.
— Un graphe G d’ordre n est un arbre ssi G est connexe et possède n −1arêtes.
— G est un arbre si pour chaque paire u ,v de sommets distincts est reliée par une seule chaîne (donc chaîne
élémentaire d’après le théorème 2.1).
— Un arbre (ou forêt) est nécessairement un graphe simple.
Pour démontrer les remarques précédentes, il suffit de prouver le théorème suivant :
Théorème 2.5
Soit Gun graphe ayant marêtes, nsommets et pcomposantes connexes, on définit nu( G) :
ν(G)=m−n+p
Alors, on a :
1.ν(G)≥0.
2.ν(G)=0⇐⇒ Gest acyclique.18 Chapitre 2. La connexité
Preuve. Par récurrence sur la taille mdu graphe. Le résultat est évident pour m=0 et m=1. On suppose le résultat
est vrai pour les graphe de taille m, et montrons que ceci est vrai pour un graphe de taille m+1. Soit donc Gun
graphe d’ordre nde taille m+1 ayant pcomposantes connexes.
•On suppose que Gest un graphe acyclique. Soit uvune arête de Gdans la composante C. Si on supprime uv,
la composante Cse transforme en deux composantes connexes (sinon on a un cycle dans G). Par la suite,
le graphe G′=G−uvest un graphe acyclique d’ordre n, de taille met ayant p+1 composantes connexes.
Donc d’après l’hypothèse de récurrence :
ν(G′)=0=(m−1)−n+(p+1)=m−n+p=ν(G)
•Maintenant, si Gcontient un cycle Wdans la composante connexe C. Soit uvune arête de W, alors si on
supprime l’arête uv, la composante Creste connexe. Donc le graphe G′=G−uvest un graphe d’ordre nde
taille m−1 ayant pcomposantes connexes. Donc, d’après l’hypothèse de récurrence :
ν(G′)=(m−1)−n−p≥0
=⇒ν(G)=m−n−p≥1>0
D’où le résultat – car si ν(G)=0,Gne peut être que acyclique, sinon 0 =ν(G)≥1/exclamati⌢n-triangle
2.3.1 Codage et décodage d’un arbre – Prüfer code
Soit Tun arbre ayant nsommet numérotés {1,2,..., n}. Le codage de Prüfer représente l’arbre Tarbre de avec
une suite P=(x1,x2,x3,..., xn−2) de n−2 termes (les n° des sommets avec répétition possible). Une suite Pdonnée
correspond à un et un seul arbre numéroté. Voici les algorithmes de codage et de décodage.
Algorithme 2 : Codage de Prüfer
Entrées : Un arbre T
Output : Séquence de Prüfer P
1P←() ; // Initialisation de P comme séquence vide
2tant que v(T)>2faire
3 x←feuille de Tayant le n° minimum ; // donc d(x)=1
4 P←(P,s) où sest le seul (n°) sommet adjacent à x;
5 T←T−x;
6fin
7retourner P;
Example 2.2
Donner le code de Prüfer de l’arbre :
126 345
Indice : on trouve, P=(2,3,3,2)
Pour faire la réciproque, étant donnée une séquence P=(x1,x2,..., xn−2) où les xi∈{1,2,..., n}, on construit
l’arbre Tdont les sommets sont {1,2,..., n} avec l’algorithme suivant (le décodage) :H. SABRI 19
Algorithme 3 : Décodage de Prüfer
Entrées : Une séquence Pde taille n−2
Output : L ’arbre Tcorrespondante
1I←{1,2,..., n};
2T←graphe tel que V(T)=IetE(T)= ; ; // T graphe à n sommets isolés
3tant que P̸=()faire
4 i←min {x∈I:x∉P};
5 T←T+(i,P[1]) ; // ajouter l'arc (i,P[1])
6 P←P−P[1];I←I−{i};
7fin
8T←T+(a,b) ; // a,b sont les deux éléments restant dans I
9retourner T;
Example 2.3
Donner l’arbre dont le code de Prüfer est : P=(2,3,3,3)
Puisqu’il ya une bijection entre les arbres d’ordre net les suites Pde longueur n−2 à coefficients dans {1,2,..., n},
on déduit le théorème de Cayley :
Théorème 2.6 Formule de Cayley
Le nombre d’arbres que l’on peut construire sur n(n≥2) sommets numérotés est égal à nn−2.
2.3.2 Arbre couvrant de poids minimum – ACM
Soit Gun graphe (non orienté). Un arbre couvrant (spanning tree) TdeGest un sous graphe couvrant de G
tel que Test un arbre. Remarquer que, Gdoit être connexe, sinon un arbre couvrant de Gn’existe pas. Le nombre
des arbres couvrant de Gest noté a(G). Remarquer que a(Kn)=nn−2(le nombre de Cayley). Un problème algo-
rithmique classique est de trouver, dans un graphe valué , un arbre couvrant de poids minimal . On dispose de
plusieurs algorithmes (l’algorithme de Prim, l’algorithme de Kruskal ...).
Algorithme 4 : Kruskal
Entrées : Un graphe Gvalué d’ordre net de taille m
Output : Arbre (ou forêt) couvrant de poids minimum
1Numéroter les arêtes de Gpar poids minimum : w(e1)≤w(e2)≤ ··· ≤ w(em)
2T←graphe tel que V(T)=V(G) etE(T)= ; ; // T graphe à n sommets isolés
3k←0;
4tant que k<m et e (T)<n−1faire
5 siT+ek+1est acyclique alors
6 T←T+ek+1;
7 k←k+1;
8fin
9retourner T;
Appliquer l’algorithme de Kruskal dans le graphe suivant :
CHAPITRE 3
Les algorithmes de base
Beaucoup de problèmes sur les graphes nécessitent que l’on parcourt l’ensemble des sommets et des arcs. Par
exemple, pour vérifier que le graphe est connexe, chercher un sommet particulier, construire un arbre couvrant,
trouver un plus court chemin ...etc.
3.1 Parcours en profondeur (DFS) / largeur (BFS)
Une manière simple de tester si un graphe Gest connexe ou non est d’exécuter l’algorithme DFS ouBFS dans
Gen commençant par n’importe quel sommet et en enregistrant les sommets visités pendant l’exécution dans une
liste. Si la liste contient tous les sommets de G, alors Gest connexe. Une petite modification permet de donner les
composantes connexes de G. L ’algorithme DFS_Component suivant donne les composantes connexes de G. Il est
donné sous forme d’implémentation récursive.
Algorithme 5 : DFS_Component
Entrées : Un graphe G=(V,E)
Output : Les composantes connexes C=(C1,C2,..., Ck) de G.
1VisitedNodes ← ; ;
2k←0 ; // k est le nombre des composantes connexes
3pour chaque u∈Vfaire
4 siu∉VisitedNodes alors
5 k←k+1;
6 DFS( u);
7 fin
8fin
9retourner (C1,C2,..., Ck);
1Procedure DFS( u )
2 VisitedNodes ←VisitedNodes ∪{u};
3 Ck←Ck∪{u};
4 pour chaque x∈Γ(u)faire
5 six∉VisitedNodes alors
6 DFS( x);
7 fin
8 fin
Note : -
Il est possible de d’implémenter la procédure DFS itérativement à l’aide d’une pile LIFO (stack) contenant les
sommets à explorer : on désempile un sommet et on empile ses voisins non encore explorés.
20H. SABRI 21
Pseudocode :
stack . push ( root )
while stack . isEmpty ( ) = f a l s e do
node = stack . pop ( ) // so mark i t as v i s i t e d
for each x in node . childNodes do
i f x i s not v i s i t e d then
stack . push ( x )
. . .
endfor
endwhile
Example 3.1 (DFS )
Ici on empile (gris) les sommets les plus à droite, alors l’ordre des sommets visité (noir) est ( a,b,d,e,g,c,f).
Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b
 c
d
 e
f
g
a
b
 c
d e
f
ga
b
 c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g
L ’utilisation d’une file (FIFO) au lieu d’une pile transforme l’algorithme du parcours en profondeur en algo-
rithme de parcours en largeur ( BFS ). Avec BFS l’exemple précédent devient (en enfile le plus à gauche) :
Example 3.2 (BFS )
Ici, avec BFS, on enfile (gris) les sommets les plus à gauche d’abord, alors l’ordre des sommets visité (noir)
est ( a,b,d,e,g,c,f). Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b c
d
 e
f
g
a
b c
d
 e
f
ga
b c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g22 Chapitre 3. Les algorithmes de base
Exercice 3.1
1. Écrire la procédure BFS .
2. Utiliser DFS (ou BFS) pour la construction d’un arbre couvrant d’un graphe connexe. L ’appliquer
pour le graphe triangle.
3. Utiliser DFS pour écrire une procédure DFS_Cycle pour détecter un cycle dans un graphe.
On sait qu’un graphe orienté G=(V,E) est fortement connexe si pour chaque paire de sommets u,v∈V, il
existe un chemin de uàvet il existe un chemin de vàu. En d’autres termes, nous avons besoin d’une connectivité
dans les deux directions .
Une procédure pour tester si un graphe orienté est fortement connexe ou non peut être conçue avec l’idée
suivante. En partant d’un sommet arbitraire vdu graphe G, on exécute l’algorithme BFS ouDFS et l’on note les
sommets visités. Ensuite, on obtient la transposée de G,GT, en inversant la direction des arêtes de G, et l’on
exécute à nouveau l’algorithme BFS ou DFS à partir du sommet v. Si les sommets visités dans les deux cas sont
égaux à V, alors le graphe orienté est fortement connexe. Cette méthode est illustrée dans l’algorithme 6.
Algorithme 6 : Fortement_connexe
Entrées : Un graphe orienté G=(V,E)
Output : true siGest fortement connexe et false sinon
1X← ; ;
2Y← ; ;
3v←un sommet quelconque de V;
4X←DFS( G,v) ; // Enregistrez les sommets visités dans X
5GT←Gavec flèches inversées;
6Y←DFS( GT,v);
7siX=Y=Valors
8 retourner TRUE.
9sinon
10 retourner FALSE.
11fin
3.2 Recherche des chemins
3.2.1 Matrice d’adjacence et nombre de chemins
La puissance de la matrice d’adjacence Amontre qu’il y a des chemins (ou chaînes) de longueur kallant de xà
ycomme le montre le théorème suivant.
Théorème 3.1
Soit G=(V,E) un (di)graphe. On note V={1,2,..., n} et Asa matrice d’adjacence et Akla puissance k-ème
deA. Alors le terme d’indices i,jdeAkest le nombre de chemins (chaînes) de longueur kallant de iàj.
Preuve. Par récurrence sur k. Pour k=1 c’est clair. On suppose le résultat est vrai à l’ordre ket montrons qu’elle
est vrai pour k+1. Soit S=(si,j)=Ak. Si on a un chemin de iàjde longueur k+1, alors on va d’abord de ià un
sommet ravec kpas et puis de ràj. Or d’après l’hypothèse de récurrence on a si,rchemins possibles pour aller de
iàret finalement ar,jpas (1 ou 0) pour aller de ràj. Ainsi, le nombre totale possibles (i.e. tous les sommets r) est :
nX
r=1si,rar,j=³
Ak×A´
i,jH. SABRI 23
ce qui est bien le terme ( i,j) de la matrice Ak+1.
3.2.2 Plus court chemin et l’algorithme de Dijkstra
Dans cette partie on suppose que le (di)graphe G=(V,E,w) est valué positivement (i.e.∀e∈E,w(e)>0). Notre
objectif est de chercher un plus court chemin (i.e., un chemin de poids minimal ) d’un sommet ufixé à un sommet
quelconque de G.
Il est clair que l’on peut restreindre ce problème au cas d’un (di)graphe simple1. On suppose aussi que Gest
connexe (sinon, certains trajets sont impossibles). Il est aussi claire (d’après théorème 2.1), qu’un plus court chemin
est nécessairement un chemin élémentaire (path).
L ’algorithme de Dijkstra (1959) permet de calculer le plus court chemin entre un sommet particulier u(racine )
et tous les autres sommets. L ’algorithme fonctionne de la manière suivante :
Pour tout sommet vdeG, on associe une valeur T(v), initialisée à w(u,v) et une liste de sommets C(v) qui
correspond à un chemin de uàv. À la fin de l’algorithme, T(v) contient le poids minimal des chemins joignant uà
v(ou T(v)= ∞ siu↛v) et la liste C(v) réalise un tel chemin. Voici donc l’algorithme de Dijkstra :
Algorithme 7 : Algorithme de Dijkstra
Entrées : Un (di)graphe valué G=(V,E,w) et un sommet racine u
Output : Le coût minimum d’un chemin de uàv(∀v∈V) et un trajet pour chaque coût minimal obtenu
1∀v∈V,T(v)←w(u,v) etC(v)←(u,v); // Initialisation de T(v) et la liste C(v)
2X←{u};
3tant que X̸=Vfaire
4 Choisir v∈V−Xtel que ∀y∈V−X,T(v)≤T(y);
5 X←X∪{v};
6 pour chaque y∈V−Xfaire // Faire les mises à jours pour les autres sommets
7 siT(y)>T(v)+w(v,y)alors
8 T(y)←T(v)+w(v,y);
9 C(y)←[C(v),y]; // On ajoute à la liste C(v) l'élément y
10
11 fin
12 fin
13fin
Example 3.3
Voici une application de l’algorithme de Dijkstra au digraphe suivant. On prend Ecomme sommet racine.
EA
B
CD
FG
S5
4
21
12
2
34
4
215
7
1. En effet, passer par une boucle ne ferait qu’augmenter inutilement le poids de ce chemin. De même, si plusieurs arcs joignent deux
sommets, il suffit de conserver l’arc de poids minimal.24 Chapitre 3. Les algorithmes de base
Ainsi, pour l’initialisation, on a : X={E} et on a les valeurs :
v  E A B C D F G S
T(v) 0 5 4 2 ∞ ∞ ∞ ∞
C(v)(E,E) ( E,A) ( E,B) ( E,C) ( E,D) ( E,F) ( E,G) ( E,S)
Maintenant, on choisit (un seul choix) le sommet C, donc X={E,C}. Le tableau est mis à jour :
v  E A B  C D F G S
T(v) 0 5 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À l’étape suivante, on est forcé de choisir B. Ainsi, X={E,C,B} et la mise à jour est :
v  E A  B  C D F G S
T(v) 0 4 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À présent, on a le choix entre AetF. On choisit A. Donc X={E,C,B,A} et on a :
v  E  A  B  C D F G S
T(v) 0 4 3 2 6 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,B,A,D) ( E,C,F) ( E,C,G) ( E,S)
Puis, on prend le sommet F. D’où X={E,C,B,A,F} et :
v  E  A  B  C D  F G S
T(v) 0 4 3 2 5 4 5 11
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,S)
On prend Det on obtient X={E,C,B,A,F,D} et :
v  E  A  B  C  D  F G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Finalement, on prend Gpuis Set on voit que ceci ne change rien. D’où le tableau finale :
v  E  A  B  C  D  F  G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Ainsi le chemin minimum pour aller de EàSest de coût 10 et un trajet de coût minimal de EàSest : EC F DS .H. SABRI 25
3.3 Problèmes d’ordonnancement et chemin critique
Un problème d’ordonnancement peut-être représenté sous la forme d’un digraphe. Les sommets sont des évé-
nements (début et fin de la tâche) et les arcs des tâches, La longueur (ou poids) de chaque arc représente la durée
d’exécution de la tâche. Ainsi, la tâche correspondant à l’arc ( i,j) ne peut commencer que si toutes les tâches cor-
respondant à des arcs ( k,i) ont été complétées. On ajoute deux sommets pour le début (s) et de fin(t) du projet .
Le digraphe peut contenir des tâches fictives dedurée nulle afin de forcer certaines précédences (postériorité).
Ainsi, un réseau PERT est un digraphe valué G=(V,E,w,s,t) où la fonction poids (ou longueur) w:E→R+
etsle sommet source (début) et tle sommet puits (fin). Un chemin critique est un chemin de sàtdelongueur
maximale . S’il n’existe pas de chemin critique, le projet n’est pas réalisable (e.g. un circuit). Le temps minimal
requis pour l’exécution d’un projet réalisable est égal à la longueur d’un chemin critique. Les tâches figurant sur un
chemin critique sont aussi appelées critiques, ce qui s’explique par le fait que tout retard d’exécution d’une tâche
critique retarde d’autant l’exécution du projet.
3.3.1 Algorithmes de tri topologique et de chemin critique
Il faut d’abord numérotés les sommets de 1 à nde manière compatible au pré-ordre (rang) avec l’algorithme du
rang suivant (tri topologique) :
Algorithme 8 : Algorithme du rang
Entrées : Un digraphe G=(V,E) sans circuit
Output : Le rang r(v) de chaque sommet v∈Vde G
1r←0;X←V;
2R←{v∈X:Γ−
X(v)= ;} ; // l'ensemble des sommets de X sans prédécesseur dans X
3tant que X̸= ; faire
4 r(v)←rpour chaque sommet v∈R;
5 X←X−R;
6 R←l’ensemble des sommets de Xsans prédécesseur dans X;
7 r←r+1;
8fin
On supposera dorénavant que les sommets ont déjà été numérotés de 1 à nde manière compatible avec leurs
rangs, c’est-à-dire que r(j)>r(i) implique j>i(donc 1 =setn=t). Enfin, on supposera éliminés les arcs paral-
lèles par l’introduction de tâches fictives de durée nulle .
Pour un sommet i, on note tiledébut au plus tôt des tâches correspondant aux arcs i→jet par Tilafin au
plus tard des tâches correspondant aux arcs j→i.
Algorithme 9 : Algorithme du chemin critique
Entrées : Un digraphe G=(V,E) sans circuit trié topologiquement
Output : La durée du chemin critique et les dates ti,Ti
1t1←0;
2pour j=2···nfaire // Calcul des dates de début au plus tôt  récurrence en avançant
3 tj←max i∈Γ−(j){ti+w(i,j)}
4fin
5Tn←tn;
6pour j=n−1···1faire // Calcul des dates de fin au plus tard  récurrence en reculant
7 Tj←min i∈Γ+(j){Ti−w(j,i)}
8fin26 Chapitre 3. Les algorithmes de base
Définition 3.1
— Un sommet iest critique si ti=Ti.
— Un arc ( i,j) est critique les sommets ietjsont critiques ettj−ti=w(i,j).
— Un chemin critique est un chemin de 1 à nn’utilisant que des arcs critiques.
— La durée du chemin critique est donnée par Tn(ou par tn). Elle correspond à la durée minimale du
projet .
Example 3.4
L ’application de l’algorithme du chemin critique au digraphe suivant (trié topologiquement) est :
1 23
45
6B
9A
3
C
5D
8
E
4
F7G
20
H6I5
=⇒
 1
0,02
9,933,16
4
16,23513,24
6
29,29B
9A
3
C
5D
8
E
4
F7G
20
H6I5
Les tâches critiques sont BetG. La durée totale minimale du projet est donc 29.
Exercice 3.2
Les tâches ( durée et précédences ) pour la construction d’un entrepôt sont données dans le tableau suivant :
Tâches Nature Précédences Durée (jours)
A Acceptation des plans par le propriétaire – 4
B Préparation du terrain – 2
C Commande des matériaux A 1
D Creusage des fondations A, B 1
E Commande des portes et fenêtres A 2
F Livraison des matériaux C 2
G Coulage des fondations D, F 2
H Livraison des portes et fenêtres E 10
I Pose des murs, de la charpente et du toit G 4
J Mise en place des portes et fenêtres H, I 1
1. Représentez le graphe des précédences de ce projet (trié topologiquement).
2. Déterminez une durée totale minimale en exhibant un chemin critique dans ce graphe.CHAPITRE 4
Programmation linéaire
La programmation linéaire est le processus de minimiser ou maximiser une fonction objective linéaire sou-
mise à un nombre fini de contraintes d’égalités et d’inégalités linéaires.
La programmation linéaire a de nombreuses applications dans le domaine de l’informatique théorique. Elle
peut être utilisée pour résoudre de nombreux problèmes combinatoires variés, tels que la recherche de flot maxi-
mum dans un réseau, la recherche d’un couplage maximal dans un graphe et la coloration d’un graphe parfait.
Example 4.1 (Problème de régime)
On suppose qu’on a quatre plats : de la truite ( XT), un sandwich au corned-beef ( XC B), un burrito ( XBU R )
et un hamburger ( XHB). Le tableau suivant répertorie la valeur nutritionnelle de chaque plat (vitamines et
calories) et notre besoin journalier des vitamines.
Vit. A Vit. C Vit. D Calories
Truite 203 92 100 600
Corned-beef 90 84 230 350
Burrito 270 80 512 250
Humburger 500 90 210 500
Besoins 2000 300 430
Notre objectif est de minimiser le nombre total de calories consommées : 600 XT+350XC B+250XBU R+
500XHBtout en satisfaisant les trois besoins nutritionnels en vitamines. Le programme linéaire résultant
s’écrit :
min 600 XT+350XC B+250XBU R+500XHB
s.t. 203 XT+90XC B+270XBU R+500XHB≥2000, (Besoins de Vit. A),
92XT+84XC B+80XBU R+90XHB≥300, (Besoins de Vit. C),
100XT+230XC B+512XBU R+210XHB≥430, (Besoins de Vit. D),
XT,XC B,XBU R ,XHB≥0
Définition 4.1: Forme canonique – Forme standard
On peut écrire un P .L. sous deux formes spéciales :
•Canonique
max
mincTX+c0
s.t. AX≤b(≥bsi min),
X≥0•Standard
max cTX+c0
s.t. AX=b,
X≥0Avec :
cTX=¡
c1··· cn¢
x1
...
xn

cTX+c0=c1x1+c2x2+···+ cnxn+c0
2728 Chapitre 4. Programmation linéaire
Remarque 9. Un P .L. général peut être formulé selon une forme standard ou canonique par la méthode suivante :
générale =⇒ standard il faut éliminer les contraintes d’inégalité et les variables sans contrainte de positivité.
— Si dT
iX≤biest une contrainte d’inégalité, alors créer une nouvelle variable ( d’écart ) siet remplacer l’in-
égalité dT
iX≤bipar dT
iX+si=biet s i≥0.
Si dT
iX≥bi, alors on peut écrire dT
iX−si=biet s i≥0.
— Si une variable x i≶0est de signe quelconque, alors créez deux nouvelles variables x+
iet x−
iet remplacez
xipartout par x+
i−x−
i, et ajoutez les contraintes de signe : x+
i≥0,x−
i≥0.
générale =⇒ canonique
— Si dT
iX=biest une contrainte d’égalité, alors remplacer cette égalité par une paire d’inégalités :
dT
iX≥biet−dT
iX≥ −bi
— Même chose que précédemment si la variable x i≶0.
Il est facile de voir que les problèmes qui en résultent sont équivalents aux problème d’origine. Pour l’algorithme
simplexe , nous utiliserons la forme standard .
On remarque aussi qu’en utilisant la relation min f(x)= − max¡
−f(x)¢
dans laquelle f (x)représente la fonction-
nelle linéaire à optimiser, on peut toujours se ramener à un problème de minimisation (ou de maximisation).
Example 4.2
Le P .L :max 5 x+4y
s.t. x≤6
1
4x+y≤6
3x+2y≤22
x,y≥0s’écrit sous forme standard :max 5 x1+4x2
s.t. x1+e1=6
1
4x1+x2+e2=6
3x1+2x2+e3=22
x1,x2,e1,e2,e3≥0
Donc (sous la forme matricielle) on a :
cT=¡
5 4 0 0 0¢
;A=
1 0 1 0 0
1
41 0 1 0
3 2 0 0 1
;X=
x1
x2
e1
e2
e3
et b=
6
6
22

4.1 La méthode simplexe
4.1.1 Solution de base admissible
On suppose que la matrice Adu programme linéaire est de type m×netde rang m(pourquoi !). Soit Bla
matrice carrée extraite de Aformée par les mcolonnes j1,j2,..., jmlinéairement indépendants de A(les vecteurs
de base). Alors, Best une matrice inversible. Ainsi si on pose xl=0 sil∉{j1,..., jm} etxjklak-ième composante de
B−1b. Alors, on a AX B=b. Si de plus XB≥0(i.e. chaque xi≥0), alors :
Xest une solution de base admissible (ou réalisable)
Dans l’exemple 4.2, la matrice extraite B=
1 0 0
0 1 0
0 0 1
est inversible et B−1b=
6
6
22
. Donc XB=
0
0
6
6
22
≥0, par suite
XBest une solution de base admissible. On appelle les variables xjklesvariables de base . Les autres variables xl
sont les variables hors-base .
Parfois, il n’est pas évident de trouver une solution de base admissible, comme le montre l’exercice suivant :H. SABRI 29
Exercice 4.1
Écrire le programme linéaire suivant sous forme standard et montrer qu’on n’a pas une solution de base
admissible. Résoudre le programme linéaire.
max −x+y
s.t. x+y≥1,
3x+2y=6,
x,y≥0
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux
Dans cette section, on suppose qu’on a déjà trouvé une solution de base admissible X(produite avec B=Im)
du programme linéaire ( P: max z=cTX+c0etb≥0pour garantir que 0est une solution de AX≤b).
La méthode du simplexe est une méthode itérative qui génère une séquence de solutions de base réalisable
(correspondant à différentes bases) et s’arrête finalement lorsqu’elle a trouvé une solution de base réalisable opti-
male. Remarquer qu’on peut toujours prendre c0=0.
Algorithme 10 : Algorithme du simplexe
Entrées : Un P .L. standard P(max) avec une solution de base réalisable
Output : La solution optimale (ou non)
1On commence à écrire le tableau initiale (avec les variables de base xj1,..., xjm)
VB x1 ... xn b
xj1 b1
... A...
xjm bm
c1 ... cn−c0
2Sicj≤0 (∀j:xjest hors base), alors solution optimale (STOP) // min ⇝cj≥0
3Trouver la colonne s(hors base) tel que cs=max©
cj:cj>0ª// min ⇝cs=min©
cj:cj<0ª
4Siai,s≤0∀i=1... m, alors pas de solution optimale (STOP)
5Min Ratio Test : trouver la ligne rtel que
br
ar,s=min
i=1...m½bi
ai,s:ai,s>0¾
6Appliquer la procédure de Gauss autour de pivot ar,s(ar,s⇝1 et on annule les coefficients situés sous et
sur le pivot dans la colonne s, par combinaisons de lignes) // Ne pas oublier la dernière ligne
7Remplacer (dans VB) la variable de base ( sortante ) située à la ligne rpar la variable ( entrante )xs
8Retourner à l’étape 2 // l'algorithme termine si le programme linéaire est non dégénéré
Remarque 10.
— La dernière ligne représente l’équation linéaire −z+c1x1+···+ cnxn= −c0.
— La valeur de la variable de base de V Bde la ligne k est égale à la valeur b k(de la ligne k).
— La solution optimale du problème est la valeur finale (dernière cellule) (×− 1).
— Si on n’a pas au départ B =Im(à l’aide des variables d’écart) alors, on ajoute les variables artificielles (et on
applique d’abord la phase I - voir section suivante).30 Chapitre 4. Programmation linéaire
Exercice 4.2
Soit le programme linéaire :
max 2 x1+x2
s.t. x1−x2≤3,
x1+2x2≤6,
−x1+2x2≤2,
x1,x2≥0
Rajouter les variables d’écart. Puis résoudre le problème par l’algorithme du simplexe.
Remarque 11. Vérifier le résultat de l’exercice précédent, par la méthode graphique.
4.1.3 Initialisation - Phase I du simplexe
Un programme linéaire est dit sous forme simpliciale si la matrice Acontient la matrice identité Imcomme
sous matrice. On suppose que le programme linéaire P, après la mise en forme AX=b, n’est pas simpliciale
(possible dans le cas de contraintes du type ≥ou du type =). Soit Bune matrice d’ordre mextraite de Ainversible
tel que B−1b≥0et soit XBla solution de base réalisable ( XB≥0etAX B=b), alors on peut changer l’équation
matricielle :
AX B=b
⇐⇒ (B−1A)XB=B−1b
⇐⇒ A∗XB=b∗
et la matrice A∗contient la matrice identité Imcomme matrice extraite ( B−1A=B−1(H|B)=¡
B−1H|Im¢
). Ainsi, on
peut appliquer directement l’algorithme 10 en remplaçant Apar A∗etbpar b∗. Cependant, cette méthode n’est
pas efficace, car il faut trouver une matrice extraite Bréalisable correspondante. Pour une matrice Ade type m×n,
il existe¡m
n¢
matrices extraites à tester !
L ’idée est d’ajouter des variables, dites artificielles w1,w2,..., wm, pour faire apparaître une forme simpliciale
du programme linéaire P: (AX=b). Mais, il faut que w1= ··· = wm=0. Donc, il faut minimiser d’abord le pro-
gramme linéaire P0suivant :
P0=min W=w1+···+ wm
s.t. (A|Im)×(x1...xnw1...wm)T=b
x1,..., xn,w1,..., wm ≥0
On exprime Wà l’aide des autres variables (hors base) et puis on applique l’algorithme du simplexe 10 pour P0
(phase I). À la fin, si on trouve que les wi=0, alors les variables de bases xj1,..., xjmforment une première base
admissible pour démarrer le simplexe pour le programme d’origine P.H. SABRI 31
Remarque 12. On ajoute la ligne de Z :c1 ... cn−c0dans le tableau du simplexe de P0(phase I) et on lui
applique les opérations élémentaire comme avec les autres lignes. À la fin de la phase I, on supprime les colonnes des
wiet la ligne de la fonction W . Finalement, on utilise ce tableau pour résoudre le problème initiale P.
Example 4.3
Soit le programme linéaire P:
min 6 x1+3x2
s.t. x1+x2≥1,
2x1−x2≥1,
3x2≤2,
x1,x2≥0sous forme standard (max)= = = = = = = = = = = = = = = = = = ⇒max Z= −6x1−3x2
s.t. x1+x2−e1=1,
2x1−x2−e2=1,
3x2+e3=2,
x1,x2,e1,e2,e3≥0
La matrice Aest :
A=x1 x2 e1 e2 e3

1 1 −1 0 0
2−1 0 −1 0
0 3 0 0 1
est par suite Pn’est pas sous forme simpliciale (il n’ ya pas de sous matrice I3). Donc on peut ajouter 2
variables artificielles pour construire le problème initiale P0:
max −w1−w2=3x1−e1−e2−2
s.t. x1+x2−e1+w1=1,
2x1−x2−e2+w2=1,
3x2+e3=2,
x1,x2,e1,e2,e3,w1,w2≥0dont le vecteur X=

0 x1
0 x2
0 e1
0 e2
2 e3
1 w1
1 w2est une solution de base réalisable.
Ainsi, on commence notre algorithme 10 pour le programme P0. Le tableau initial est :
x1 x2 e1 e2 e3 w1 w2 b

w1 1 1 −1 0 0 1 0 1
w2 2−1 0 −1 0 0 1 1
e3 0 3 0 0 1 0 0 2
W: 3 0 −1−1 0 0 0 2
Z:−6−3 0 0 0 0 0 0
Le pivot c’est a2,1donc x1est la variable entrante et w2est sortante. On obtient après pivotement le tableau :
L2←1
2L2− − − − − − − − →
L1←L1−L2
L4←L4−3L2
L5←L5+6L2x1 x2 e1 e2 e3 w1 w2 b

w1 03
2−11
20 1−1
21
2
x1 1−1
20−1
20 01
21
2
e3 0 3 0 0 1 0 0 2
W: 03
2−11
20 0−3
21
2
Z: 0 −6 0 −3 0 0 3 3
Le pivot est a1,2(Min ratio test =1
3). On obtient alors :32 Chapitre 4. Programmation linéaire
L1←2
3L1− − − − − − − − →
L2←L2+1
2L1
L3←L3−3L1
L4←L4−3
2L1
L5←L5+6L1x1 x2 e1 e2 e3 w1 w2 b


x2 0 1−2
31
302
3−1
31
3
x1 1 0−1
3−1
301
31
32
3
e3 0 0 2 −1 1 −2 1 1
W: 0 0 0 0 0 −1−1 0
Z: 0 0 −4−1 0 4 1 5
Ainsi, la phase I se termine avec W=0 et x1=2
3,x2=1
3,e3=1 et e1=e2=w1=w2=0. Le tableau pour la
phase II est donc :
x1 x2 e1 e2 e3 b


x2 0 1−2
31
301
3
x1 1 0−1
3−1
302
3
e3 0 0 2 −1 1 1
Z: 0 0 −4−1 0 5
On remarque donc que les cj≤0, donc (STOP) la solution est optimale et le max est −5. Ainsi la solution
optimale pour le programme P=min6 x1+3x2est−(−5)=5=6×2
3+3×1
3.
4.2 Dualité
SoitPun P .L. sous forme canonique. Le programme dualDdePest définit par :
P=max z=cTX
s.t. AX ≤ b
X≥ 0le dual est= = = = = = = ⇒D=min w=bTY
s.t. ATY≥ c
Y≥ 0
Le programme Pest dit primal . On remarque que si Ade type m×n, alors X∈RnetY∈Rmpour le dual.
Théorème 4.1 Théorème de dualité
Si un problème primal ou dual admet une solution, alors l’autre problème admet aussi une solution et on a :
max z=cTX =
s.t. AX ≤ b
X≥ 0min w=bTY
s.t. ATY≥ c
Y≥ 0
Exercice 4.3
Soit le problème suivant de type régime :
D=min w=340x1+2400 x2+560x3
s.t. x1+2x2+x3≥ 1200
x1+3x2+2x3≥ 1400
x1+x2+3x3≥ 1500
x1,x2,x3≥ 0
Écrire le programme primal PdeD. Résoudre le programme Pet déduire la valeur minimale de w, a-t-on
besoin de faire les deux phases du simplexe ?
7} A B oS



HOUSSEM SABRI
Graphes et Optimisation
2`emeannée
LISI  LSI
Institut Supérieur des Sciences Appliquées et de Technologie de Sousse
A.U. 2023-2024
28 novembre 2023Table des matières
1 Les graphes 3
1.1 Définitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.1 Graphes non orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.2 Graphes orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.2 Opérations et quelques types de graphes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.3 Représentation d’un graphe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.1 Listes d’adjacences (ou de succession) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.2 Matrices d’adjacence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.3.3 Matrice d’incidence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2 La connexité 11
2.1 Les chaînes et les cycles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.2 Graphe connexe, eulérien, hamiltonien . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.3 Arbres . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.3.1 Codage et décodage d’un arbre – Prüfer code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.3.2 Arbre couvrant de poids minimum – ACM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3 Les algorithmes de base 20
3.1 Parcours en profondeur (DFS) / largeur (BFS) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
3.2 Recherche des chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.1 Matrice d’adjacence et nombre de chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.2 Plus court chemin et l’algorithme de Dijkstra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
3.3 Problèmes d’ordonnancement et chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
3.3.1 Algorithmes de tri topologique et de chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . 25
4 Programmation linéaire 27
4.1 La méthode simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.1 Solution de base admissible . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux . . . . . . . . . . . . . . . . . . . . . . . . 29
4.1.3 Initialisation - Phase I du simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
4.2 Dualité . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
2CHAPITRE 1
Les graphes
L ’exemple classique pour introduire la théorie des graphes est le problème des ponts de Königsberg, étudié par
Euler en 1736. Quel itinéraire doit-on suivre pour traverser chaque pont exactement une fois? Une telle prome-
nade n’existe pas, et c’est Euler qui donna la solution de ce problème en caractérisant les graphes que l’on appelle
aujourd’hui eulériens .
A
B
Ce1 e2
e3 e4
De5
e6e7
FIGURE 1.1 – Les ponts de Königsberg
Les graphes introduisent une simplification : les régions se transforment en des "points" (aussi appelés noeuds
ousommet ), les ponts se transforment en des lignes (aussi appelées arêtes ouarcs ), et ce principe s’applique dès
lors qu’une relation existe entre des objets. Les graphes relèvent de la combinatoire plutôt que de la géométrie (les
intersections, les longueurs, et la forme des arêtes n’ont aucune importance, sauf en ce qui concerne la lisibilité de
la représentation).
1.1 Définitions
Dans la suite, il est toujours supposé que les graphes sont finis, sauf indication contraire.
1.1.1 Graphes non orientés
Définition 1.1: Graphe
Un graphe Gest un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V{2}des pairs non ordon-
nées de V.Vest l’ensemble des noeuds (Vertices en anglais) et Ec’est l’ensemble des arêtes de G(Edges en
anglais). Lorsque e={x,y} est une arête, on dit que x, y sont les extrémités de cette arête, que eest incidente
enxet en y. On joint x et y par un trait et on dit que x, y sont adjacents (ou voisins). On note aussi e=x you
encore e=(x,y) (attention , dans ce cas : ( x,y)=(y,x)).
SiGest un graphe alors, on note par V(G) l’ensemble de noeuds et par E(G) l’ensemble des arcs.
Remarque 1.
— Une arête e ={x,x}s’appelle boucle .
— Dans un graphe, il peut exister des arêtes parallèles (on parle donc de multigraphe ).
Dans l’exemple des ponts on a : e 1=e2=(A,B).
34 Chapitre 1. Les graphes
— Un graphe est dit simple s’il ne comporte ni arêtes multiples ni de boucles, c’est-à-dire chaque paire de nœuds
distincts est reliée par au plus une arête, ou encore E (G)⊆P2(G).
Dans la plupart des cas, les graphes sont considérés comme simples par défaut.
Définition 1.2: ordre – taille – degré
Soit G=(V,E) un graphe.
1. On appelle ordre d’un graphe noté v(G) le nombre de ses sommets :
v(G)= |V|
2. On appelle taille d’un graphe noté e(G) le nombre de ses arêtes :
e(G)= |E|
3. Le degré (ou valence) d’un sommet xnoté d(x) est le nombre d’arêtes contenant x. (Attention! Une
boucle sur un sommet compte double).
Si on note par Γ(x) l’ensemble des voisins de x, i.e.
Γ(x)={y∈V:x y∈E}
alors, siGest simple , on a :
d(x)= |Γ(x)|
Example 1.1 (Graphe complet)
Un graphe d’ordre nest dit complet noté Knsi chaque sommet du graphe est relié directement à tous les
autres sommets, i.e. E(Kn)=P2(V(Kn)).
Représenter graphiquement K3,K4,k5. Calculer la taille de K3,k4,...Kn.
Example 1.2 (Graphe biparti)
Un graphe G=(V,E) est dit biparti si son ensemble de sommets V=V1˙∪V2, i.e. peut être divisé en deux
sous-ensembles disjoints V1etV2tels que chaque arête ait une extrémité dans V1et l’autre dans V2.
Si∀x∈V1,∀y∈V2;x y∈E, alors Gest dit biparti complet noté Kn,moùn= |V1|etm= |V2|.
a1
 a2
 a3
 a4
b1
 b2
 b3
FIGURE 1.2 – Un graphe biparti
Théorème 1.1 Lemme des poignées de main – Handshaking lemma
Soit Gun graphe alors, on a :X
x∈V(G)d(x)=2e(G)
Dans ce théorème d(x) est le nombre de personnes à qui xserre la main et e(G) le nombre total de poignées
de mains.H. SABRI 5
Preuve.
•Méthode simple Il y en a d(x) arêtes en un sommet xfixé. Pour tout les sommets cela fait doncP
x∈V(G)d(x).
Mais avec cette manière chaque arête est comptée deux fois, une fois à chacune de ses extrémités, d’où le
résultat en divisant par 2.
•Preuve par double dénombrement On pose
Z={(x,e)∈V×E:x∈e}⊆V×E
et les deux projections :
p:Z→V
(x,e)7→xet q:Z→E
(x,e)7→e
L ’idée est de calculer |Z|de deux manières différentes. D’abord, on rappelle que si f:A→Best une fonction
quelconque, alors :X
b∈B|f−1[b]| = | A|
oùf−1[b] désigne l’image réciproque de { b} par f(pourquoi ˙S
b∈Bf−1[b] est une union disjointe ?).
Ainsi on obtient :
|Z| =X
x∈V|p−1[x]| =X
e∈E|q−1[e]|
Or,|p−1[x]| =d(x) et|q−1[e]| = |{x∈V:x∈e}| =2. Donc :
X
x∈Vd(x)=X
e∈E2=2|E|
Remarque 2.
— Un sommet de degré 0est appelé sommet isolé .
— Un graphe tel que : ∀x∈V,d(x)=kest dit graphe k-régulier .
— Le graphe complet K nest un graphe (n−1)-régulier .
Exercice 1.1
Montrer que dans un graphe le nombre de sommets d’ordre impairs est toujours pair. En particulier un
graphe k-régulier avec kimpaire est un graphe d’ordre pair.
Voici quelques exemples comme application :
1. Est-il possible de relier 15 ordinateurs en réseau de sorte que chacun soit relié à exactement 3 autres ?
2. Une ligue de football comprenant 11 clubs organise un tournoi. Pour gagner du temps on décide que chaque
équipe ne jouera que la moitié des matches possibles. Comment organiser le tournoi ?
Proposition 1.1
Soit G=(V,E) un graphe (simple) d’ordre n≥2. Alors :
∃u,v∈V,u̸=v:d(u)=d(v)
Preuve. Supposons le contraire, c’est-à-dire ∀u,v∈V;d(u)̸=d(v). Or dans un graphe (simple) on a toujours d(x)∈
{0,1,..., n−1}. Dans ce cas, puisque tous les nsommets ont des degrés distincts, alors il existe une bijection
{d(x):x∈V}←→ {0,1,..., n−1}
Donc, il existe un sommet uavec un degré 0, et un sommet vavec degré n−1, donc vest connecté à tous les autres
sommets du graphe, ce qui signifie que une peut pas être un sommet isolé, d’où une contradiction.6 Chapitre 1. Les graphes
1.1.2 Graphes orientés
Les arêtes d’un graphe peuvent être orientées, auquel cas une flèche indique la direction. De tels graphes sont
appelés des graphes orientés ou des digraphes , et une arête ( a,b) dans un tel graphe indique que cette arête est
dirigée de sommet avers b, i.e. ( a,b)=− →ab̸=(b,a)=− →ba. D’où la définition :
Définition 1.3: Graphe orienté - digraphe
Un graphe orienté G(ou− →G) est un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V2des pairs
ordonnées de V.Eest l’ensemble des arêtes (ou flèches, arcs) de G. Lorsque e=(x,y) est une arête, on dit
que xestl’origine (ou sommet initiale) et yl’extrémité (ou sommet terminale) de e, que eest sortant en x
et incident en y, et que yest un successeur de xtandis que xest un prédécesseur de y. On note l’arête e
par :
e=(x,y)=− →x y=x→y
De la même façon, une arête x→xest une boucle. On peut toujours supprimer les boucles pour obtenir des
digraphes simples. Voici l’exemple d’un digraphe G=(V,E) d’une fonction f:E→Eoù ( x,y) est un arc si et seule-
ment si y=f(x). On l’appelle digraphe fonctionnelle.
0
3
1214
11 568
169
4
2 1
713 10
15
FIGURE 1.3 – Le digraphe fonctionnelle Gfdex7→(x2+3) mod 17.
Comme dans les graphes on peut définir les degrés (entrant, sortant) d’un sommet dans un digraphe.
Définition 1.4: indegree - outdegree
Soit G=(V,E) un digraphe. Pour v∈V, on note par :
d+(v) le degré extérieur (sortant - outdegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité initiale.
d+(v)= |{v→ •}|
d−(v) le degré intérieur (entrant - indegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité finale.
d−(v)= |{• → v}|
On définit le degré : d(v)=d−(v)+d+(v).
Un sommet de degré entrant non nul et de degré sortant nul est appelé puits , tandis qu’un sommet de
degré entrant nul et de degré sortant non nul est appelé source ouracine .
Dans un graphe orienté, les voisins d’un sommet vsont soit des successeurs ou des prédécesseurs. On les notes
par :
Γ+(x)=Succ (x)={y∈V:x→y∈E} et Γ−(x)=Pr ed (x)={y∈V:y→x∈E}H. SABRI 7
Si le digraphe est simple (ni boucle ni arcs parallèles) on a :
d−(v)= |Γ−(v)|et d+(v)= |Γ+(v)|
Proposition 1.2
Soit Gun digraphe, alors :X
v∈Vd−(v)=X
v∈Vd+(v)= |E|
Preuve. On a
E=˙[
v∈V{• → v}=˙[
v∈V{v→ •}
=⇒ | E| =X
v∈V|{• → v}| =X
v∈V|{v→ •}| =⇒ | E| =X
v∈Vd−(v)=X
v∈Vd+(v)
1.2 Opérations et quelques types de graphes
Une opération sur les graphes permet de construire un nouveau graphe comme résultat de l’opération. Les
opérations courantes sur les graphes sont la suppression, la valuation, l’union, l’intersection et le produit cartésien.
Graphe valué
Tout d’abord, on peut vouloir attribuer des valeurs aux arcs ou arêtes pour tenir compte de contraintes : dis-
tance, coût ...
Définition 1.5: (di)graphe valué
Un (di)graphe valué G=(V,E,w) est un (di)graphe muni d’une application w:E→R. L ’application west
appelée application poids ou coût. On indique sur chaque arête son poids (ou son coût). On note w(x,y)
au lieu de w((x,y)). On convient (même que ceci n’a pas de sens!) que w(x,y)= +∞ si (x,y)∉E.
ab
c
d
ef53
43
3
335
81
FIGURE 1.4 – Un digraphe valué
/pythonPython code : -
Implémenter le digraphe valué précédent avec python. Indice – use chatGPT : how to build a weighted digraph with
python8 Chapitre 1. Les graphes
Sous graphes
Soit G=(V,E) un graphe (orienté ou non). Un sous graphe de Gest un graphe de la forme G′=(V′,E′) où
V′⊆V,E′⊆Etels que toute arête de E′a ses extrémités dans V′(ou encore G′est aussi un graphe). On a :
•Sous-graphe induit Un sous-graphe G′=(V′,E′) de G=(V,E) est appelé un sous-graphe induit deGsi :
∀x,y∈V′; (x,y)∈E′⇐⇒ (x,y)∈E
En d’autres termes, deux sommets de G′qui sont connectés dans G, sont également connectés dans G′.
•Sous-graphe couvrant Un sous-graphe couvrant G′deGcontient tous les sommets de G, i.e. V′=V.
•G−vSupprimer un sommet vd’un graphe Gconsiste à supprimer vet toutes ses arêtes incidentes. Le sous-
graphe obtenu de cette opération est noté G−v, i.e.
V′=V−{v} et E′=E−{(v,y): (v,y)∈E}
De manière similaire, une arête epeut être supprimée (resp. ajoutée) d’un graphe G, et le sous-graphe
résultant est représenté par G−e(resp. G+e). Notez que la suppression d’une arête ne retire pas de sommets
du graphe.
•G−V′=G[V′] On supprimer tous les sommets v∈V′du graphe Gavec les arêtes incidentes. Le sous-graphe
obtenu de cette opération est noté G[V′], i.e.
V(G[V′])=V−V′et E(G[V′])=E−{(v,y)∈E:v∈V′}
•Clique Une clique Cd’un graphe Gest un sous-ensemble des sommets de Gdont le sous-graphe induit G′=
(C,E′) est un graphe complet, en d’autres termes, deux sommets quelconques de la clique Csont toujours
adjacents.
•Stable Un stable – appelé aussi ensemble indépendant (independent set en anglais) est un ensemble de som-
mets deux à deux non adjacents. Donc le sous-graphe induit est sans arcs.
FIGURE 1.5 – L ’ensemble des sommets en bleu dans ce graphe est un stable maximal du graphe.
Note : -
Le problème décisionnel de la clique (c’est à dire existe t-il une clique de taille k) est NP-complet . De même la
recherche d’un stable de taille maximum dans un graphe est un problème NP-complet et difficile à approximer.
Exercice 1.2
Trouver un plus grand stable et une plus grande clique du graphe suivant :
8
4
62 7
3
1 5
Indice : vérifier le résultat avec networkx.find_cliques(G) et.maximum_independent_set(G) de python.H. SABRI 9
Opérations binaires
Union L ’union de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∪H=(VF,EF) dans lequel
VF=VG∪VH et EF=EG∪EH
Intersection L ’intersection de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∩H=(VF,EF)
dans lequel
VF=VG∩VH et EF=EG∩EH
1.3 Représentation d’un graphe
Il est important de savoir comment représenter les graphes au sein d’un ordinateur. Il ya plusieurs méthodes
selon la nature des traitements que l’on souhaite appliquer au graphe considéré.
1.3.1 Listes d’adjacences (ou de succession)
Soit Gun (di)graphe. On suppose que les sommets de Gsont numérotés de S1àSn. La représentation par listes
d’adjacence de Gconsiste en un tableau (ou des listes chainées) tel que la ligne i=1... ncorrespond au sommet Si
et comporte la liste des voisins/successeurs (ou des prédécesseurs) de ce sommet notée T[Si]. Les sommets dans
chaque liste d’adjacence sont généralement listés selon un ordre arbitraire.
1
2
345
FIGURE 1.6 – Un digraphe
La liste d’adjacence de digraphe 1.6 est donc :
1 2 3 4 5
2 3
3 4
4−
5 1 410 Chapitre 1. Les graphes
1.3.2 Matrices d’adjacence
Définition 1.6: Mat. Adjacence
Soit G=(V,E) un graphe (orienté) d’ordre n. On peut numéroter V={1,2,..., n}.La matrice d’adjacence
deGest la matrice carrée A=(ai j) d’ordre n, définie par :
ai j=(
1 si ( i j)∈E;
0 sinon.
Remarque 3.
1. Si le graphe G est non orienté et simple, alors la matrice A est symétrique avec des 0sur la diagonale. Pour un
digraphe simple, on a toujours des 0sur la diagonale, mais la matrice n’est pas symétrique en général.
2. Pour les multigraphes, il peut y avoir des termes diagonaux (pour les boucles) et s’il y a plusieurs arêtes de i à
j , le coefficient de la matrice a i jest le nombre d’arêtes de i à j .
3. Pour un (di)graphe valué G =(V,E,w), on pose :
ai j=(
w(i,j)si(i j)∈E ;
∞ sinon.
La matrice d’adjacence de la figure 1.4 est :

∞ 5∞ 4 3 ∞
∞ ∞ 3∞ 1∞
∞ ∞ ∞ ∞ ∞ 5
∞ ∞ 3∞ 3 3
∞ ∞ ∞ ∞ ∞ 8
∞ ∞ ∞ ∞ ∞ ∞

1.3.3 Matrice d’incidence
Définition 1.7: Mat. Incidence
Soit G=(V,E) un graphe (simple) d’ordre net de taille m. On pose V={v1,v2,..., vn} etE={e1,e2,..., em}.
La matrice d’incidence deGest la matrice de type n×m B=(bi j), définie par :
•Si G orienté
bi j=

1 si ej=vi→ • (i.e. viest l’extrémité initiale de ej) ;
−1 si ej= • → vi(i.e. viest l’extrémité terminale de ej) ;
0 sinon.
•Si G non-orienté
bi j=(
1 si viest une extrémité de ej;
0 sinon.
Exercice 1.3
1. Donner la matrice d’incidence du graphe 1.6.
2. Montrer le théorème 1.1 avec la matrice d’incidence.CHAPITRE 2
La connexité
Il est important de savoir si on peut suivre un chemin d’un sommet donné à un autre dans un graphe donné.
Cette propriété (de connexité) doit être maintenue dans différents types de réseaux.
2.1 Les chaînes et les cycles
Définition 2.1: (chaine – cycle) (chemin – circuit)
•Graphe non orienté
1. Une chaîne (walk ) reliant xày, notée µ(x,y), est définie par une suite finie d’arêtes consécutives,
reliant xày, ou encore une séquence de sommets (puisque non multigraphe)
µ(x,y)=<v0,v1,..., vk>
tels que v0=x,vk=yet (vi−1,vi)∈E(G) pour tout i=1... k. Six=yla chaîne est dite fermée .
Lalongueur du chaîne l(µ(x,y)) est le nombre d’arcs dans la chaîne, c’est-à-dire k.
2. Une chaîne élémentaire (a path ) si tous les sommets sont distincts. Une chaîne simple (a simple
walk, a trail ) est une chaîne ne passant pas deux fois par une même arête, c’est-à-dire dont toutes
les arêtes sont distinctes. Remarquer que : élémentaire =⇒ simple.
3. Un cycle v0v1...vnde longueur n≥3 est une chaîne simple fermée ( v0=vn) tel que les sommets
v0,v1,..., vn−1sont tous distincts. Un graphe sans cycle est dit acyclique .
•Graphe orienté
Dans un graphe orienté, on parlera de chemin au lieu de chaîne, et de circuit au lieu de cycle.
Example 2.1
abxcd xa est une chaîne simple et fermée (non cycle!) de longueur 6 (mais, c’est un graphe eulérien - voir
plus loin). Y a-t-il un cycle de longueur 3,4 ?
a b
x
c dÏ
Remarque 4.
1. On peut pivoter une chaine fermée (l’orienter de manière arbitraire) , i.e.
<v0,v1,v2,..., v0>=< vk,vk+1,..., v0,v1,..., vk>
1112 Chapitre 2. La connexité
2. Soient x ,y∈V . La distance de x à y est définie par :
d(x,y)=(
k si le plus court chemin/chaîne de x vers y est de longueur k
∞ sinon
On convient que d (x,x)=0.
3. Le diamètre du graphe la plus grande distance entre deux sommets.
L ’observation suivante, bien que très facile à prouver, sera utile.
Théorème 2.1
S’il existe une chaîne du sommet yau sommet zdans le graphe G, où y̸=z, alors il existe une chaîne élé-
mentaire ( path ) dans Gavec pour premier sommet yet pour dernier sommet z.
Preuve. Soit la chaine
W1=µ(y,z)=x0x1...xn; avec x0=yetxn=z.
Si les sommets x0,x1,..., xnsont tous distincts, alors W1est une chaîne élémentaire, et nous avons terminé. Sinon,
il existe xi=xj(i<j) et on écrit :
W2=x0x1...xixj+1...xn.
Alors, l(W2)<l(W1). Si W2ne contient aucun sommet répété, alors c’est la chaîne recherché. Sinon, par la même
procédure, il existe W3(y z−chaîne) tel que
l(W3)<l(W2)<l(W1).
Ce processus doit s’arrêter à un certain stade, car chaque chaîne est plus courte que la précédente et la longueur
ne peut jamais être inférieure à 1
1< ··· < l(Wk)< ··· < l(W3)<l(W2)<l(W1).
Ainsi, pour un certain k,Wkne peut pas être réduit en longueur. Donc, la chaîne Wkne contient aucun sommet
répété et est donc une y z−chaîne élémentaire (path).
Exercice 2.1
Dans le graphe suivant, construire un path à partir de la chaîne W=v2v3v4v5v6v4v2v8v1
v1
 v2
v3
v4
v5
v6
v7
 v8
 v9
Calculer d(v1,v7) et le diamètre de G.
/pythonpython : >>G = nx.Graph([(1, 2), (2, 3), (2, 4), ...]) >>nx.diameter(G)
Les cycles fournissent la caractérisation suivante pour les graphes bipartis .H. SABRI 13
Théorème 2.2
Un graphe est biparti si et seulement s’il ne contient aucun cycle de longueur impaire.
Preuve.
⇒On suppose que G=U˙∪Vest un graphe biparti. Soit W=< x1,x2,..., x2k+1,x1>un cycle de longueur im-
paire (2 k+1). Si x1∈U, alors
x1∈U=⇒ x2∈V=⇒ x3∈U=⇒ ··· =⇒ x2k+1∈U=⇒ x1∈V/exclamati⌢n-triangle
absurde, d’où le résultat.
⇐On suppose que Gest connexe (car l’union des composantes connexes bipartis est un graphe biparti). Soit
xun sommet de Get on pose :
U={y∈V(G):d(x,y) est paire} et V={z∈V(G):d(x,z) est impaire}
S’il existe y1,y2∈Utel que y1y2∈E(G), alors on a :
W1=<x,..., y1>est une chaîne de longueur paire =2k1
W2=<x,..., y2>est une chaîne de longueur paire =2k2
=⇒ W3=<x,..., y1,y2,..., x>est un cycle de longueur impaire =2k1+2k2+1/exclamati⌢n-triangle
Donc G=U˙∪Vest un graphe biparti.
Exercice 2.2
Vérifier si le graphe maison est un graphe biparti. Faire de même pour la grille G4,4.
maison grille
2.2 Graphe connexe, eulérien, hamiltonien
Définition 2.2: Graphe connexe
Un graphe est dit connexe si deux points peuvent toujours être joints par une chaîne, i.e.
∀x,y∈V(G),d(x,y)< ∞
— Une composante connexe d’un graphe est un sous-graphe induit maximal connexe.
— Un point d’articulation d’un graphe est un sommet dont la suppression augmente le nombre de
composantes connexes.
Par exemple, le graphe suivant :14 Chapitre 2. La connexité
a
 b
d
 c
e
f
 g
n’est pas connexe car il n’existe pas de chaîne entre les sommets aete. On a donc 2 composantes connexes. En
revanche, le sous-graphe induit par les sommets { a,b,c,d} est connexe dont aest le seul point d’articulation.
Remarque 5.
1. Un graphe connexe à n sommets possède au moins n −1arêtes ( faite une preuve par récurrence ).
2. L’algorithme de parcours en profondeur permet de déterminer si un graphe est connexe ou non.
3. Même définitions dans un graphe orienté . Graphe orienté (fortement) connexe et de composante connexe .
Définition 2.3: Graphe eulérien
— Une chaîne joignant deux sommets xetyest dite chaîne eulérienne si elle emprunte chaque arête
deGune et une seule fois. On parle de chemin eulérien dans le cas d’un graphe orienté.
— Un cycle eulérien est une chaîne eulérienne dont les extrémités coïncident. Un graphe qui admet
un cycle (resp. circuit) eulérien est dit graphe eulérien .
/flushedRemarquer qu’un cycle eulérien n’est pas forcément un cycle comme définit dans la définition 2.1
Si un graphe (ou multigraphe) Gpossède une chaîne eulérienne, alors soit Gpossède deux sommets impairs, le
début et la fin de cette chaîne, soit Gn’a aucun sommet impair, et la promenade d’Euler commence et se termine
au même point (cycle eulérien). Une autre condition nécessaire évidente est que Gdoit être connexe. Ces deux
conditions sont ensemble suffisantes.
Théorème 2.3 Euler
Soit Gun graphe (multigraphe) connexe.
— Si Gn’a pas de sommets impairs, alors il possède un cycle eulérien (commençant à n’importe quel
point).
i.e.∀x,d(x)≡0 mod 2 =⇒ Gest un graphe eulérien.
— Si Ga deux sommets impairs, alors il possède une chaîne eulérienne dont le début et la fin sont les
sommets impairs.
La réciproque est aussi vraie.
Preuve.
⇐On commence par la réciproque. S’il existe une chaîne eulérienne µ(x,y), alors on peut crée une arête fictive
e=(y,x) et par la suite on obtient un cycle eulérien. Donc il suffit de montrer que si Gadmet un cycle
eulérien alors tous les sommets sont de degré pair.
Soit W=< v1,v2,..., vn,v1>un cycle eulérien. Soit le sommet vjavec j̸=1, il est donc claire que chaque
fois vjapparaît dans W, il ya deux arcs distincts incidents en vj( (•,vj) et ( vj,•)). Comme toutes les arêtes
sont utilisées, on voit que d(vj) est pair. Même chose pour v1car on ajoute deux arcs ( v1,v2) et ( v1,vn).
⇒On suppose que tous les sommets sont de degré pair. Montrons que Gadmet un cycle eulérien. Puisque
tous les sommets sont de degré pair on peut construire d’abord une chaîne simple fermée (quelconque)
W1=<v1,v2,..., vk,v1>
SiW1contient chaque arête de G, alors c’est finis, c’est un cycle eulérien. Sinon (puisque Gest connexe), il
existe une arête e=(vi,c) qui n’est pas dans W1(avec visommet de W1). On pose le sous-graphe
G′=G−{ arêtes de W1}H. SABRI 15
Il est donc claire que les sommets de G′sont aussi de degré pair. Alors, par la même procédure on construit
une chaîne simple fermée dans G′de la forme : <vi,c,d,..., vi>et par la suite on insère cette chaîne dans
W1pour obtenir :
W2=<v1,v2,..., vi,c,d,..., vi,vi+1,..., vk,v1>
Sil(W2)< |E(G)|, on construit W3de longueur plus grand. Ainsi, on a :
l(W1)<l(W2)<l(W3)< ··· ≤ | E(G)|
Donc, nécessairement, il existe Wk(chaîne simple fermée de longueur |E(G)|) donc c’est un cycle eulérien.
Finalement , si∃a,b∈V(G):d(a)≡d(b)≡1 mod 2, et tous les autres sommets sont de degré pair, alors on
pose :
G′=G+{a,b}
et donc tous les sommets de G′sont de degré pair. Avec la construction précédente, il existe un cycle eulérien
dans G′:
W=<a,b,v1,..., a>
est donc la chaîne <b,v2,..., a>est une chaîne eulérienne dans G.
Algorithme 1 : Euler
Entrées : Gun graphe eulérien
Output : Un cycle eulérien W
/* On suppose que G est eulérien, i.e. les sommets sont de degré pair */
1Gaux←G;W←µ(v,v) une chaîne simple (quelconque) de G; // Initialisation
2tant que l(W)<e(G)faire
3 Gaux←G−{ arêtes de W} ;
4 Choisir ( x,c)∈E(Gaux) tel que x∈W;
5 L←< x,c,..., x>une chaîne simple de Gaux ;
6 Dans W, remplacer (juste ce) xpar la séquence L;
7fin
8retourner W;
Exercice 2.3
1. Montrer que le graphe de l’exercice 2.1 est un graphe eulérien et donner un cycle eulérien.
2. Tracer cette maison d’un seul trait.
Remarque 6. Le théorème d’Euler dans un graphe orienté connexe s’écrit :
Admet un circuit eulérien si, et seulement si, pour tout sommet, le degré entrant est égal au degré sortant.
∀v∈V(G),d+(v)=d−(v)
Admet un chemin eulérien de a vers b si, et seulement si,


d+(v)=d−(v) ;∀v̸=a,b,
d−(a)=d+(a)−1
d−(b)=d+(b)+116 Chapitre 2. La connexité
Définition 2.4: Graphe hamiltonien
Soit Gun graphe connexe d’ordre n. On appelle :
1. On appelle cycle hamiltonien deGun cycle passant (une et une seule fois) par chacun des sommets
deG. Un graphe est dit hamiltonien s’il possède un cycle hamiltonien.
2. Une chaîne hamiltonienne est une chaîne passant une et une seule fois par chacun des sommets de
G. Un graphe ne possédant que des chaînes hamiltoniennes est semi-hamiltonien .
3. Dans un digraphe, on change cycle par circuit et chaîne par chemin .
Remarque 7.
— Une chaîne hamiltonienne est une chaîne élémentaire de longueur n −1.
— Un graphe peut être eulérien, hamiltonien, les deux à la fois, ou aucun des deux.
— De nombreux problèmes concrets peuvent être formulés en termes de recherche de parcours hamiltoniens : pro-
blème du voyageur de commerce (chercher un cycle hamiltonien de longueur totale minimale), l’ ordonancement
de tâches .
— Le problème du chaîne hamiltonienne est un problème NP-complet .
Exercice 2.4
Donner un graphe (connexe, simple) qui soit :
1. hamiltonien et eulérien.
2. hamiltonien et non eulérien.
3. eulérien et non hamiltonien.
4. non hamiltonien et non eulérien.
Aucune condition nécessaire et suffisante adéquate n’est connue pour l’existence de cycles hamiltoniens. Le
résultat suivant constitue une condition suffisante utile.
Théorème 2.4 Ore
Soit Gun graphe simple d’ordre n≥3. Si pour toute paire { x,y} de sommets non adjacents, on a d(x)+d(y)≥
n, alors Gest hamiltonien.
Preuve. On suppose que le théorème est faux. Alors, il existe un graphe Gsimple d’ordre nnon hamiltonien tel que
d(u)+d(v)≥npour tout sommets non adjacents uetv. On prend Gun tel graphe d’ordre nde taille maximale qui
vérifie cette propriété (remarquer que le graphe complet Knest hamiltonien).
Soient uetvdeux sommets non adjacents de G. Par maximalité de G, le graphe G+uv(d’ordre n) doit être
hamiltonien. Donc il existe dans G+uvun cycle hamiltonien :
W=<u,x1,x2,..., xn−2,v,u>
u
x1
xi xi+1xn−2
v
... ...
Or, si uxi+1∈E(G) etv xi∈E(G) (les arcs en rouge), alors on peut construire dans Gle cycle hamiltonien :
<u,x1,x2,..., xi,v,xn−2,..., xi+1,u>H. SABRI 17
Ceci est absurde car Gest non hamiltonien. Donc si xi+1est un sommet voisin à u, alors le sommet xin’est pas
voisin de v:
xi+1∈Γ(u)=⇒ xi∉Γ(v)
Donc :
d(u)= |Γ(u)| =p=⇒ d(v)≤(n−1)−p
et par la suite
d(u)+d(v)≤n−1
ce qui absurde par hypothèse. Donc Gest hamiltonien.
Une conséquence immédiate est le théorème de Dirac :
Proposition 2.1 Dirac
Soit Gun graphe simple d’ordre n≥3. Si pour tout sommet xdeG, on a d(x)≥n
2, alors Gest hamiltonien.
2.3 Arbres
Définition 2.5: Arbres et forêts
On appelle arbre tout graphe (non orienté) connexe et acyclique . Les composantes connexes dans un
graphe acyclique sont des arbres et le graphe est dit forêt . Une feuille ou sommet pendant est un som-
met de degré 1.
Un forêt avec deux arbres
Un graphe Gest une arborescence s’il existe un sommet Rappelé racine deGtel que, pour tout sommet
SdeG, il existe un chemin et un seul de Rvers S. Donc, c’est un arbre orienté dans lequel on choisit un
sommet Rcomme racine et on dirige les arcs vers le sens sortant de la racine.
Remarque 8.
— Un graphe G d’ordre n est un arbre ssi G est sans cycle et possède n −1arêtes.
— Un graphe G d’ordre n est un arbre ssi G est connexe et possède n −1arêtes.
— G est un arbre si pour chaque paire u ,v de sommets distincts est reliée par une seule chaîne (donc chaîne
élémentaire d’après le théorème 2.1).
— Un arbre (ou forêt) est nécessairement un graphe simple.
Pour démontrer les remarques précédentes, il suffit de prouver le théorème suivant :
Théorème 2.5
Soit Gun graphe ayant marêtes, nsommets et pcomposantes connexes, on définit nu( G) :
ν(G)=m−n+p
Alors, on a :
1.ν(G)≥0.
2.ν(G)=0⇐⇒ Gest acyclique.18 Chapitre 2. La connexité
Preuve. Par récurrence sur la taille mdu graphe. Le résultat est évident pour m=0 et m=1. On suppose le résultat
est vrai pour les graphe de taille m, et montrons que ceci est vrai pour un graphe de taille m+1. Soit donc Gun
graphe d’ordre nde taille m+1 ayant pcomposantes connexes.
•On suppose que Gest un graphe acyclique. Soit uvune arête de Gdans la composante C. Si on supprime uv,
la composante Cse transforme en deux composantes connexes (sinon on a un cycle dans G). Par la suite,
le graphe G′=G−uvest un graphe acyclique d’ordre n, de taille met ayant p+1 composantes connexes.
Donc d’après l’hypothèse de récurrence :
ν(G′)=0=(m−1)−n+(p+1)=m−n+p=ν(G)
•Maintenant, si Gcontient un cycle Wdans la composante connexe C. Soit uvune arête de W, alors si on
supprime l’arête uv, la composante Creste connexe. Donc le graphe G′=G−uvest un graphe d’ordre nde
taille m−1 ayant pcomposantes connexes. Donc, d’après l’hypothèse de récurrence :
ν(G′)=(m−1)−n−p≥0
=⇒ν(G)=m−n−p≥1>0
D’où le résultat – car si ν(G)=0,Gne peut être que acyclique, sinon 0 =ν(G)≥1/exclamati⌢n-triangle
2.3.1 Codage et décodage d’un arbre – Prüfer code
Soit Tun arbre ayant nsommet numérotés {1,2,..., n}. Le codage de Prüfer représente l’arbre Tarbre de avec
une suite P=(x1,x2,x3,..., xn−2) de n−2 termes (les n° des sommets avec répétition possible). Une suite Pdonnée
correspond à un et un seul arbre numéroté. Voici les algorithmes de codage et de décodage.
Algorithme 2 : Codage de Prüfer
Entrées : Un arbre T
Output : Séquence de Prüfer P
1P←() ; // Initialisation de P comme séquence vide
2tant que v(T)>2faire
3 x←feuille de Tayant le n° minimum ; // donc d(x)=1
4 P←(P,s) où sest le seul (n°) sommet adjacent à x;
5 T←T−x;
6fin
7retourner P;
Example 2.2
Donner le code de Prüfer de l’arbre :
126 345
Indice : on trouve, P=(2,3,3,2)
Pour faire la réciproque, étant donnée une séquence P=(x1,x2,..., xn−2) où les xi∈{1,2,..., n}, on construit
l’arbre Tdont les sommets sont {1,2,..., n} avec l’algorithme suivant (le décodage) :H. SABRI 19
Algorithme 3 : Décodage de Prüfer
Entrées : Une séquence Pde taille n−2
Output : L ’arbre Tcorrespondante
1I←{1,2,..., n};
2T←graphe tel que V(T)=IetE(T)= ; ; // T graphe à n sommets isolés
3tant que P̸=()faire
4 i←min {x∈I:x∉P};
5 T←T+(i,P[1]) ; // ajouter l'arc (i,P[1])
6 P←P−P[1];I←I−{i};
7fin
8T←T+(a,b) ; // a,b sont les deux éléments restant dans I
9retourner T;
Example 2.3
Donner l’arbre dont le code de Prüfer est : P=(2,3,3,3)
Puisqu’il ya une bijection entre les arbres d’ordre net les suites Pde longueur n−2 à coefficients dans {1,2,..., n},
on déduit le théorème de Cayley :
Théorème 2.6 Formule de Cayley
Le nombre d’arbres que l’on peut construire sur n(n≥2) sommets numérotés est égal à nn−2.
2.3.2 Arbre couvrant de poids minimum – ACM
Soit Gun graphe (non orienté). Un arbre couvrant (spanning tree) TdeGest un sous graphe couvrant de G
tel que Test un arbre. Remarquer que, Gdoit être connexe, sinon un arbre couvrant de Gn’existe pas. Le nombre
des arbres couvrant de Gest noté a(G). Remarquer que a(Kn)=nn−2(le nombre de Cayley). Un problème algo-
rithmique classique est de trouver, dans un graphe valué , un arbre couvrant de poids minimal . On dispose de
plusieurs algorithmes (l’algorithme de Prim, l’algorithme de Kruskal ...).
Algorithme 4 : Kruskal
Entrées : Un graphe Gvalué d’ordre net de taille m
Output : Arbre (ou forêt) couvrant de poids minimum
1Numéroter les arêtes de Gpar poids minimum : w(e1)≤w(e2)≤ ··· ≤ w(em)
2T←graphe tel que V(T)=V(G) etE(T)= ; ; // T graphe à n sommets isolés
3k←0;
4tant que k<m et e (T)<n−1faire
5 siT+ek+1est acyclique alors
6 T←T+ek+1;
7 k←k+1;
8fin
9retourner T;
Appliquer l’algorithme de Kruskal dans le graphe suivant :
CHAPITRE 3
Les algorithmes de base
Beaucoup de problèmes sur les graphes nécessitent que l’on parcourt l’ensemble des sommets et des arcs. Par
exemple, pour vérifier que le graphe est connexe, chercher un sommet particulier, construire un arbre couvrant,
trouver un plus court chemin ...etc.
3.1 Parcours en profondeur (DFS) / largeur (BFS)
Une manière simple de tester si un graphe Gest connexe ou non est d’exécuter l’algorithme DFS ouBFS dans
Gen commençant par n’importe quel sommet et en enregistrant les sommets visités pendant l’exécution dans une
liste. Si la liste contient tous les sommets de G, alors Gest connexe. Une petite modification permet de donner les
composantes connexes de G. L ’algorithme DFS_Component suivant donne les composantes connexes de G. Il est
donné sous forme d’implémentation récursive.
Algorithme 5 : DFS_Component
Entrées : Un graphe G=(V,E)
Output : Les composantes connexes C=(C1,C2,..., Ck) de G.
1VisitedNodes ← ; ;
2k←0 ; // k est le nombre des composantes connexes
3pour chaque u∈Vfaire
4 siu∉VisitedNodes alors
5 k←k+1;
6 DFS( u);
7 fin
8fin
9retourner (C1,C2,..., Ck);
1Procedure DFS( u )
2 VisitedNodes ←VisitedNodes ∪{u};
3 Ck←Ck∪{u};
4 pour chaque x∈Γ(u)faire
5 six∉VisitedNodes alors
6 DFS( x);
7 fin
8 fin
Note : -
Il est possible de d’implémenter la procédure DFS itérativement à l’aide d’une pile LIFO (stack) contenant les
sommets à explorer : on désempile un sommet et on empile ses voisins non encore explorés.
20H. SABRI 21
Pseudocode :
stack . push ( root )
while stack . isEmpty ( ) = f a l s e do
node = stack . pop ( ) // so mark i t as v i s i t e d
for each x in node . childNodes do
i f x i s not v i s i t e d then
stack . push ( x )
. . .
endfor
endwhile
Example 3.1 (DFS )
Ici on empile (gris) les sommets les plus à droite, alors l’ordre des sommets visité (noir) est ( a,b,d,e,g,c,f).
Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b
 c
d
 e
f
g
a
b
 c
d e
f
ga
b
 c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g
L ’utilisation d’une file (FIFO) au lieu d’une pile transforme l’algorithme du parcours en profondeur en algo-
rithme de parcours en largeur ( BFS ). Avec BFS l’exemple précédent devient (en enfile le plus à gauche) :
Example 3.2 (BFS )
Ici, avec BFS, on enfile (gris) les sommets les plus à gauche d’abord, alors l’ordre des sommets visité (noir)
est ( a,b,d,e,g,c,f). Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b c
d
 e
f
g
a
b c
d
 e
f
ga
b c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g22 Chapitre 3. Les algorithmes de base
Exercice 3.1
1. Écrire la procédure BFS .
2. Utiliser DFS (ou BFS) pour la construction d’un arbre couvrant d’un graphe connexe. L ’appliquer
pour le graphe triangle.
3. Utiliser DFS pour écrire une procédure DFS_Cycle pour détecter un cycle dans un graphe.
On sait qu’un graphe orienté G=(V,E) est fortement connexe si pour chaque paire de sommets u,v∈V, il
existe un chemin de uàvet il existe un chemin de vàu. En d’autres termes, nous avons besoin d’une connectivité
dans les deux directions .
Une procédure pour tester si un graphe orienté est fortement connexe ou non peut être conçue avec l’idée
suivante. En partant d’un sommet arbitraire vdu graphe G, on exécute l’algorithme BFS ouDFS et l’on note les
sommets visités. Ensuite, on obtient la transposée de G,GT, en inversant la direction des arêtes de G, et l’on
exécute à nouveau l’algorithme BFS ou DFS à partir du sommet v. Si les sommets visités dans les deux cas sont
égaux à V, alors le graphe orienté est fortement connexe. Cette méthode est illustrée dans l’algorithme 6.
Algorithme 6 : Fortement_connexe
Entrées : Un graphe orienté G=(V,E)
Output : true siGest fortement connexe et false sinon
1X← ; ;
2Y← ; ;
3v←un sommet quelconque de V;
4X←DFS( G,v) ; // Enregistrez les sommets visités dans X
5GT←Gavec flèches inversées;
6Y←DFS( GT,v);
7siX=Y=Valors
8 retourner TRUE.
9sinon
10 retourner FALSE.
11fin
3.2 Recherche des chemins
3.2.1 Matrice d’adjacence et nombre de chemins
La puissance de la matrice d’adjacence Amontre qu’il y a des chemins (ou chaînes) de longueur kallant de xà
ycomme le montre le théorème suivant.
Théorème 3.1
Soit G=(V,E) un (di)graphe. On note V={1,2,..., n} et Asa matrice d’adjacence et Akla puissance k-ème
deA. Alors le terme d’indices i,jdeAkest le nombre de chemins (chaînes) de longueur kallant de iàj.
Preuve. Par récurrence sur k. Pour k=1 c’est clair. On suppose le résultat est vrai à l’ordre ket montrons qu’elle
est vrai pour k+1. Soit S=(si,j)=Ak. Si on a un chemin de iàjde longueur k+1, alors on va d’abord de ià un
sommet ravec kpas et puis de ràj. Or d’après l’hypothèse de récurrence on a si,rchemins possibles pour aller de
iàret finalement ar,jpas (1 ou 0) pour aller de ràj. Ainsi, le nombre totale possibles (i.e. tous les sommets r) est :
nX
r=1si,rar,j=³
Ak×A´
i,jH. SABRI 23
ce qui est bien le terme ( i,j) de la matrice Ak+1.
3.2.2 Plus court chemin et l’algorithme de Dijkstra
Dans cette partie on suppose que le (di)graphe G=(V,E,w) est valué positivement (i.e.∀e∈E,w(e)>0). Notre
objectif est de chercher un plus court chemin (i.e., un chemin de poids minimal ) d’un sommet ufixé à un sommet
quelconque de G.
Il est clair que l’on peut restreindre ce problème au cas d’un (di)graphe simple1. On suppose aussi que Gest
connexe (sinon, certains trajets sont impossibles). Il est aussi claire (d’après théorème 2.1), qu’un plus court chemin
est nécessairement un chemin élémentaire (path).
L ’algorithme de Dijkstra (1959) permet de calculer le plus court chemin entre un sommet particulier u(racine )
et tous les autres sommets. L ’algorithme fonctionne de la manière suivante :
Pour tout sommet vdeG, on associe une valeur T(v), initialisée à w(u,v) et une liste de sommets C(v) qui
correspond à un chemin de uàv. À la fin de l’algorithme, T(v) contient le poids minimal des chemins joignant uà
v(ou T(v)= ∞ siu↛v) et la liste C(v) réalise un tel chemin. Voici donc l’algorithme de Dijkstra :
Algorithme 7 : Algorithme de Dijkstra
Entrées : Un (di)graphe valué G=(V,E,w) et un sommet racine u
Output : Le coût minimum d’un chemin de uàv(∀v∈V) et un trajet pour chaque coût minimal obtenu
1∀v∈V,T(v)←w(u,v) etC(v)←(u,v); // Initialisation de T(v) et la liste C(v)
2X←{u};
3tant que X̸=Vfaire
4 Choisir v∈V−Xtel que ∀y∈V−X,T(v)≤T(y);
5 X←X∪{v};
6 pour chaque y∈V−Xfaire // Faire les mises à jours pour les autres sommets
7 siT(y)>T(v)+w(v,y)alors
8 T(y)←T(v)+w(v,y);
9 C(y)←[C(v),y]; // On ajoute à la liste C(v) l'élément y
10
11 fin
12 fin
13fin
Example 3.3
Voici une application de l’algorithme de Dijkstra au digraphe suivant. On prend Ecomme sommet racine.
EA
B
CD
FG
S5
4
21
12
2
34
4
215
7
1. En effet, passer par une boucle ne ferait qu’augmenter inutilement le poids de ce chemin. De même, si plusieurs arcs joignent deux
sommets, il suffit de conserver l’arc de poids minimal.24 Chapitre 3. Les algorithmes de base
Ainsi, pour l’initialisation, on a : X={E} et on a les valeurs :
v  E A B C D F G S
T(v) 0 5 4 2 ∞ ∞ ∞ ∞
C(v)(E,E) ( E,A) ( E,B) ( E,C) ( E,D) ( E,F) ( E,G) ( E,S)
Maintenant, on choisit (un seul choix) le sommet C, donc X={E,C}. Le tableau est mis à jour :
v  E A B  C D F G S
T(v) 0 5 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À l’étape suivante, on est forcé de choisir B. Ainsi, X={E,C,B} et la mise à jour est :
v  E A  B  C D F G S
T(v) 0 4 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À présent, on a le choix entre AetF. On choisit A. Donc X={E,C,B,A} et on a :
v  E  A  B  C D F G S
T(v) 0 4 3 2 6 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,B,A,D) ( E,C,F) ( E,C,G) ( E,S)
Puis, on prend le sommet F. D’où X={E,C,B,A,F} et :
v  E  A  B  C D  F G S
T(v) 0 4 3 2 5 4 5 11
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,S)
On prend Det on obtient X={E,C,B,A,F,D} et :
v  E  A  B  C  D  F G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Finalement, on prend Gpuis Set on voit que ceci ne change rien. D’où le tableau finale :
v  E  A  B  C  D  F  G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Ainsi le chemin minimum pour aller de EàSest de coût 10 et un trajet de coût minimal de EàSest : EC F DS .H. SABRI 25
3.3 Problèmes d’ordonnancement et chemin critique
Un problème d’ordonnancement peut-être représenté sous la forme d’un digraphe. Les sommets sont des évé-
nements (début et fin de la tâche) et les arcs des tâches, La longueur (ou poids) de chaque arc représente la durée
d’exécution de la tâche. Ainsi, la tâche correspondant à l’arc ( i,j) ne peut commencer que si toutes les tâches cor-
respondant à des arcs ( k,i) ont été complétées. On ajoute deux sommets pour le début (s) et de fin(t) du projet .
Le digraphe peut contenir des tâches fictives dedurée nulle afin de forcer certaines précédences (postériorité).
Ainsi, un réseau PERT est un digraphe valué G=(V,E,w,s,t) où la fonction poids (ou longueur) w:E→R+
etsle sommet source (début) et tle sommet puits (fin). Un chemin critique est un chemin de sàtdelongueur
maximale . S’il n’existe pas de chemin critique, le projet n’est pas réalisable (e.g. un circuit). Le temps minimal
requis pour l’exécution d’un projet réalisable est égal à la longueur d’un chemin critique. Les tâches figurant sur un
chemin critique sont aussi appelées critiques, ce qui s’explique par le fait que tout retard d’exécution d’une tâche
critique retarde d’autant l’exécution du projet.
3.3.1 Algorithmes de tri topologique et de chemin critique
Il faut d’abord numérotés les sommets de 1 à nde manière compatible au pré-ordre (rang) avec l’algorithme du
rang suivant (tri topologique) :
Algorithme 8 : Algorithme du rang
Entrées : Un digraphe G=(V,E) sans circuit
Output : Le rang r(v) de chaque sommet v∈Vde G
1r←0;X←V;
2R←{v∈X:Γ−
X(v)= ;} ; // l'ensemble des sommets de X sans prédécesseur dans X
3tant que X̸= ; faire
4 r(v)←rpour chaque sommet v∈R;
5 X←X−R;
6 R←l’ensemble des sommets de Xsans prédécesseur dans X;
7 r←r+1;
8fin
On supposera dorénavant que les sommets ont déjà été numérotés de 1 à nde manière compatible avec leurs
rangs, c’est-à-dire que r(j)>r(i) implique j>i(donc 1 =setn=t). Enfin, on supposera éliminés les arcs paral-
lèles par l’introduction de tâches fictives de durée nulle .
Pour un sommet i, on note tiledébut au plus tôt des tâches correspondant aux arcs i→jet par Tilafin au
plus tard des tâches correspondant aux arcs j→i.
Algorithme 9 : Algorithme du chemin critique
Entrées : Un digraphe G=(V,E) sans circuit trié topologiquement
Output : La durée du chemin critique et les dates ti,Ti
1t1←0;
2pour j=2···nfaire // Calcul des dates de début au plus tôt  récurrence en avançant
3 tj←max i∈Γ−(j){ti+w(i,j)}
4fin
5Tn←tn;
6pour j=n−1···1faire // Calcul des dates de fin au plus tard  récurrence en reculant
7 Tj←min i∈Γ+(j){Ti−w(j,i)}
8fin26 Chapitre 3. Les algorithmes de base
Définition 3.1
— Un sommet iest critique si ti=Ti.
— Un arc ( i,j) est critique les sommets ietjsont critiques ettj−ti=w(i,j).
— Un chemin critique est un chemin de 1 à nn’utilisant que des arcs critiques.
— La durée du chemin critique est donnée par Tn(ou par tn). Elle correspond à la durée minimale du
projet .
Example 3.4
L ’application de l’algorithme du chemin critique au digraphe suivant (trié topologiquement) est :
1 23
45
6B
9A
3
C
5D
8
E
4
F7G
20
H6I5
=⇒
 1
0,02
9,933,16
4
16,23513,24
6
29,29B
9A
3
C
5D
8
E
4
F7G
20
H6I5
Les tâches critiques sont BetG. La durée totale minimale du projet est donc 29.
Exercice 3.2
Les tâches ( durée et précédences ) pour la construction d’un entrepôt sont données dans le tableau suivant :
Tâches Nature Précédences Durée (jours)
A Acceptation des plans par le propriétaire – 4
B Préparation du terrain – 2
C Commande des matériaux A 1
D Creusage des fondations A, B 1
E Commande des portes et fenêtres A 2
F Livraison des matériaux C 2
G Coulage des fondations D, F 2
H Livraison des portes et fenêtres E 10
I Pose des murs, de la charpente et du toit G 4
J Mise en place des portes et fenêtres H, I 1
1. Représentez le graphe des précédences de ce projet (trié topologiquement).
2. Déterminez une durée totale minimale en exhibant un chemin critique dans ce graphe.CHAPITRE 4
Programmation linéaire
La programmation linéaire est le processus de minimiser ou maximiser une fonction objective linéaire sou-
mise à un nombre fini de contraintes d’égalités et d’inégalités linéaires.
La programmation linéaire a de nombreuses applications dans le domaine de l’informatique théorique. Elle
peut être utilisée pour résoudre de nombreux problèmes combinatoires variés, tels que la recherche de flot maxi-
mum dans un réseau, la recherche d’un couplage maximal dans un graphe et la coloration d’un graphe parfait.
Example 4.1 (Problème de régime)
On suppose qu’on a quatre plats : de la truite ( XT), un sandwich au corned-beef ( XC B), un burrito ( XBU R )
et un hamburger ( XHB). Le tableau suivant répertorie la valeur nutritionnelle de chaque plat (vitamines et
calories) et notre besoin journalier des vitamines.
Vit. A Vit. C Vit. D Calories
Truite 203 92 100 600
Corned-beef 90 84 230 350
Burrito 270 80 512 250
Humburger 500 90 210 500
Besoins 2000 300 430
Notre objectif est de minimiser le nombre total de calories consommées : 600 XT+350XC B+250XBU R+
500XHBtout en satisfaisant les trois besoins nutritionnels en vitamines. Le programme linéaire résultant
s’écrit :
min 600 XT+350XC B+250XBU R+500XHB
s.t. 203 XT+90XC B+270XBU R+500XHB≥2000, (Besoins de Vit. A),
92XT+84XC B+80XBU R+90XHB≥300, (Besoins de Vit. C),
100XT+230XC B+512XBU R+210XHB≥430, (Besoins de Vit. D),
XT,XC B,XBU R ,XHB≥0
Définition 4.1: Forme canonique – Forme standard
On peut écrire un P .L. sous deux formes spéciales :
•Canonique
max
mincTX+c0
s.t. AX≤b(≥bsi min),
X≥0•Standard
max cTX+c0
s.t. AX=b,
X≥0Avec :
cTX=¡
c1··· cn¢
x1
...
xn

cTX+c0=c1x1+c2x2+···+ cnxn+c0
2728 Chapitre 4. Programmation linéaire
Remarque 9. Un P .L. général peut être formulé selon une forme standard ou canonique par la méthode suivante :
générale =⇒ standard il faut éliminer les contraintes d’inégalité et les variables sans contrainte de positivité.
— Si dT
iX≤biest une contrainte d’inégalité, alors créer une nouvelle variable ( d’écart ) siet remplacer l’in-
égalité dT
iX≤bipar dT
iX+si=biet s i≥0.
Si dT
iX≥bi, alors on peut écrire dT
iX−si=biet s i≥0.
— Si une variable x i≶0est de signe quelconque, alors créez deux nouvelles variables x+
iet x−
iet remplacez
xipartout par x+
i−x−
i, et ajoutez les contraintes de signe : x+
i≥0,x−
i≥0.
générale =⇒ canonique
— Si dT
iX=biest une contrainte d’égalité, alors remplacer cette égalité par une paire d’inégalités :
dT
iX≥biet−dT
iX≥ −bi
— Même chose que précédemment si la variable x i≶0.
Il est facile de voir que les problèmes qui en résultent sont équivalents aux problème d’origine. Pour l’algorithme
simplexe , nous utiliserons la forme standard .
On remarque aussi qu’en utilisant la relation min f(x)= − max¡
−f(x)¢
dans laquelle f (x)représente la fonction-
nelle linéaire à optimiser, on peut toujours se ramener à un problème de minimisation (ou de maximisation).
Example 4.2
Le P .L :max 5 x+4y
s.t. x≤6
1
4x+y≤6
3x+2y≤22
x,y≥0s’écrit sous forme standard :max 5 x1+4x2
s.t. x1+e1=6
1
4x1+x2+e2=6
3x1+2x2+e3=22
x1,x2,e1,e2,e3≥0
Donc (sous la forme matricielle) on a :
cT=¡
5 4 0 0 0¢
;A=
1 0 1 0 0
1
41 0 1 0
3 2 0 0 1
;X=
x1
x2
e1
e2
e3
et b=
6
6
22

4.1 La méthode simplexe
4.1.1 Solution de base admissible
On suppose que la matrice Adu programme linéaire est de type m×netde rang m(pourquoi !). Soit Bla
matrice carrée extraite de Aformée par les mcolonnes j1,j2,..., jmlinéairement indépendants de A(les vecteurs
de base). Alors, Best une matrice inversible. Ainsi si on pose xl=0 sil∉{j1,..., jm} etxjklak-ième composante de
B−1b. Alors, on a AX B=b. Si de plus XB≥0(i.e. chaque xi≥0), alors :
Xest une solution de base admissible (ou réalisable)
Dans l’exemple 4.2, la matrice extraite B=
1 0 0
0 1 0
0 0 1
est inversible et B−1b=
6
6
22
. Donc XB=
0
0
6
6
22
≥0, par suite
XBest une solution de base admissible. On appelle les variables xjklesvariables de base . Les autres variables xl
sont les variables hors-base .
Parfois, il n’est pas évident de trouver une solution de base admissible, comme le montre l’exercice suivant :H. SABRI 29
Exercice 4.1
Écrire le programme linéaire suivant sous forme standard et montrer qu’on n’a pas une solution de base
admissible. Résoudre le programme linéaire.
max −x+y
s.t. x+y≥1,
3x+2y=6,
x,y≥0
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux
Dans cette section, on suppose qu’on a déjà trouvé une solution de base admissible X(produite avec B=Im)
du programme linéaire ( P: max z=cTX+c0etb≥0pour garantir que 0est une solution de AX≤b).
La méthode du simplexe est une méthode itérative qui génère une séquence de solutions de base réalisable
(correspondant à différentes bases) et s’arrête finalement lorsqu’elle a trouvé une solution de base réalisable opti-
male. Remarquer qu’on peut toujours prendre c0=0.
Algorithme 10 : Algorithme du simplexe
Entrées : Un P .L. standard P(max) avec une solution de base réalisable
Output : La solution optimale (ou non)
1On commence à écrire le tableau initiale (avec les variables de base xj1,..., xjm)
VB x1 ... xn b
xj1 b1
... A...
xjm bm
c1 ... cn−c0
2Sicj≤0 (∀j:xjest hors base), alors solution optimale (STOP) // min ⇝cj≥0
3Trouver la colonne s(hors base) tel que cs=max©
cj:cj>0ª// min ⇝cs=min©
cj:cj<0ª
4Siai,s≤0∀i=1... m, alors pas de solution optimale (STOP)
5Min Ratio Test : trouver la ligne rtel que
br
ar,s=min
i=1...m½bi
ai,s:ai,s>0¾
6Appliquer la procédure de Gauss autour de pivot ar,s(ar,s⇝1 et on annule les coefficients situés sous et
sur le pivot dans la colonne s, par combinaisons de lignes) // Ne pas oublier la dernière ligne
7Remplacer (dans VB) la variable de base ( sortante ) située à la ligne rpar la variable ( entrante )xs
8Retourner à l’étape 2 // l'algorithme termine si le programme linéaire est non dégénéré
Remarque 10.
— La dernière ligne représente l’équation linéaire −z+c1x1+···+ cnxn= −c0.
— La valeur de la variable de base de V Bde la ligne k est égale à la valeur b k(de la ligne k).
— La solution optimale du problème est la valeur finale (dernière cellule) (×− 1).
— Si on n’a pas au départ B =Im(à l’aide des variables d’écart) alors, on ajoute les variables artificielles (et on
applique d’abord la phase I - voir section suivante).30 Chapitre 4. Programmation linéaire
Exercice 4.2
Soit le programme linéaire :
max 2 x1+x2
s.t. x1−x2≤3,
x1+2x2≤6,
−x1+2x2≤2,
x1,x2≥0
Rajouter les variables d’écart. Puis résoudre le problème par l’algorithme du simplexe.
Remarque 11. Vérifier le résultat de l’exercice précédent, par la méthode graphique.
4.1.3 Initialisation - Phase I du simplexe
Un programme linéaire est dit sous forme simpliciale si la matrice Acontient la matrice identité Imcomme
sous matrice. On suppose que le programme linéaire P, après la mise en forme AX=b, n’est pas simpliciale
(possible dans le cas de contraintes du type ≥ou du type =). Soit Bune matrice d’ordre mextraite de Ainversible
tel que B−1b≥0et soit XBla solution de base réalisable ( XB≥0etAX B=b), alors on peut changer l’équation
matricielle :
AX B=b
⇐⇒ (B−1A)XB=B−1b
⇐⇒ A∗XB=b∗
et la matrice A∗contient la matrice identité Imcomme matrice extraite ( B−1A=B−1(H|B)=¡
B−1H|Im¢
). Ainsi, on
peut appliquer directement l’algorithme 10 en remplaçant Apar A∗etbpar b∗. Cependant, cette méthode n’est
pas efficace, car il faut trouver une matrice extraite Bréalisable correspondante. Pour une matrice Ade type m×n,
il existe¡m
n¢
matrices extraites à tester !
L ’idée est d’ajouter des variables, dites artificielles w1,w2,..., wm, pour faire apparaître une forme simpliciale
du programme linéaire P: (AX=b). Mais, il faut que w1= ··· = wm=0. Donc, il faut minimiser d’abord le pro-
gramme linéaire P0suivant :
P0=min W=w1+···+ wm
s.t. (A|Im)×(x1...xnw1...wm)T=b
x1,..., xn,w1,..., wm ≥0
On exprime Wà l’aide des autres variables (hors base) et puis on applique l’algorithme du simplexe 10 pour P0
(phase I). À la fin, si on trouve que les wi=0, alors les variables de bases xj1,..., xjmforment une première base
admissible pour démarrer le simplexe pour le programme d’origine P.H. SABRI 31
Remarque 12. On ajoute la ligne de Z :c1 ... cn−c0dans le tableau du simplexe de P0(phase I) et on lui
applique les opérations élémentaire comme avec les autres lignes. À la fin de la phase I, on supprime les colonnes des
wiet la ligne de la fonction W . Finalement, on utilise ce tableau pour résoudre le problème initiale P.
Example 4.3
Soit le programme linéaire P:
min 6 x1+3x2
s.t. x1+x2≥1,
2x1−x2≥1,
3x2≤2,
x1,x2≥0sous forme standard (max)= = = = = = = = = = = = = = = = = = ⇒max Z= −6x1−3x2
s.t. x1+x2−e1=1,
2x1−x2−e2=1,
3x2+e3=2,
x1,x2,e1,e2,e3≥0
La matrice Aest :
A=x1 x2 e1 e2 e3

1 1 −1 0 0
2−1 0 −1 0
0 3 0 0 1
est par suite Pn’est pas sous forme simpliciale (il n’ ya pas de sous matrice I3). Donc on peut ajouter 2
variables artificielles pour construire le problème initiale P0:
max −w1−w2=3x1−e1−e2−2
s.t. x1+x2−e1+w1=1,
2x1−x2−e2+w2=1,
3x2+e3=2,
x1,x2,e1,e2,e3,w1,w2≥0dont le vecteur X=

0 x1
0 x2
0 e1
0 e2
2 e3
1 w1
1 w2est une solution de base réalisable.
Ainsi, on commence notre algorithme 10 pour le programme P0. Le tableau initial est :
x1 x2 e1 e2 e3 w1 w2 b

w1 1 1 −1 0 0 1 0 1
w2 2−1 0 −1 0 0 1 1
e3 0 3 0 0 1 0 0 2
W: 3 0 −1−1 0 0 0 2
Z:−6−3 0 0 0 0 0 0
Le pivot c’est a2,1donc x1est la variable entrante et w2est sortante. On obtient après pivotement le tableau :
L2←1
2L2− − − − − − − − →
L1←L1−L2
L4←L4−3L2
L5←L5+6L2x1 x2 e1 e2 e3 w1 w2 b

w1 03
2−11
20 1−1
21
2
x1 1−1
20−1
20 01
21
2
e3 0 3 0 0 1 0 0 2
W: 03
2−11
20 0−3
21
2
Z: 0 −6 0 −3 0 0 3 3
Le pivot est a1,2(Min ratio test =1
3). On obtient alors :32 Chapitre 4. Programmation linéaire
L1←2
3L1− − − − − − − − →
L2←L2+1
2L1
L3←L3−3L1
L4←L4−3
2L1
L5←L5+6L1x1 x2 e1 e2 e3 w1 w2 b


x2 0 1−2
31
302
3−1
31
3
x1 1 0−1
3−1
301
31
32
3
e3 0 0 2 −1 1 −2 1 1
W: 0 0 0 0 0 −1−1 0
Z: 0 0 −4−1 0 4 1 5
Ainsi, la phase I se termine avec W=0 et x1=2
3,x2=1
3,e3=1 et e1=e2=w1=w2=0. Le tableau pour la
phase II est donc :
x1 x2 e1 e2 e3 b


x2 0 1−2
31
301
3
x1 1 0−1
3−1
302
3
e3 0 0 2 −1 1 1
Z: 0 0 −4−1 0 5
On remarque donc que les cj≤0, donc (STOP) la solution est optimale et le max est −5. Ainsi la solution
optimale pour le programme P=min6 x1+3x2est−(−5)=5=6×2
3+3×1
3.
4.2 Dualité
SoitPun P .L. sous forme canonique. Le programme dualDdePest définit par :
P=max z=cTX
s.t. AX ≤ b
X≥ 0le dual est= = = = = = = ⇒D=min w=bTY
s.t. ATY≥ c
Y≥ 0
Le programme Pest dit primal . On remarque que si Ade type m×n, alors X∈RnetY∈Rmpour le dual.
Théorème 4.1 Théorème de dualité
Si un problème primal ou dual admet une solution, alors l’autre problème admet aussi une solution et on a :
max z=cTX =
s.t. AX ≤ b
X≥ 0min w=bTY
s.t. ATY≥ c
Y≥ 0
Exercice 4.3
Soit le problème suivant de type régime :
D=min w=340x1+2400 x2+560x3
s.t. x1+2x2+x3≥ 1200
x1+3x2+2x3≥ 1400
x1+x2+3x3≥ 1500
x1,x2,x3≥ 0
Écrire le programme primal PdeD. Résoudre le programme Pet déduire la valeur minimale de w, a-t-on
besoin de faire les deux phases du simplexe ?
7} A B oS



HOUSSEM SABRI
Graphes et Optimisation
2`emeannée
LISI  LSI
Institut Supérieur des Sciences Appliquées et de Technologie de Sousse
A.U. 2023-2024
28 novembre 2023Table des matières
1 Les graphes 3
1.1 Définitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.1 Graphes non orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.2 Graphes orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.2 Opérations et quelques types de graphes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.3 Représentation d’un graphe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.1 Listes d’adjacences (ou de succession) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.2 Matrices d’adjacence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.3.3 Matrice d’incidence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2 La connexité 11
2.1 Les chaînes et les cycles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.2 Graphe connexe, eulérien, hamiltonien . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.3 Arbres . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.3.1 Codage et décodage d’un arbre – Prüfer code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.3.2 Arbre couvrant de poids minimum – ACM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3 Les algorithmes de base 20
3.1 Parcours en profondeur (DFS) / largeur (BFS) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
3.2 Recherche des chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.1 Matrice d’adjacence et nombre de chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.2 Plus court chemin et l’algorithme de Dijkstra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
3.3 Problèmes d’ordonnancement et chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
3.3.1 Algorithmes de tri topologique et de chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . 25
4 Programmation linéaire 27
4.1 La méthode simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.1 Solution de base admissible . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux . . . . . . . . . . . . . . . . . . . . . . . . 29
4.1.3 Initialisation - Phase I du simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
4.2 Dualité . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
2CHAPITRE 1
Les graphes
L ’exemple classique pour introduire la théorie des graphes est le problème des ponts de Königsberg, étudié par
Euler en 1736. Quel itinéraire doit-on suivre pour traverser chaque pont exactement une fois? Une telle prome-
nade n’existe pas, et c’est Euler qui donna la solution de ce problème en caractérisant les graphes que l’on appelle
aujourd’hui eulériens .
A
B
Ce1 e2
e3 e4
De5
e6e7
FIGURE 1.1 – Les ponts de Königsberg
Les graphes introduisent une simplification : les régions se transforment en des "points" (aussi appelés noeuds
ousommet ), les ponts se transforment en des lignes (aussi appelées arêtes ouarcs ), et ce principe s’applique dès
lors qu’une relation existe entre des objets. Les graphes relèvent de la combinatoire plutôt que de la géométrie (les
intersections, les longueurs, et la forme des arêtes n’ont aucune importance, sauf en ce qui concerne la lisibilité de
la représentation).
1.1 Définitions
Dans la suite, il est toujours supposé que les graphes sont finis, sauf indication contraire.
1.1.1 Graphes non orientés
Définition 1.1: Graphe
Un graphe Gest un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V{2}des pairs non ordon-
nées de V.Vest l’ensemble des noeuds (Vertices en anglais) et Ec’est l’ensemble des arêtes de G(Edges en
anglais). Lorsque e={x,y} est une arête, on dit que x, y sont les extrémités de cette arête, que eest incidente
enxet en y. On joint x et y par un trait et on dit que x, y sont adjacents (ou voisins). On note aussi e=x you
encore e=(x,y) (attention , dans ce cas : ( x,y)=(y,x)).
SiGest un graphe alors, on note par V(G) l’ensemble de noeuds et par E(G) l’ensemble des arcs.
Remarque 1.
— Une arête e ={x,x}s’appelle boucle .
— Dans un graphe, il peut exister des arêtes parallèles (on parle donc de multigraphe ).
Dans l’exemple des ponts on a : e 1=e2=(A,B).
34 Chapitre 1. Les graphes
— Un graphe est dit simple s’il ne comporte ni arêtes multiples ni de boucles, c’est-à-dire chaque paire de nœuds
distincts est reliée par au plus une arête, ou encore E (G)⊆P2(G).
Dans la plupart des cas, les graphes sont considérés comme simples par défaut.
Définition 1.2: ordre – taille – degré
Soit G=(V,E) un graphe.
1. On appelle ordre d’un graphe noté v(G) le nombre de ses sommets :
v(G)= |V|
2. On appelle taille d’un graphe noté e(G) le nombre de ses arêtes :
e(G)= |E|
3. Le degré (ou valence) d’un sommet xnoté d(x) est le nombre d’arêtes contenant x. (Attention! Une
boucle sur un sommet compte double).
Si on note par Γ(x) l’ensemble des voisins de x, i.e.
Γ(x)={y∈V:x y∈E}
alors, siGest simple , on a :
d(x)= |Γ(x)|
Example 1.1 (Graphe complet)
Un graphe d’ordre nest dit complet noté Knsi chaque sommet du graphe est relié directement à tous les
autres sommets, i.e. E(Kn)=P2(V(Kn)).
Représenter graphiquement K3,K4,k5. Calculer la taille de K3,k4,...Kn.
Example 1.2 (Graphe biparti)
Un graphe G=(V,E) est dit biparti si son ensemble de sommets V=V1˙∪V2, i.e. peut être divisé en deux
sous-ensembles disjoints V1etV2tels que chaque arête ait une extrémité dans V1et l’autre dans V2.
Si∀x∈V1,∀y∈V2;x y∈E, alors Gest dit biparti complet noté Kn,moùn= |V1|etm= |V2|.
a1
 a2
 a3
 a4
b1
 b2
 b3
FIGURE 1.2 – Un graphe biparti
Théorème 1.1 Lemme des poignées de main – Handshaking lemma
Soit Gun graphe alors, on a :X
x∈V(G)d(x)=2e(G)
Dans ce théorème d(x) est le nombre de personnes à qui xserre la main et e(G) le nombre total de poignées
de mains.H. SABRI 5
Preuve.
•Méthode simple Il y en a d(x) arêtes en un sommet xfixé. Pour tout les sommets cela fait doncP
x∈V(G)d(x).
Mais avec cette manière chaque arête est comptée deux fois, une fois à chacune de ses extrémités, d’où le
résultat en divisant par 2.
•Preuve par double dénombrement On pose
Z={(x,e)∈V×E:x∈e}⊆V×E
et les deux projections :
p:Z→V
(x,e)7→xet q:Z→E
(x,e)7→e
L ’idée est de calculer |Z|de deux manières différentes. D’abord, on rappelle que si f:A→Best une fonction
quelconque, alors :X
b∈B|f−1[b]| = | A|
oùf−1[b] désigne l’image réciproque de { b} par f(pourquoi ˙S
b∈Bf−1[b] est une union disjointe ?).
Ainsi on obtient :
|Z| =X
x∈V|p−1[x]| =X
e∈E|q−1[e]|
Or,|p−1[x]| =d(x) et|q−1[e]| = |{x∈V:x∈e}| =2. Donc :
X
x∈Vd(x)=X
e∈E2=2|E|
Remarque 2.
— Un sommet de degré 0est appelé sommet isolé .
— Un graphe tel que : ∀x∈V,d(x)=kest dit graphe k-régulier .
— Le graphe complet K nest un graphe (n−1)-régulier .
Exercice 1.1
Montrer que dans un graphe le nombre de sommets d’ordre impairs est toujours pair. En particulier un
graphe k-régulier avec kimpaire est un graphe d’ordre pair.
Voici quelques exemples comme application :
1. Est-il possible de relier 15 ordinateurs en réseau de sorte que chacun soit relié à exactement 3 autres ?
2. Une ligue de football comprenant 11 clubs organise un tournoi. Pour gagner du temps on décide que chaque
équipe ne jouera que la moitié des matches possibles. Comment organiser le tournoi ?
Proposition 1.1
Soit G=(V,E) un graphe (simple) d’ordre n≥2. Alors :
∃u,v∈V,u̸=v:d(u)=d(v)
Preuve. Supposons le contraire, c’est-à-dire ∀u,v∈V;d(u)̸=d(v). Or dans un graphe (simple) on a toujours d(x)∈
{0,1,..., n−1}. Dans ce cas, puisque tous les nsommets ont des degrés distincts, alors il existe une bijection
{d(x):x∈V}←→ {0,1,..., n−1}
Donc, il existe un sommet uavec un degré 0, et un sommet vavec degré n−1, donc vest connecté à tous les autres
sommets du graphe, ce qui signifie que une peut pas être un sommet isolé, d’où une contradiction.6 Chapitre 1. Les graphes
1.1.2 Graphes orientés
Les arêtes d’un graphe peuvent être orientées, auquel cas une flèche indique la direction. De tels graphes sont
appelés des graphes orientés ou des digraphes , et une arête ( a,b) dans un tel graphe indique que cette arête est
dirigée de sommet avers b, i.e. ( a,b)=− →ab̸=(b,a)=− →ba. D’où la définition :
Définition 1.3: Graphe orienté - digraphe
Un graphe orienté G(ou− →G) est un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V2des pairs
ordonnées de V.Eest l’ensemble des arêtes (ou flèches, arcs) de G. Lorsque e=(x,y) est une arête, on dit
que xestl’origine (ou sommet initiale) et yl’extrémité (ou sommet terminale) de e, que eest sortant en x
et incident en y, et que yest un successeur de xtandis que xest un prédécesseur de y. On note l’arête e
par :
e=(x,y)=− →x y=x→y
De la même façon, une arête x→xest une boucle. On peut toujours supprimer les boucles pour obtenir des
digraphes simples. Voici l’exemple d’un digraphe G=(V,E) d’une fonction f:E→Eoù ( x,y) est un arc si et seule-
ment si y=f(x). On l’appelle digraphe fonctionnelle.
0
3
1214
11 568
169
4
2 1
713 10
15
FIGURE 1.3 – Le digraphe fonctionnelle Gfdex7→(x2+3) mod 17.
Comme dans les graphes on peut définir les degrés (entrant, sortant) d’un sommet dans un digraphe.
Définition 1.4: indegree - outdegree
Soit G=(V,E) un digraphe. Pour v∈V, on note par :
d+(v) le degré extérieur (sortant - outdegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité initiale.
d+(v)= |{v→ •}|
d−(v) le degré intérieur (entrant - indegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité finale.
d−(v)= |{• → v}|
On définit le degré : d(v)=d−(v)+d+(v).
Un sommet de degré entrant non nul et de degré sortant nul est appelé puits , tandis qu’un sommet de
degré entrant nul et de degré sortant non nul est appelé source ouracine .
Dans un graphe orienté, les voisins d’un sommet vsont soit des successeurs ou des prédécesseurs. On les notes
par :
Γ+(x)=Succ (x)={y∈V:x→y∈E} et Γ−(x)=Pr ed (x)={y∈V:y→x∈E}H. SABRI 7
Si le digraphe est simple (ni boucle ni arcs parallèles) on a :
d−(v)= |Γ−(v)|et d+(v)= |Γ+(v)|
Proposition 1.2
Soit Gun digraphe, alors :X
v∈Vd−(v)=X
v∈Vd+(v)= |E|
Preuve. On a
E=˙[
v∈V{• → v}=˙[
v∈V{v→ •}
=⇒ | E| =X
v∈V|{• → v}| =X
v∈V|{v→ •}| =⇒ | E| =X
v∈Vd−(v)=X
v∈Vd+(v)
1.2 Opérations et quelques types de graphes
Une opération sur les graphes permet de construire un nouveau graphe comme résultat de l’opération. Les
opérations courantes sur les graphes sont la suppression, la valuation, l’union, l’intersection et le produit cartésien.
Graphe valué
Tout d’abord, on peut vouloir attribuer des valeurs aux arcs ou arêtes pour tenir compte de contraintes : dis-
tance, coût ...
Définition 1.5: (di)graphe valué
Un (di)graphe valué G=(V,E,w) est un (di)graphe muni d’une application w:E→R. L ’application west
appelée application poids ou coût. On indique sur chaque arête son poids (ou son coût). On note w(x,y)
au lieu de w((x,y)). On convient (même que ceci n’a pas de sens!) que w(x,y)= +∞ si (x,y)∉E.
ab
c
d
ef53
43
3
335
81
FIGURE 1.4 – Un digraphe valué
/pythonPython code : -
Implémenter le digraphe valué précédent avec python. Indice – use chatGPT : how to build a weighted digraph with
python8 Chapitre 1. Les graphes
Sous graphes
Soit G=(V,E) un graphe (orienté ou non). Un sous graphe de Gest un graphe de la forme G′=(V′,E′) où
V′⊆V,E′⊆Etels que toute arête de E′a ses extrémités dans V′(ou encore G′est aussi un graphe). On a :
•Sous-graphe induit Un sous-graphe G′=(V′,E′) de G=(V,E) est appelé un sous-graphe induit deGsi :
∀x,y∈V′; (x,y)∈E′⇐⇒ (x,y)∈E
En d’autres termes, deux sommets de G′qui sont connectés dans G, sont également connectés dans G′.
•Sous-graphe couvrant Un sous-graphe couvrant G′deGcontient tous les sommets de G, i.e. V′=V.
•G−vSupprimer un sommet vd’un graphe Gconsiste à supprimer vet toutes ses arêtes incidentes. Le sous-
graphe obtenu de cette opération est noté G−v, i.e.
V′=V−{v} et E′=E−{(v,y): (v,y)∈E}
De manière similaire, une arête epeut être supprimée (resp. ajoutée) d’un graphe G, et le sous-graphe
résultant est représenté par G−e(resp. G+e). Notez que la suppression d’une arête ne retire pas de sommets
du graphe.
•G−V′=G[V′] On supprimer tous les sommets v∈V′du graphe Gavec les arêtes incidentes. Le sous-graphe
obtenu de cette opération est noté G[V′], i.e.
V(G[V′])=V−V′et E(G[V′])=E−{(v,y)∈E:v∈V′}
•Clique Une clique Cd’un graphe Gest un sous-ensemble des sommets de Gdont le sous-graphe induit G′=
(C,E′) est un graphe complet, en d’autres termes, deux sommets quelconques de la clique Csont toujours
adjacents.
•Stable Un stable – appelé aussi ensemble indépendant (independent set en anglais) est un ensemble de som-
mets deux à deux non adjacents. Donc le sous-graphe induit est sans arcs.
FIGURE 1.5 – L ’ensemble des sommets en bleu dans ce graphe est un stable maximal du graphe.
Note : -
Le problème décisionnel de la clique (c’est à dire existe t-il une clique de taille k) est NP-complet . De même la
recherche d’un stable de taille maximum dans un graphe est un problème NP-complet et difficile à approximer.
Exercice 1.2
Trouver un plus grand stable et une plus grande clique du graphe suivant :
8
4
62 7
3
1 5
Indice : vérifier le résultat avec networkx.find_cliques(G) et.maximum_independent_set(G) de python.H. SABRI 9
Opérations binaires
Union L ’union de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∪H=(VF,EF) dans lequel
VF=VG∪VH et EF=EG∪EH
Intersection L ’intersection de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∩H=(VF,EF)
dans lequel
VF=VG∩VH et EF=EG∩EH
1.3 Représentation d’un graphe
Il est important de savoir comment représenter les graphes au sein d’un ordinateur. Il ya plusieurs méthodes
selon la nature des traitements que l’on souhaite appliquer au graphe considéré.
1.3.1 Listes d’adjacences (ou de succession)
Soit Gun (di)graphe. On suppose que les sommets de Gsont numérotés de S1àSn. La représentation par listes
d’adjacence de Gconsiste en un tableau (ou des listes chainées) tel que la ligne i=1... ncorrespond au sommet Si
et comporte la liste des voisins/successeurs (ou des prédécesseurs) de ce sommet notée T[Si]. Les sommets dans
chaque liste d’adjacence sont généralement listés selon un ordre arbitraire.
1
2
345
FIGURE 1.6 – Un digraphe
La liste d’adjacence de digraphe 1.6 est donc :
1 2 3 4 5
2 3
3 4
4−
5 1 410 Chapitre 1. Les graphes
1.3.2 Matrices d’adjacence
Définition 1.6: Mat. Adjacence
Soit G=(V,E) un graphe (orienté) d’ordre n. On peut numéroter V={1,2,..., n}.La matrice d’adjacence
deGest la matrice carrée A=(ai j) d’ordre n, définie par :
ai j=(
1 si ( i j)∈E;
0 sinon.
Remarque 3.
1. Si le graphe G est non orienté et simple, alors la matrice A est symétrique avec des 0sur la diagonale. Pour un
digraphe simple, on a toujours des 0sur la diagonale, mais la matrice n’est pas symétrique en général.
2. Pour les multigraphes, il peut y avoir des termes diagonaux (pour les boucles) et s’il y a plusieurs arêtes de i à
j , le coefficient de la matrice a i jest le nombre d’arêtes de i à j .
3. Pour un (di)graphe valué G =(V,E,w), on pose :
ai j=(
w(i,j)si(i j)∈E ;
∞ sinon.
La matrice d’adjacence de la figure 1.4 est :

∞ 5∞ 4 3 ∞
∞ ∞ 3∞ 1∞
∞ ∞ ∞ ∞ ∞ 5
∞ ∞ 3∞ 3 3
∞ ∞ ∞ ∞ ∞ 8
∞ ∞ ∞ ∞ ∞ ∞

1.3.3 Matrice d’incidence
Définition 1.7: Mat. Incidence
Soit G=(V,E) un graphe (simple) d’ordre net de taille m. On pose V={v1,v2,..., vn} etE={e1,e2,..., em}.
La matrice d’incidence deGest la matrice de type n×m B=(bi j), définie par :
•Si G orienté
bi j=

1 si ej=vi→ • (i.e. viest l’extrémité initiale de ej) ;
−1 si ej= • → vi(i.e. viest l’extrémité terminale de ej) ;
0 sinon.
•Si G non-orienté
bi j=(
1 si viest une extrémité de ej;
0 sinon.
Exercice 1.3
1. Donner la matrice d’incidence du graphe 1.6.
2. Montrer le théorème 1.1 avec la matrice d’incidence.CHAPITRE 2
La connexité
Il est important de savoir si on peut suivre un chemin d’un sommet donné à un autre dans un graphe donné.
Cette propriété (de connexité) doit être maintenue dans différents types de réseaux.
2.1 Les chaînes et les cycles
Définition 2.1: (chaine – cycle) (chemin – circuit)
•Graphe non orienté
1. Une chaîne (walk ) reliant xày, notée µ(x,y), est définie par une suite finie d’arêtes consécutives,
reliant xày, ou encore une séquence de sommets (puisque non multigraphe)
µ(x,y)=<v0,v1,..., vk>
tels que v0=x,vk=yet (vi−1,vi)∈E(G) pour tout i=1... k. Six=yla chaîne est dite fermée .
Lalongueur du chaîne l(µ(x,y)) est le nombre d’arcs dans la chaîne, c’est-à-dire k.
2. Une chaîne élémentaire (a path ) si tous les sommets sont distincts. Une chaîne simple (a simple
walk, a trail ) est une chaîne ne passant pas deux fois par une même arête, c’est-à-dire dont toutes
les arêtes sont distinctes. Remarquer que : élémentaire =⇒ simple.
3. Un cycle v0v1...vnde longueur n≥3 est une chaîne simple fermée ( v0=vn) tel que les sommets
v0,v1,..., vn−1sont tous distincts. Un graphe sans cycle est dit acyclique .
•Graphe orienté
Dans un graphe orienté, on parlera de chemin au lieu de chaîne, et de circuit au lieu de cycle.
Example 2.1
abxcd xa est une chaîne simple et fermée (non cycle!) de longueur 6 (mais, c’est un graphe eulérien - voir
plus loin). Y a-t-il un cycle de longueur 3,4 ?
a b
x
c dÏ
Remarque 4.
1. On peut pivoter une chaine fermée (l’orienter de manière arbitraire) , i.e.
<v0,v1,v2,..., v0>=< vk,vk+1,..., v0,v1,..., vk>
1112 Chapitre 2. La connexité
2. Soient x ,y∈V . La distance de x à y est définie par :
d(x,y)=(
k si le plus court chemin/chaîne de x vers y est de longueur k
∞ sinon
On convient que d (x,x)=0.
3. Le diamètre du graphe la plus grande distance entre deux sommets.
L ’observation suivante, bien que très facile à prouver, sera utile.
Théorème 2.1
S’il existe une chaîne du sommet yau sommet zdans le graphe G, où y̸=z, alors il existe une chaîne élé-
mentaire ( path ) dans Gavec pour premier sommet yet pour dernier sommet z.
Preuve. Soit la chaine
W1=µ(y,z)=x0x1...xn; avec x0=yetxn=z.
Si les sommets x0,x1,..., xnsont tous distincts, alors W1est une chaîne élémentaire, et nous avons terminé. Sinon,
il existe xi=xj(i<j) et on écrit :
W2=x0x1...xixj+1...xn.
Alors, l(W2)<l(W1). Si W2ne contient aucun sommet répété, alors c’est la chaîne recherché. Sinon, par la même
procédure, il existe W3(y z−chaîne) tel que
l(W3)<l(W2)<l(W1).
Ce processus doit s’arrêter à un certain stade, car chaque chaîne est plus courte que la précédente et la longueur
ne peut jamais être inférieure à 1
1< ··· < l(Wk)< ··· < l(W3)<l(W2)<l(W1).
Ainsi, pour un certain k,Wkne peut pas être réduit en longueur. Donc, la chaîne Wkne contient aucun sommet
répété et est donc une y z−chaîne élémentaire (path).
Exercice 2.1
Dans le graphe suivant, construire un path à partir de la chaîne W=v2v3v4v5v6v4v2v8v1
v1
 v2
v3
v4
v5
v6
v7
 v8
 v9
Calculer d(v1,v7) et le diamètre de G.
/pythonpython : >>G = nx.Graph([(1, 2), (2, 3), (2, 4), ...]) >>nx.diameter(G)
Les cycles fournissent la caractérisation suivante pour les graphes bipartis .H. SABRI 13
Théorème 2.2
Un graphe est biparti si et seulement s’il ne contient aucun cycle de longueur impaire.
Preuve.
⇒On suppose que G=U˙∪Vest un graphe biparti. Soit W=< x1,x2,..., x2k+1,x1>un cycle de longueur im-
paire (2 k+1). Si x1∈U, alors
x1∈U=⇒ x2∈V=⇒ x3∈U=⇒ ··· =⇒ x2k+1∈U=⇒ x1∈V/exclamati⌢n-triangle
absurde, d’où le résultat.
⇐On suppose que Gest connexe (car l’union des composantes connexes bipartis est un graphe biparti). Soit
xun sommet de Get on pose :
U={y∈V(G):d(x,y) est paire} et V={z∈V(G):d(x,z) est impaire}
S’il existe y1,y2∈Utel que y1y2∈E(G), alors on a :
W1=<x,..., y1>est une chaîne de longueur paire =2k1
W2=<x,..., y2>est une chaîne de longueur paire =2k2
=⇒ W3=<x,..., y1,y2,..., x>est un cycle de longueur impaire =2k1+2k2+1/exclamati⌢n-triangle
Donc G=U˙∪Vest un graphe biparti.
Exercice 2.2
Vérifier si le graphe maison est un graphe biparti. Faire de même pour la grille G4,4.
maison grille
2.2 Graphe connexe, eulérien, hamiltonien
Définition 2.2: Graphe connexe
Un graphe est dit connexe si deux points peuvent toujours être joints par une chaîne, i.e.
∀x,y∈V(G),d(x,y)< ∞
— Une composante connexe d’un graphe est un sous-graphe induit maximal connexe.
— Un point d’articulation d’un graphe est un sommet dont la suppression augmente le nombre de
composantes connexes.
Par exemple, le graphe suivant :14 Chapitre 2. La connexité
a
 b
d
 c
e
f
 g
n’est pas connexe car il n’existe pas de chaîne entre les sommets aete. On a donc 2 composantes connexes. En
revanche, le sous-graphe induit par les sommets { a,b,c,d} est connexe dont aest le seul point d’articulation.
Remarque 5.
1. Un graphe connexe à n sommets possède au moins n −1arêtes ( faite une preuve par récurrence ).
2. L’algorithme de parcours en profondeur permet de déterminer si un graphe est connexe ou non.
3. Même définitions dans un graphe orienté . Graphe orienté (fortement) connexe et de composante connexe .
Définition 2.3: Graphe eulérien
— Une chaîne joignant deux sommets xetyest dite chaîne eulérienne si elle emprunte chaque arête
deGune et une seule fois. On parle de chemin eulérien dans le cas d’un graphe orienté.
— Un cycle eulérien est une chaîne eulérienne dont les extrémités coïncident. Un graphe qui admet
un cycle (resp. circuit) eulérien est dit graphe eulérien .
/flushedRemarquer qu’un cycle eulérien n’est pas forcément un cycle comme définit dans la définition 2.1
Si un graphe (ou multigraphe) Gpossède une chaîne eulérienne, alors soit Gpossède deux sommets impairs, le
début et la fin de cette chaîne, soit Gn’a aucun sommet impair, et la promenade d’Euler commence et se termine
au même point (cycle eulérien). Une autre condition nécessaire évidente est que Gdoit être connexe. Ces deux
conditions sont ensemble suffisantes.
Théorème 2.3 Euler
Soit Gun graphe (multigraphe) connexe.
— Si Gn’a pas de sommets impairs, alors il possède un cycle eulérien (commençant à n’importe quel
point).
i.e.∀x,d(x)≡0 mod 2 =⇒ Gest un graphe eulérien.
— Si Ga deux sommets impairs, alors il possède une chaîne eulérienne dont le début et la fin sont les
sommets impairs.
La réciproque est aussi vraie.
Preuve.
⇐On commence par la réciproque. S’il existe une chaîne eulérienne µ(x,y), alors on peut crée une arête fictive
e=(y,x) et par la suite on obtient un cycle eulérien. Donc il suffit de montrer que si Gadmet un cycle
eulérien alors tous les sommets sont de degré pair.
Soit W=< v1,v2,..., vn,v1>un cycle eulérien. Soit le sommet vjavec j̸=1, il est donc claire que chaque
fois vjapparaît dans W, il ya deux arcs distincts incidents en vj( (•,vj) et ( vj,•)). Comme toutes les arêtes
sont utilisées, on voit que d(vj) est pair. Même chose pour v1car on ajoute deux arcs ( v1,v2) et ( v1,vn).
⇒On suppose que tous les sommets sont de degré pair. Montrons que Gadmet un cycle eulérien. Puisque
tous les sommets sont de degré pair on peut construire d’abord une chaîne simple fermée (quelconque)
W1=<v1,v2,..., vk,v1>
SiW1contient chaque arête de G, alors c’est finis, c’est un cycle eulérien. Sinon (puisque Gest connexe), il
existe une arête e=(vi,c) qui n’est pas dans W1(avec visommet de W1). On pose le sous-graphe
G′=G−{ arêtes de W1}H. SABRI 15
Il est donc claire que les sommets de G′sont aussi de degré pair. Alors, par la même procédure on construit
une chaîne simple fermée dans G′de la forme : <vi,c,d,..., vi>et par la suite on insère cette chaîne dans
W1pour obtenir :
W2=<v1,v2,..., vi,c,d,..., vi,vi+1,..., vk,v1>
Sil(W2)< |E(G)|, on construit W3de longueur plus grand. Ainsi, on a :
l(W1)<l(W2)<l(W3)< ··· ≤ | E(G)|
Donc, nécessairement, il existe Wk(chaîne simple fermée de longueur |E(G)|) donc c’est un cycle eulérien.
Finalement , si∃a,b∈V(G):d(a)≡d(b)≡1 mod 2, et tous les autres sommets sont de degré pair, alors on
pose :
G′=G+{a,b}
et donc tous les sommets de G′sont de degré pair. Avec la construction précédente, il existe un cycle eulérien
dans G′:
W=<a,b,v1,..., a>
est donc la chaîne <b,v2,..., a>est une chaîne eulérienne dans G.
Algorithme 1 : Euler
Entrées : Gun graphe eulérien
Output : Un cycle eulérien W
/* On suppose que G est eulérien, i.e. les sommets sont de degré pair */
1Gaux←G;W←µ(v,v) une chaîne simple (quelconque) de G; // Initialisation
2tant que l(W)<e(G)faire
3 Gaux←G−{ arêtes de W} ;
4 Choisir ( x,c)∈E(Gaux) tel que x∈W;
5 L←< x,c,..., x>une chaîne simple de Gaux ;
6 Dans W, remplacer (juste ce) xpar la séquence L;
7fin
8retourner W;
Exercice 2.3
1. Montrer que le graphe de l’exercice 2.1 est un graphe eulérien et donner un cycle eulérien.
2. Tracer cette maison d’un seul trait.
Remarque 6. Le théorème d’Euler dans un graphe orienté connexe s’écrit :
Admet un circuit eulérien si, et seulement si, pour tout sommet, le degré entrant est égal au degré sortant.
∀v∈V(G),d+(v)=d−(v)
Admet un chemin eulérien de a vers b si, et seulement si,


d+(v)=d−(v) ;∀v̸=a,b,
d−(a)=d+(a)−1
d−(b)=d+(b)+116 Chapitre 2. La connexité
Définition 2.4: Graphe hamiltonien
Soit Gun graphe connexe d’ordre n. On appelle :
1. On appelle cycle hamiltonien deGun cycle passant (une et une seule fois) par chacun des sommets
deG. Un graphe est dit hamiltonien s’il possède un cycle hamiltonien.
2. Une chaîne hamiltonienne est une chaîne passant une et une seule fois par chacun des sommets de
G. Un graphe ne possédant que des chaînes hamiltoniennes est semi-hamiltonien .
3. Dans un digraphe, on change cycle par circuit et chaîne par chemin .
Remarque 7.
— Une chaîne hamiltonienne est une chaîne élémentaire de longueur n −1.
— Un graphe peut être eulérien, hamiltonien, les deux à la fois, ou aucun des deux.
— De nombreux problèmes concrets peuvent être formulés en termes de recherche de parcours hamiltoniens : pro-
blème du voyageur de commerce (chercher un cycle hamiltonien de longueur totale minimale), l’ ordonancement
de tâches .
— Le problème du chaîne hamiltonienne est un problème NP-complet .
Exercice 2.4
Donner un graphe (connexe, simple) qui soit :
1. hamiltonien et eulérien.
2. hamiltonien et non eulérien.
3. eulérien et non hamiltonien.
4. non hamiltonien et non eulérien.
Aucune condition nécessaire et suffisante adéquate n’est connue pour l’existence de cycles hamiltoniens. Le
résultat suivant constitue une condition suffisante utile.
Théorème 2.4 Ore
Soit Gun graphe simple d’ordre n≥3. Si pour toute paire { x,y} de sommets non adjacents, on a d(x)+d(y)≥
n, alors Gest hamiltonien.
Preuve. On suppose que le théorème est faux. Alors, il existe un graphe Gsimple d’ordre nnon hamiltonien tel que
d(u)+d(v)≥npour tout sommets non adjacents uetv. On prend Gun tel graphe d’ordre nde taille maximale qui
vérifie cette propriété (remarquer que le graphe complet Knest hamiltonien).
Soient uetvdeux sommets non adjacents de G. Par maximalité de G, le graphe G+uv(d’ordre n) doit être
hamiltonien. Donc il existe dans G+uvun cycle hamiltonien :
W=<u,x1,x2,..., xn−2,v,u>
u
x1
xi xi+1xn−2
v
... ...
Or, si uxi+1∈E(G) etv xi∈E(G) (les arcs en rouge), alors on peut construire dans Gle cycle hamiltonien :
<u,x1,x2,..., xi,v,xn−2,..., xi+1,u>H. SABRI 17
Ceci est absurde car Gest non hamiltonien. Donc si xi+1est un sommet voisin à u, alors le sommet xin’est pas
voisin de v:
xi+1∈Γ(u)=⇒ xi∉Γ(v)
Donc :
d(u)= |Γ(u)| =p=⇒ d(v)≤(n−1)−p
et par la suite
d(u)+d(v)≤n−1
ce qui absurde par hypothèse. Donc Gest hamiltonien.
Une conséquence immédiate est le théorème de Dirac :
Proposition 2.1 Dirac
Soit Gun graphe simple d’ordre n≥3. Si pour tout sommet xdeG, on a d(x)≥n
2, alors Gest hamiltonien.
2.3 Arbres
Définition 2.5: Arbres et forêts
On appelle arbre tout graphe (non orienté) connexe et acyclique . Les composantes connexes dans un
graphe acyclique sont des arbres et le graphe est dit forêt . Une feuille ou sommet pendant est un som-
met de degré 1.
Un forêt avec deux arbres
Un graphe Gest une arborescence s’il existe un sommet Rappelé racine deGtel que, pour tout sommet
SdeG, il existe un chemin et un seul de Rvers S. Donc, c’est un arbre orienté dans lequel on choisit un
sommet Rcomme racine et on dirige les arcs vers le sens sortant de la racine.
Remarque 8.
— Un graphe G d’ordre n est un arbre ssi G est sans cycle et possède n −1arêtes.
— Un graphe G d’ordre n est un arbre ssi G est connexe et possède n −1arêtes.
— G est un arbre si pour chaque paire u ,v de sommets distincts est reliée par une seule chaîne (donc chaîne
élémentaire d’après le théorème 2.1).
— Un arbre (ou forêt) est nécessairement un graphe simple.
Pour démontrer les remarques précédentes, il suffit de prouver le théorème suivant :
Théorème 2.5
Soit Gun graphe ayant marêtes, nsommets et pcomposantes connexes, on définit nu( G) :
ν(G)=m−n+p
Alors, on a :
1.ν(G)≥0.
2.ν(G)=0⇐⇒ Gest acyclique.18 Chapitre 2. La connexité
Preuve. Par récurrence sur la taille mdu graphe. Le résultat est évident pour m=0 et m=1. On suppose le résultat
est vrai pour les graphe de taille m, et montrons que ceci est vrai pour un graphe de taille m+1. Soit donc Gun
graphe d’ordre nde taille m+1 ayant pcomposantes connexes.
•On suppose que Gest un graphe acyclique. Soit uvune arête de Gdans la composante C. Si on supprime uv,
la composante Cse transforme en deux composantes connexes (sinon on a un cycle dans G). Par la suite,
le graphe G′=G−uvest un graphe acyclique d’ordre n, de taille met ayant p+1 composantes connexes.
Donc d’après l’hypothèse de récurrence :
ν(G′)=0=(m−1)−n+(p+1)=m−n+p=ν(G)
•Maintenant, si Gcontient un cycle Wdans la composante connexe C. Soit uvune arête de W, alors si on
supprime l’arête uv, la composante Creste connexe. Donc le graphe G′=G−uvest un graphe d’ordre nde
taille m−1 ayant pcomposantes connexes. Donc, d’après l’hypothèse de récurrence :
ν(G′)=(m−1)−n−p≥0
=⇒ν(G)=m−n−p≥1>0
D’où le résultat – car si ν(G)=0,Gne peut être que acyclique, sinon 0 =ν(G)≥1/exclamati⌢n-triangle
2.3.1 Codage et décodage d’un arbre – Prüfer code
Soit Tun arbre ayant nsommet numérotés {1,2,..., n}. Le codage de Prüfer représente l’arbre Tarbre de avec
une suite P=(x1,x2,x3,..., xn−2) de n−2 termes (les n° des sommets avec répétition possible). Une suite Pdonnée
correspond à un et un seul arbre numéroté. Voici les algorithmes de codage et de décodage.
Algorithme 2 : Codage de Prüfer
Entrées : Un arbre T
Output : Séquence de Prüfer P
1P←() ; // Initialisation de P comme séquence vide
2tant que v(T)>2faire
3 x←feuille de Tayant le n° minimum ; // donc d(x)=1
4 P←(P,s) où sest le seul (n°) sommet adjacent à x;
5 T←T−x;
6fin
7retourner P;
Example 2.2
Donner le code de Prüfer de l’arbre :
126 345
Indice : on trouve, P=(2,3,3,2)
Pour faire la réciproque, étant donnée une séquence P=(x1,x2,..., xn−2) où les xi∈{1,2,..., n}, on construit
l’arbre Tdont les sommets sont {1,2,..., n} avec l’algorithme suivant (le décodage) :H. SABRI 19
Algorithme 3 : Décodage de Prüfer
Entrées : Une séquence Pde taille n−2
Output : L ’arbre Tcorrespondante
1I←{1,2,..., n};
2T←graphe tel que V(T)=IetE(T)= ; ; // T graphe à n sommets isolés
3tant que P̸=()faire
4 i←min {x∈I:x∉P};
5 T←T+(i,P[1]) ; // ajouter l'arc (i,P[1])
6 P←P−P[1];I←I−{i};
7fin
8T←T+(a,b) ; // a,b sont les deux éléments restant dans I
9retourner T;
Example 2.3
Donner l’arbre dont le code de Prüfer est : P=(2,3,3,3)
Puisqu’il ya une bijection entre les arbres d’ordre net les suites Pde longueur n−2 à coefficients dans {1,2,..., n},
on déduit le théorème de Cayley :
Théorème 2.6 Formule de Cayley
Le nombre d’arbres que l’on peut construire sur n(n≥2) sommets numérotés est égal à nn−2.
2.3.2 Arbre couvrant de poids minimum – ACM
Soit Gun graphe (non orienté). Un arbre couvrant (spanning tree) TdeGest un sous graphe couvrant de G
tel que Test un arbre. Remarquer que, Gdoit être connexe, sinon un arbre couvrant de Gn’existe pas. Le nombre
des arbres couvrant de Gest noté a(G). Remarquer que a(Kn)=nn−2(le nombre de Cayley). Un problème algo-
rithmique classique est de trouver, dans un graphe valué , un arbre couvrant de poids minimal . On dispose de
plusieurs algorithmes (l’algorithme de Prim, l’algorithme de Kruskal ...).
Algorithme 4 : Kruskal
Entrées : Un graphe Gvalué d’ordre net de taille m
Output : Arbre (ou forêt) couvrant de poids minimum
1Numéroter les arêtes de Gpar poids minimum : w(e1)≤w(e2)≤ ··· ≤ w(em)
2T←graphe tel que V(T)=V(G) etE(T)= ; ; // T graphe à n sommets isolés
3k←0;
4tant que k<m et e (T)<n−1faire
5 siT+ek+1est acyclique alors
6 T←T+ek+1;
7 k←k+1;
8fin
9retourner T;
Appliquer l’algorithme de Kruskal dans le graphe suivant :
CHAPITRE 3
Les algorithmes de base
Beaucoup de problèmes sur les graphes nécessitent que l’on parcourt l’ensemble des sommets et des arcs. Par
exemple, pour vérifier que le graphe est connexe, chercher un sommet particulier, construire un arbre couvrant,
trouver un plus court chemin ...etc.
3.1 Parcours en profondeur (DFS) / largeur (BFS)
Une manière simple de tester si un graphe Gest connexe ou non est d’exécuter l’algorithme DFS ouBFS dans
Gen commençant par n’importe quel sommet et en enregistrant les sommets visités pendant l’exécution dans une
liste. Si la liste contient tous les sommets de G, alors Gest connexe. Une petite modification permet de donner les
composantes connexes de G. L ’algorithme DFS_Component suivant donne les composantes connexes de G. Il est
donné sous forme d’implémentation récursive.
Algorithme 5 : DFS_Component
Entrées : Un graphe G=(V,E)
Output : Les composantes connexes C=(C1,C2,..., Ck) de G.
1VisitedNodes ← ; ;
2k←0 ; // k est le nombre des composantes connexes
3pour chaque u∈Vfaire
4 siu∉VisitedNodes alors
5 k←k+1;
6 DFS( u);
7 fin
8fin
9retourner (C1,C2,..., Ck);
1Procedure DFS( u )
2 VisitedNodes ←VisitedNodes ∪{u};
3 Ck←Ck∪{u};
4 pour chaque x∈Γ(u)faire
5 six∉VisitedNodes alors
6 DFS( x);
7 fin
8 fin
Note : -
Il est possible de d’implémenter la procédure DFS itérativement à l’aide d’une pile LIFO (stack) contenant les
sommets à explorer : on désempile un sommet et on empile ses voisins non encore explorés.
20H. SABRI 21
Pseudocode :
stack . push ( root )
while stack . isEmpty ( ) = f a l s e do
node = stack . pop ( ) // so mark i t as v i s i t e d
for each x in node . childNodes do
i f x i s not v i s i t e d then
stack . push ( x )
. . .
endfor
endwhile
Example 3.1 (DFS )
Ici on empile (gris) les sommets les plus à droite, alors l’ordre des sommets visité (noir) est ( a,b,d,e,g,c,f).
Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b
 c
d
 e
f
g
a
b
 c
d e
f
ga
b
 c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g
L ’utilisation d’une file (FIFO) au lieu d’une pile transforme l’algorithme du parcours en profondeur en algo-
rithme de parcours en largeur ( BFS ). Avec BFS l’exemple précédent devient (en enfile le plus à gauche) :
Example 3.2 (BFS )
Ici, avec BFS, on enfile (gris) les sommets les plus à gauche d’abord, alors l’ordre des sommets visité (noir)
est ( a,b,d,e,g,c,f). Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b c
d
 e
f
g
a
b c
d
 e
f
ga
b c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g22 Chapitre 3. Les algorithmes de base
Exercice 3.1
1. Écrire la procédure BFS .
2. Utiliser DFS (ou BFS) pour la construction d’un arbre couvrant d’un graphe connexe. L ’appliquer
pour le graphe triangle.
3. Utiliser DFS pour écrire une procédure DFS_Cycle pour détecter un cycle dans un graphe.
On sait qu’un graphe orienté G=(V,E) est fortement connexe si pour chaque paire de sommets u,v∈V, il
existe un chemin de uàvet il existe un chemin de vàu. En d’autres termes, nous avons besoin d’une connectivité
dans les deux directions .
Une procédure pour tester si un graphe orienté est fortement connexe ou non peut être conçue avec l’idée
suivante. En partant d’un sommet arbitraire vdu graphe G, on exécute l’algorithme BFS ouDFS et l’on note les
sommets visités. Ensuite, on obtient la transposée de G,GT, en inversant la direction des arêtes de G, et l’on
exécute à nouveau l’algorithme BFS ou DFS à partir du sommet v. Si les sommets visités dans les deux cas sont
égaux à V, alors le graphe orienté est fortement connexe. Cette méthode est illustrée dans l’algorithme 6.
Algorithme 6 : Fortement_connexe
Entrées : Un graphe orienté G=(V,E)
Output : true siGest fortement connexe et false sinon
1X← ; ;
2Y← ; ;
3v←un sommet quelconque de V;
4X←DFS( G,v) ; // Enregistrez les sommets visités dans X
5GT←Gavec flèches inversées;
6Y←DFS( GT,v);
7siX=Y=Valors
8 retourner TRUE.
9sinon
10 retourner FALSE.
11fin
3.2 Recherche des chemins
3.2.1 Matrice d’adjacence et nombre de chemins
La puissance de la matrice d’adjacence Amontre qu’il y a des chemins (ou chaînes) de longueur kallant de xà
ycomme le montre le théorème suivant.
Théorème 3.1
Soit G=(V,E) un (di)graphe. On note V={1,2,..., n} et Asa matrice d’adjacence et Akla puissance k-ème
deA. Alors le terme d’indices i,jdeAkest le nombre de chemins (chaînes) de longueur kallant de iàj.
Preuve. Par récurrence sur k. Pour k=1 c’est clair. On suppose le résultat est vrai à l’ordre ket montrons qu’elle
est vrai pour k+1. Soit S=(si,j)=Ak. Si on a un chemin de iàjde longueur k+1, alors on va d’abord de ià un
sommet ravec kpas et puis de ràj. Or d’après l’hypothèse de récurrence on a si,rchemins possibles pour aller de
iàret finalement ar,jpas (1 ou 0) pour aller de ràj. Ainsi, le nombre totale possibles (i.e. tous les sommets r) est :
nX
r=1si,rar,j=³
Ak×A´
i,jH. SABRI 23
ce qui est bien le terme ( i,j) de la matrice Ak+1.
3.2.2 Plus court chemin et l’algorithme de Dijkstra
Dans cette partie on suppose que le (di)graphe G=(V,E,w) est valué positivement (i.e.∀e∈E,w(e)>0). Notre
objectif est de chercher un plus court chemin (i.e., un chemin de poids minimal ) d’un sommet ufixé à un sommet
quelconque de G.
Il est clair que l’on peut restreindre ce problème au cas d’un (di)graphe simple1. On suppose aussi que Gest
connexe (sinon, certains trajets sont impossibles). Il est aussi claire (d’après théorème 2.1), qu’un plus court chemin
est nécessairement un chemin élémentaire (path).
L ’algorithme de Dijkstra (1959) permet de calculer le plus court chemin entre un sommet particulier u(racine )
et tous les autres sommets. L ’algorithme fonctionne de la manière suivante :
Pour tout sommet vdeG, on associe une valeur T(v), initialisée à w(u,v) et une liste de sommets C(v) qui
correspond à un chemin de uàv. À la fin de l’algorithme, T(v) contient le poids minimal des chemins joignant uà
v(ou T(v)= ∞ siu↛v) et la liste C(v) réalise un tel chemin. Voici donc l’algorithme de Dijkstra :
Algorithme 7 : Algorithme de Dijkstra
Entrées : Un (di)graphe valué G=(V,E,w) et un sommet racine u
Output : Le coût minimum d’un chemin de uàv(∀v∈V) et un trajet pour chaque coût minimal obtenu
1∀v∈V,T(v)←w(u,v) etC(v)←(u,v); // Initialisation de T(v) et la liste C(v)
2X←{u};
3tant que X̸=Vfaire
4 Choisir v∈V−Xtel que ∀y∈V−X,T(v)≤T(y);
5 X←X∪{v};
6 pour chaque y∈V−Xfaire // Faire les mises à jours pour les autres sommets
7 siT(y)>T(v)+w(v,y)alors
8 T(y)←T(v)+w(v,y);
9 C(y)←[C(v),y]; // On ajoute à la liste C(v) l'élément y
10
11 fin
12 fin
13fin
Example 3.3
Voici une application de l’algorithme de Dijkstra au digraphe suivant. On prend Ecomme sommet racine.
EA
B
CD
FG
S5
4
21
12
2
34
4
215
7
1. En effet, passer par une boucle ne ferait qu’augmenter inutilement le poids de ce chemin. De même, si plusieurs arcs joignent deux
sommets, il suffit de conserver l’arc de poids minimal.24 Chapitre 3. Les algorithmes de base
Ainsi, pour l’initialisation, on a : X={E} et on a les valeurs :
v  E A B C D F G S
T(v) 0 5 4 2 ∞ ∞ ∞ ∞
C(v)(E,E) ( E,A) ( E,B) ( E,C) ( E,D) ( E,F) ( E,G) ( E,S)
Maintenant, on choisit (un seul choix) le sommet C, donc X={E,C}. Le tableau est mis à jour :
v  E A B  C D F G S
T(v) 0 5 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À l’étape suivante, on est forcé de choisir B. Ainsi, X={E,C,B} et la mise à jour est :
v  E A  B  C D F G S
T(v) 0 4 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À présent, on a le choix entre AetF. On choisit A. Donc X={E,C,B,A} et on a :
v  E  A  B  C D F G S
T(v) 0 4 3 2 6 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,B,A,D) ( E,C,F) ( E,C,G) ( E,S)
Puis, on prend le sommet F. D’où X={E,C,B,A,F} et :
v  E  A  B  C D  F G S
T(v) 0 4 3 2 5 4 5 11
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,S)
On prend Det on obtient X={E,C,B,A,F,D} et :
v  E  A  B  C  D  F G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Finalement, on prend Gpuis Set on voit que ceci ne change rien. D’où le tableau finale :
v  E  A  B  C  D  F  G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Ainsi le chemin minimum pour aller de EàSest de coût 10 et un trajet de coût minimal de EàSest : EC F DS .H. SABRI 25
3.3 Problèmes d’ordonnancement et chemin critique
Un problème d’ordonnancement peut-être représenté sous la forme d’un digraphe. Les sommets sont des évé-
nements (début et fin de la tâche) et les arcs des tâches, La longueur (ou poids) de chaque arc représente la durée
d’exécution de la tâche. Ainsi, la tâche correspondant à l’arc ( i,j) ne peut commencer que si toutes les tâches cor-
respondant à des arcs ( k,i) ont été complétées. On ajoute deux sommets pour le début (s) et de fin(t) du projet .
Le digraphe peut contenir des tâches fictives dedurée nulle afin de forcer certaines précédences (postériorité).
Ainsi, un réseau PERT est un digraphe valué G=(V,E,w,s,t) où la fonction poids (ou longueur) w:E→R+
etsle sommet source (début) et tle sommet puits (fin). Un chemin critique est un chemin de sàtdelongueur
maximale . S’il n’existe pas de chemin critique, le projet n’est pas réalisable (e.g. un circuit). Le temps minimal
requis pour l’exécution d’un projet réalisable est égal à la longueur d’un chemin critique. Les tâches figurant sur un
chemin critique sont aussi appelées critiques, ce qui s’explique par le fait que tout retard d’exécution d’une tâche
critique retarde d’autant l’exécution du projet.
3.3.1 Algorithmes de tri topologique et de chemin critique
Il faut d’abord numérotés les sommets de 1 à nde manière compatible au pré-ordre (rang) avec l’algorithme du
rang suivant (tri topologique) :
Algorithme 8 : Algorithme du rang
Entrées : Un digraphe G=(V,E) sans circuit
Output : Le rang r(v) de chaque sommet v∈Vde G
1r←0;X←V;
2R←{v∈X:Γ−
X(v)= ;} ; // l'ensemble des sommets de X sans prédécesseur dans X
3tant que X̸= ; faire
4 r(v)←rpour chaque sommet v∈R;
5 X←X−R;
6 R←l’ensemble des sommets de Xsans prédécesseur dans X;
7 r←r+1;
8fin
On supposera dorénavant que les sommets ont déjà été numérotés de 1 à nde manière compatible avec leurs
rangs, c’est-à-dire que r(j)>r(i) implique j>i(donc 1 =setn=t). Enfin, on supposera éliminés les arcs paral-
lèles par l’introduction de tâches fictives de durée nulle .
Pour un sommet i, on note tiledébut au plus tôt des tâches correspondant aux arcs i→jet par Tilafin au
plus tard des tâches correspondant aux arcs j→i.
Algorithme 9 : Algorithme du chemin critique
Entrées : Un digraphe G=(V,E) sans circuit trié topologiquement
Output : La durée du chemin critique et les dates ti,Ti
1t1←0;
2pour j=2···nfaire // Calcul des dates de début au plus tôt  récurrence en avançant
3 tj←max i∈Γ−(j){ti+w(i,j)}
4fin
5Tn←tn;
6pour j=n−1···1faire // Calcul des dates de fin au plus tard  récurrence en reculant
7 Tj←min i∈Γ+(j){Ti−w(j,i)}
8fin26 Chapitre 3. Les algorithmes de base
Définition 3.1
— Un sommet iest critique si ti=Ti.
— Un arc ( i,j) est critique les sommets ietjsont critiques ettj−ti=w(i,j).
— Un chemin critique est un chemin de 1 à nn’utilisant que des arcs critiques.
— La durée du chemin critique est donnée par Tn(ou par tn). Elle correspond à la durée minimale du
projet .
Example 3.4
L ’application de l’algorithme du chemin critique au digraphe suivant (trié topologiquement) est :
1 23
45
6B
9A
3
C
5D
8
E
4
F7G
20
H6I5
=⇒
 1
0,02
9,933,16
4
16,23513,24
6
29,29B
9A
3
C
5D
8
E
4
F7G
20
H6I5
Les tâches critiques sont BetG. La durée totale minimale du projet est donc 29.
Exercice 3.2
Les tâches ( durée et précédences ) pour la construction d’un entrepôt sont données dans le tableau suivant :
Tâches Nature Précédences Durée (jours)
A Acceptation des plans par le propriétaire – 4
B Préparation du terrain – 2
C Commande des matériaux A 1
D Creusage des fondations A, B 1
E Commande des portes et fenêtres A 2
F Livraison des matériaux C 2
G Coulage des fondations D, F 2
H Livraison des portes et fenêtres E 10
I Pose des murs, de la charpente et du toit G 4
J Mise en place des portes et fenêtres H, I 1
1. Représentez le graphe des précédences de ce projet (trié topologiquement).
2. Déterminez une durée totale minimale en exhibant un chemin critique dans ce graphe.CHAPITRE 4
Programmation linéaire
La programmation linéaire est le processus de minimiser ou maximiser une fonction objective linéaire sou-
mise à un nombre fini de contraintes d’égalités et d’inégalités linéaires.
La programmation linéaire a de nombreuses applications dans le domaine de l’informatique théorique. Elle
peut être utilisée pour résoudre de nombreux problèmes combinatoires variés, tels que la recherche de flot maxi-
mum dans un réseau, la recherche d’un couplage maximal dans un graphe et la coloration d’un graphe parfait.
Example 4.1 (Problème de régime)
On suppose qu’on a quatre plats : de la truite ( XT), un sandwich au corned-beef ( XC B), un burrito ( XBU R )
et un hamburger ( XHB). Le tableau suivant répertorie la valeur nutritionnelle de chaque plat (vitamines et
calories) et notre besoin journalier des vitamines.
Vit. A Vit. C Vit. D Calories
Truite 203 92 100 600
Corned-beef 90 84 230 350
Burrito 270 80 512 250
Humburger 500 90 210 500
Besoins 2000 300 430
Notre objectif est de minimiser le nombre total de calories consommées : 600 XT+350XC B+250XBU R+
500XHBtout en satisfaisant les trois besoins nutritionnels en vitamines. Le programme linéaire résultant
s’écrit :
min 600 XT+350XC B+250XBU R+500XHB
s.t. 203 XT+90XC B+270XBU R+500XHB≥2000, (Besoins de Vit. A),
92XT+84XC B+80XBU R+90XHB≥300, (Besoins de Vit. C),
100XT+230XC B+512XBU R+210XHB≥430, (Besoins de Vit. D),
XT,XC B,XBU R ,XHB≥0
Définition 4.1: Forme canonique – Forme standard
On peut écrire un P .L. sous deux formes spéciales :
•Canonique
max
mincTX+c0
s.t. AX≤b(≥bsi min),
X≥0•Standard
max cTX+c0
s.t. AX=b,
X≥0Avec :
cTX=¡
c1··· cn¢
x1
...
xn

cTX+c0=c1x1+c2x2+···+ cnxn+c0
2728 Chapitre 4. Programmation linéaire
Remarque 9. Un P .L. général peut être formulé selon une forme standard ou canonique par la méthode suivante :
générale =⇒ standard il faut éliminer les contraintes d’inégalité et les variables sans contrainte de positivité.
— Si dT
iX≤biest une contrainte d’inégalité, alors créer une nouvelle variable ( d’écart ) siet remplacer l’in-
égalité dT
iX≤bipar dT
iX+si=biet s i≥0.
Si dT
iX≥bi, alors on peut écrire dT
iX−si=biet s i≥0.
— Si une variable x i≶0est de signe quelconque, alors créez deux nouvelles variables x+
iet x−
iet remplacez
xipartout par x+
i−x−
i, et ajoutez les contraintes de signe : x+
i≥0,x−
i≥0.
générale =⇒ canonique
— Si dT
iX=biest une contrainte d’égalité, alors remplacer cette égalité par une paire d’inégalités :
dT
iX≥biet−dT
iX≥ −bi
— Même chose que précédemment si la variable x i≶0.
Il est facile de voir que les problèmes qui en résultent sont équivalents aux problème d’origine. Pour l’algorithme
simplexe , nous utiliserons la forme standard .
On remarque aussi qu’en utilisant la relation min f(x)= − max¡
−f(x)¢
dans laquelle f (x)représente la fonction-
nelle linéaire à optimiser, on peut toujours se ramener à un problème de minimisation (ou de maximisation).
Example 4.2
Le P .L :max 5 x+4y
s.t. x≤6
1
4x+y≤6
3x+2y≤22
x,y≥0s’écrit sous forme standard :max 5 x1+4x2
s.t. x1+e1=6
1
4x1+x2+e2=6
3x1+2x2+e3=22
x1,x2,e1,e2,e3≥0
Donc (sous la forme matricielle) on a :
cT=¡
5 4 0 0 0¢
;A=
1 0 1 0 0
1
41 0 1 0
3 2 0 0 1
;X=
x1
x2
e1
e2
e3
et b=
6
6
22

4.1 La méthode simplexe
4.1.1 Solution de base admissible
On suppose que la matrice Adu programme linéaire est de type m×netde rang m(pourquoi !). Soit Bla
matrice carrée extraite de Aformée par les mcolonnes j1,j2,..., jmlinéairement indépendants de A(les vecteurs
de base). Alors, Best une matrice inversible. Ainsi si on pose xl=0 sil∉{j1,..., jm} etxjklak-ième composante de
B−1b. Alors, on a AX B=b. Si de plus XB≥0(i.e. chaque xi≥0), alors :
Xest une solution de base admissible (ou réalisable)
Dans l’exemple 4.2, la matrice extraite B=
1 0 0
0 1 0
0 0 1
est inversible et B−1b=
6
6
22
. Donc XB=
0
0
6
6
22
≥0, par suite
XBest une solution de base admissible. On appelle les variables xjklesvariables de base . Les autres variables xl
sont les variables hors-base .
Parfois, il n’est pas évident de trouver une solution de base admissible, comme le montre l’exercice suivant :H. SABRI 29
Exercice 4.1
Écrire le programme linéaire suivant sous forme standard et montrer qu’on n’a pas une solution de base
admissible. Résoudre le programme linéaire.
max −x+y
s.t. x+y≥1,
3x+2y=6,
x,y≥0
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux
Dans cette section, on suppose qu’on a déjà trouvé une solution de base admissible X(produite avec B=Im)
du programme linéaire ( P: max z=cTX+c0etb≥0pour garantir que 0est une solution de AX≤b).
La méthode du simplexe est une méthode itérative qui génère une séquence de solutions de base réalisable
(correspondant à différentes bases) et s’arrête finalement lorsqu’elle a trouvé une solution de base réalisable opti-
male. Remarquer qu’on peut toujours prendre c0=0.
Algorithme 10 : Algorithme du simplexe
Entrées : Un P .L. standard P(max) avec une solution de base réalisable
Output : La solution optimale (ou non)
1On commence à écrire le tableau initiale (avec les variables de base xj1,..., xjm)
VB x1 ... xn b
xj1 b1
... A...
xjm bm
c1 ... cn−c0
2Sicj≤0 (∀j:xjest hors base), alors solution optimale (STOP) // min ⇝cj≥0
3Trouver la colonne s(hors base) tel que cs=max©
cj:cj>0ª// min ⇝cs=min©
cj:cj<0ª
4Siai,s≤0∀i=1... m, alors pas de solution optimale (STOP)
5Min Ratio Test : trouver la ligne rtel que
br
ar,s=min
i=1...m½bi
ai,s:ai,s>0¾
6Appliquer la procédure de Gauss autour de pivot ar,s(ar,s⇝1 et on annule les coefficients situés sous et
sur le pivot dans la colonne s, par combinaisons de lignes) // Ne pas oublier la dernière ligne
7Remplacer (dans VB) la variable de base ( sortante ) située à la ligne rpar la variable ( entrante )xs
8Retourner à l’étape 2 // l'algorithme termine si le programme linéaire est non dégénéré
Remarque 10.
— La dernière ligne représente l’équation linéaire −z+c1x1+···+ cnxn= −c0.
— La valeur de la variable de base de V Bde la ligne k est égale à la valeur b k(de la ligne k).
— La solution optimale du problème est la valeur finale (dernière cellule) (×− 1).
— Si on n’a pas au départ B =Im(à l’aide des variables d’écart) alors, on ajoute les variables artificielles (et on
applique d’abord la phase I - voir section suivante).30 Chapitre 4. Programmation linéaire
Exercice 4.2
Soit le programme linéaire :
max 2 x1+x2
s.t. x1−x2≤3,
x1+2x2≤6,
−x1+2x2≤2,
x1,x2≥0
Rajouter les variables d’écart. Puis résoudre le problème par l’algorithme du simplexe.
Remarque 11. Vérifier le résultat de l’exercice précédent, par la méthode graphique.
4.1.3 Initialisation - Phase I du simplexe
Un programme linéaire est dit sous forme simpliciale si la matrice Acontient la matrice identité Imcomme
sous matrice. On suppose que le programme linéaire P, après la mise en forme AX=b, n’est pas simpliciale
(possible dans le cas de contraintes du type ≥ou du type =). Soit Bune matrice d’ordre mextraite de Ainversible
tel que B−1b≥0et soit XBla solution de base réalisable ( XB≥0etAX B=b), alors on peut changer l’équation
matricielle :
AX B=b
⇐⇒ (B−1A)XB=B−1b
⇐⇒ A∗XB=b∗
et la matrice A∗contient la matrice identité Imcomme matrice extraite ( B−1A=B−1(H|B)=¡
B−1H|Im¢
). Ainsi, on
peut appliquer directement l’algorithme 10 en remplaçant Apar A∗etbpar b∗. Cependant, cette méthode n’est
pas efficace, car il faut trouver une matrice extraite Bréalisable correspondante. Pour une matrice Ade type m×n,
il existe¡m
n¢
matrices extraites à tester !
L ’idée est d’ajouter des variables, dites artificielles w1,w2,..., wm, pour faire apparaître une forme simpliciale
du programme linéaire P: (AX=b). Mais, il faut que w1= ··· = wm=0. Donc, il faut minimiser d’abord le pro-
gramme linéaire P0suivant :
P0=min W=w1+···+ wm
s.t. (A|Im)×(x1...xnw1...wm)T=b
x1,..., xn,w1,..., wm ≥0
On exprime Wà l’aide des autres variables (hors base) et puis on applique l’algorithme du simplexe 10 pour P0
(phase I). À la fin, si on trouve que les wi=0, alors les variables de bases xj1,..., xjmforment une première base
admissible pour démarrer le simplexe pour le programme d’origine P.H. SABRI 31
Remarque 12. On ajoute la ligne de Z :c1 ... cn−c0dans le tableau du simplexe de P0(phase I) et on lui
applique les opérations élémentaire comme avec les autres lignes. À la fin de la phase I, on supprime les colonnes des
wiet la ligne de la fonction W . Finalement, on utilise ce tableau pour résoudre le problème initiale P.
Example 4.3
Soit le programme linéaire P:
min 6 x1+3x2
s.t. x1+x2≥1,
2x1−x2≥1,
3x2≤2,
x1,x2≥0sous forme standard (max)= = = = = = = = = = = = = = = = = = ⇒max Z= −6x1−3x2
s.t. x1+x2−e1=1,
2x1−x2−e2=1,
3x2+e3=2,
x1,x2,e1,e2,e3≥0
La matrice Aest :
A=x1 x2 e1 e2 e3

1 1 −1 0 0
2−1 0 −1 0
0 3 0 0 1
est par suite Pn’est pas sous forme simpliciale (il n’ ya pas de sous matrice I3). Donc on peut ajouter 2
variables artificielles pour construire le problème initiale P0:
max −w1−w2=3x1−e1−e2−2
s.t. x1+x2−e1+w1=1,
2x1−x2−e2+w2=1,
3x2+e3=2,
x1,x2,e1,e2,e3,w1,w2≥0dont le vecteur X=

0 x1
0 x2
0 e1
0 e2
2 e3
1 w1
1 w2est une solution de base réalisable.
Ainsi, on commence notre algorithme 10 pour le programme P0. Le tableau initial est :
x1 x2 e1 e2 e3 w1 w2 b

w1 1 1 −1 0 0 1 0 1
w2 2−1 0 −1 0 0 1 1
e3 0 3 0 0 1 0 0 2
W: 3 0 −1−1 0 0 0 2
Z:−6−3 0 0 0 0 0 0
Le pivot c’est a2,1donc x1est la variable entrante et w2est sortante. On obtient après pivotement le tableau :
L2←1
2L2− − − − − − − − →
L1←L1−L2
L4←L4−3L2
L5←L5+6L2x1 x2 e1 e2 e3 w1 w2 b

w1 03
2−11
20 1−1
21
2
x1 1−1
20−1
20 01
21
2
e3 0 3 0 0 1 0 0 2
W: 03
2−11
20 0−3
21
2
Z: 0 −6 0 −3 0 0 3 3
Le pivot est a1,2(Min ratio test =1
3). On obtient alors :32 Chapitre 4. Programmation linéaire
L1←2
3L1− − − − − − − − →
L2←L2+1
2L1
L3←L3−3L1
L4←L4−3
2L1
L5←L5+6L1x1 x2 e1 e2 e3 w1 w2 b


x2 0 1−2
31
302
3−1
31
3
x1 1 0−1
3−1
301
31
32
3
e3 0 0 2 −1 1 −2 1 1
W: 0 0 0 0 0 −1−1 0
Z: 0 0 −4−1 0 4 1 5
Ainsi, la phase I se termine avec W=0 et x1=2
3,x2=1
3,e3=1 et e1=e2=w1=w2=0. Le tableau pour la
phase II est donc :
x1 x2 e1 e2 e3 b


x2 0 1−2
31
301
3
x1 1 0−1
3−1
302
3
e3 0 0 2 −1 1 1
Z: 0 0 −4−1 0 5
On remarque donc que les cj≤0, donc (STOP) la solution est optimale et le max est −5. Ainsi la solution
optimale pour le programme P=min6 x1+3x2est−(−5)=5=6×2
3+3×1
3.
4.2 Dualité
SoitPun P .L. sous forme canonique. Le programme dualDdePest définit par :
P=max z=cTX
s.t. AX ≤ b
X≥ 0le dual est= = = = = = = ⇒D=min w=bTY
s.t. ATY≥ c
Y≥ 0
Le programme Pest dit primal . On remarque que si Ade type m×n, alors X∈RnetY∈Rmpour le dual.
Théorème 4.1 Théorème de dualité
Si un problème primal ou dual admet une solution, alors l’autre problème admet aussi une solution et on a :
max z=cTX =
s.t. AX ≤ b
X≥ 0min w=bTY
s.t. ATY≥ c
Y≥ 0
Exercice 4.3
Soit le problème suivant de type régime :
D=min w=340x1+2400 x2+560x3
s.t. x1+2x2+x3≥ 1200
x1+3x2+2x3≥ 1400
x1+x2+3x3≥ 1500
x1,x2,x3≥ 0
Écrire le programme primal PdeD. Résoudre le programme Pet déduire la valeur minimale de w, a-t-on
besoin de faire les deux phases du simplexe ?
7} A B oS



HOUSSEM SABRI
Graphes et Optimisation
2`emeannée
LISI  LSI
Institut Supérieur des Sciences Appliquées et de Technologie de Sousse
A.U. 2023-2024
28 novembre 2023Table des matières
1 Les graphes 3
1.1 Définitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.1 Graphes non orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.2 Graphes orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.2 Opérations et quelques types de graphes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.3 Représentation d’un graphe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.1 Listes d’adjacences (ou de succession) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.2 Matrices d’adjacence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.3.3 Matrice d’incidence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2 La connexité 11
2.1 Les chaînes et les cycles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.2 Graphe connexe, eulérien, hamiltonien . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.3 Arbres . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.3.1 Codage et décodage d’un arbre – Prüfer code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.3.2 Arbre couvrant de poids minimum – ACM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3 Les algorithmes de base 20
3.1 Parcours en profondeur (DFS) / largeur (BFS) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
3.2 Recherche des chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.1 Matrice d’adjacence et nombre de chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.2 Plus court chemin et l’algorithme de Dijkstra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
3.3 Problèmes d’ordonnancement et chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
3.3.1 Algorithmes de tri topologique et de chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . 25
4 Programmation linéaire 27
4.1 La méthode simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.1 Solution de base admissible . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux . . . . . . . . . . . . . . . . . . . . . . . . 29
4.1.3 Initialisation - Phase I du simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
4.2 Dualité . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
2CHAPITRE 1
Les graphes
L ’exemple classique pour introduire la théorie des graphes est le problème des ponts de Königsberg, étudié par
Euler en 1736. Quel itinéraire doit-on suivre pour traverser chaque pont exactement une fois? Une telle prome-
nade n’existe pas, et c’est Euler qui donna la solution de ce problème en caractérisant les graphes que l’on appelle
aujourd’hui eulériens .
A
B
Ce1 e2
e3 e4
De5
e6e7
FIGURE 1.1 – Les ponts de Königsberg
Les graphes introduisent une simplification : les régions se transforment en des "points" (aussi appelés noeuds
ousommet ), les ponts se transforment en des lignes (aussi appelées arêtes ouarcs ), et ce principe s’applique dès
lors qu’une relation existe entre des objets. Les graphes relèvent de la combinatoire plutôt que de la géométrie (les
intersections, les longueurs, et la forme des arêtes n’ont aucune importance, sauf en ce qui concerne la lisibilité de
la représentation).
1.1 Définitions
Dans la suite, il est toujours supposé que les graphes sont finis, sauf indication contraire.
1.1.1 Graphes non orientés
Définition 1.1: Graphe
Un graphe Gest un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V{2}des pairs non ordon-
nées de V.Vest l’ensemble des noeuds (Vertices en anglais) et Ec’est l’ensemble des arêtes de G(Edges en
anglais). Lorsque e={x,y} est une arête, on dit que x, y sont les extrémités de cette arête, que eest incidente
enxet en y. On joint x et y par un trait et on dit que x, y sont adjacents (ou voisins). On note aussi e=x you
encore e=(x,y) (attention , dans ce cas : ( x,y)=(y,x)).
SiGest un graphe alors, on note par V(G) l’ensemble de noeuds et par E(G) l’ensemble des arcs.
Remarque 1.
— Une arête e ={x,x}s’appelle boucle .
— Dans un graphe, il peut exister des arêtes parallèles (on parle donc de multigraphe ).
Dans l’exemple des ponts on a : e 1=e2=(A,B).
34 Chapitre 1. Les graphes
— Un graphe est dit simple s’il ne comporte ni arêtes multiples ni de boucles, c’est-à-dire chaque paire de nœuds
distincts est reliée par au plus une arête, ou encore E (G)⊆P2(G).
Dans la plupart des cas, les graphes sont considérés comme simples par défaut.
Définition 1.2: ordre – taille – degré
Soit G=(V,E) un graphe.
1. On appelle ordre d’un graphe noté v(G) le nombre de ses sommets :
v(G)= |V|
2. On appelle taille d’un graphe noté e(G) le nombre de ses arêtes :
e(G)= |E|
3. Le degré (ou valence) d’un sommet xnoté d(x) est le nombre d’arêtes contenant x. (Attention! Une
boucle sur un sommet compte double).
Si on note par Γ(x) l’ensemble des voisins de x, i.e.
Γ(x)={y∈V:x y∈E}
alors, siGest simple , on a :
d(x)= |Γ(x)|
Example 1.1 (Graphe complet)
Un graphe d’ordre nest dit complet noté Knsi chaque sommet du graphe est relié directement à tous les
autres sommets, i.e. E(Kn)=P2(V(Kn)).
Représenter graphiquement K3,K4,k5. Calculer la taille de K3,k4,...Kn.
Example 1.2 (Graphe biparti)
Un graphe G=(V,E) est dit biparti si son ensemble de sommets V=V1˙∪V2, i.e. peut être divisé en deux
sous-ensembles disjoints V1etV2tels que chaque arête ait une extrémité dans V1et l’autre dans V2.
Si∀x∈V1,∀y∈V2;x y∈E, alors Gest dit biparti complet noté Kn,moùn= |V1|etm= |V2|.
a1
 a2
 a3
 a4
b1
 b2
 b3
FIGURE 1.2 – Un graphe biparti
Théorème 1.1 Lemme des poignées de main – Handshaking lemma
Soit Gun graphe alors, on a :X
x∈V(G)d(x)=2e(G)
Dans ce théorème d(x) est le nombre de personnes à qui xserre la main et e(G) le nombre total de poignées
de mains.H. SABRI 5
Preuve.
•Méthode simple Il y en a d(x) arêtes en un sommet xfixé. Pour tout les sommets cela fait doncP
x∈V(G)d(x).
Mais avec cette manière chaque arête est comptée deux fois, une fois à chacune de ses extrémités, d’où le
résultat en divisant par 2.
•Preuve par double dénombrement On pose
Z={(x,e)∈V×E:x∈e}⊆V×E
et les deux projections :
p:Z→V
(x,e)7→xet q:Z→E
(x,e)7→e
L ’idée est de calculer |Z|de deux manières différentes. D’abord, on rappelle que si f:A→Best une fonction
quelconque, alors :X
b∈B|f−1[b]| = | A|
oùf−1[b] désigne l’image réciproque de { b} par f(pourquoi ˙S
b∈Bf−1[b] est une union disjointe ?).
Ainsi on obtient :
|Z| =X
x∈V|p−1[x]| =X
e∈E|q−1[e]|
Or,|p−1[x]| =d(x) et|q−1[e]| = |{x∈V:x∈e}| =2. Donc :
X
x∈Vd(x)=X
e∈E2=2|E|
Remarque 2.
— Un sommet de degré 0est appelé sommet isolé .
— Un graphe tel que : ∀x∈V,d(x)=kest dit graphe k-régulier .
— Le graphe complet K nest un graphe (n−1)-régulier .
Exercice 1.1
Montrer que dans un graphe le nombre de sommets d’ordre impairs est toujours pair. En particulier un
graphe k-régulier avec kimpaire est un graphe d’ordre pair.
Voici quelques exemples comme application :
1. Est-il possible de relier 15 ordinateurs en réseau de sorte que chacun soit relié à exactement 3 autres ?
2. Une ligue de football comprenant 11 clubs organise un tournoi. Pour gagner du temps on décide que chaque
équipe ne jouera que la moitié des matches possibles. Comment organiser le tournoi ?
Proposition 1.1
Soit G=(V,E) un graphe (simple) d’ordre n≥2. Alors :
∃u,v∈V,u̸=v:d(u)=d(v)
Preuve. Supposons le contraire, c’est-à-dire ∀u,v∈V;d(u)̸=d(v). Or dans un graphe (simple) on a toujours d(x)∈
{0,1,..., n−1}. Dans ce cas, puisque tous les nsommets ont des degrés distincts, alors il existe une bijection
{d(x):x∈V}←→ {0,1,..., n−1}
Donc, il existe un sommet uavec un degré 0, et un sommet vavec degré n−1, donc vest connecté à tous les autres
sommets du graphe, ce qui signifie que une peut pas être un sommet isolé, d’où une contradiction.6 Chapitre 1. Les graphes
1.1.2 Graphes orientés
Les arêtes d’un graphe peuvent être orientées, auquel cas une flèche indique la direction. De tels graphes sont
appelés des graphes orientés ou des digraphes , et une arête ( a,b) dans un tel graphe indique que cette arête est
dirigée de sommet avers b, i.e. ( a,b)=− →ab̸=(b,a)=− →ba. D’où la définition :
Définition 1.3: Graphe orienté - digraphe
Un graphe orienté G(ou− →G) est un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V2des pairs
ordonnées de V.Eest l’ensemble des arêtes (ou flèches, arcs) de G. Lorsque e=(x,y) est une arête, on dit
que xestl’origine (ou sommet initiale) et yl’extrémité (ou sommet terminale) de e, que eest sortant en x
et incident en y, et que yest un successeur de xtandis que xest un prédécesseur de y. On note l’arête e
par :
e=(x,y)=− →x y=x→y
De la même façon, une arête x→xest une boucle. On peut toujours supprimer les boucles pour obtenir des
digraphes simples. Voici l’exemple d’un digraphe G=(V,E) d’une fonction f:E→Eoù ( x,y) est un arc si et seule-
ment si y=f(x). On l’appelle digraphe fonctionnelle.
0
3
1214
11 568
169
4
2 1
713 10
15
FIGURE 1.3 – Le digraphe fonctionnelle Gfdex7→(x2+3) mod 17.
Comme dans les graphes on peut définir les degrés (entrant, sortant) d’un sommet dans un digraphe.
Définition 1.4: indegree - outdegree
Soit G=(V,E) un digraphe. Pour v∈V, on note par :
d+(v) le degré extérieur (sortant - outdegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité initiale.
d+(v)= |{v→ •}|
d−(v) le degré intérieur (entrant - indegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité finale.
d−(v)= |{• → v}|
On définit le degré : d(v)=d−(v)+d+(v).
Un sommet de degré entrant non nul et de degré sortant nul est appelé puits , tandis qu’un sommet de
degré entrant nul et de degré sortant non nul est appelé source ouracine .
Dans un graphe orienté, les voisins d’un sommet vsont soit des successeurs ou des prédécesseurs. On les notes
par :
Γ+(x)=Succ (x)={y∈V:x→y∈E} et Γ−(x)=Pr ed (x)={y∈V:y→x∈E}H. SABRI 7
Si le digraphe est simple (ni boucle ni arcs parallèles) on a :
d−(v)= |Γ−(v)|et d+(v)= |Γ+(v)|
Proposition 1.2
Soit Gun digraphe, alors :X
v∈Vd−(v)=X
v∈Vd+(v)= |E|
Preuve. On a
E=˙[
v∈V{• → v}=˙[
v∈V{v→ •}
=⇒ | E| =X
v∈V|{• → v}| =X
v∈V|{v→ •}| =⇒ | E| =X
v∈Vd−(v)=X
v∈Vd+(v)
1.2 Opérations et quelques types de graphes
Une opération sur les graphes permet de construire un nouveau graphe comme résultat de l’opération. Les
opérations courantes sur les graphes sont la suppression, la valuation, l’union, l’intersection et le produit cartésien.
Graphe valué
Tout d’abord, on peut vouloir attribuer des valeurs aux arcs ou arêtes pour tenir compte de contraintes : dis-
tance, coût ...
Définition 1.5: (di)graphe valué
Un (di)graphe valué G=(V,E,w) est un (di)graphe muni d’une application w:E→R. L ’application west
appelée application poids ou coût. On indique sur chaque arête son poids (ou son coût). On note w(x,y)
au lieu de w((x,y)). On convient (même que ceci n’a pas de sens!) que w(x,y)= +∞ si (x,y)∉E.
ab
c
d
ef53
43
3
335
81
FIGURE 1.4 – Un digraphe valué
/pythonPython code : -
Implémenter le digraphe valué précédent avec python. Indice – use chatGPT : how to build a weighted digraph with
python8 Chapitre 1. Les graphes
Sous graphes
Soit G=(V,E) un graphe (orienté ou non). Un sous graphe de Gest un graphe de la forme G′=(V′,E′) où
V′⊆V,E′⊆Etels que toute arête de E′a ses extrémités dans V′(ou encore G′est aussi un graphe). On a :
•Sous-graphe induit Un sous-graphe G′=(V′,E′) de G=(V,E) est appelé un sous-graphe induit deGsi :
∀x,y∈V′; (x,y)∈E′⇐⇒ (x,y)∈E
En d’autres termes, deux sommets de G′qui sont connectés dans G, sont également connectés dans G′.
•Sous-graphe couvrant Un sous-graphe couvrant G′deGcontient tous les sommets de G, i.e. V′=V.
•G−vSupprimer un sommet vd’un graphe Gconsiste à supprimer vet toutes ses arêtes incidentes. Le sous-
graphe obtenu de cette opération est noté G−v, i.e.
V′=V−{v} et E′=E−{(v,y): (v,y)∈E}
De manière similaire, une arête epeut être supprimée (resp. ajoutée) d’un graphe G, et le sous-graphe
résultant est représenté par G−e(resp. G+e). Notez que la suppression d’une arête ne retire pas de sommets
du graphe.
•G−V′=G[V′] On supprimer tous les sommets v∈V′du graphe Gavec les arêtes incidentes. Le sous-graphe
obtenu de cette opération est noté G[V′], i.e.
V(G[V′])=V−V′et E(G[V′])=E−{(v,y)∈E:v∈V′}
•Clique Une clique Cd’un graphe Gest un sous-ensemble des sommets de Gdont le sous-graphe induit G′=
(C,E′) est un graphe complet, en d’autres termes, deux sommets quelconques de la clique Csont toujours
adjacents.
•Stable Un stable – appelé aussi ensemble indépendant (independent set en anglais) est un ensemble de som-
mets deux à deux non adjacents. Donc le sous-graphe induit est sans arcs.
FIGURE 1.5 – L ’ensemble des sommets en bleu dans ce graphe est un stable maximal du graphe.
Note : -
Le problème décisionnel de la clique (c’est à dire existe t-il une clique de taille k) est NP-complet . De même la
recherche d’un stable de taille maximum dans un graphe est un problème NP-complet et difficile à approximer.
Exercice 1.2
Trouver un plus grand stable et une plus grande clique du graphe suivant :
8
4
62 7
3
1 5
Indice : vérifier le résultat avec networkx.find_cliques(G) et.maximum_independent_set(G) de python.H. SABRI 9
Opérations binaires
Union L ’union de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∪H=(VF,EF) dans lequel
VF=VG∪VH et EF=EG∪EH
Intersection L ’intersection de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∩H=(VF,EF)
dans lequel
VF=VG∩VH et EF=EG∩EH
1.3 Représentation d’un graphe
Il est important de savoir comment représenter les graphes au sein d’un ordinateur. Il ya plusieurs méthodes
selon la nature des traitements que l’on souhaite appliquer au graphe considéré.
1.3.1 Listes d’adjacences (ou de succession)
Soit Gun (di)graphe. On suppose que les sommets de Gsont numérotés de S1àSn. La représentation par listes
d’adjacence de Gconsiste en un tableau (ou des listes chainées) tel que la ligne i=1... ncorrespond au sommet Si
et comporte la liste des voisins/successeurs (ou des prédécesseurs) de ce sommet notée T[Si]. Les sommets dans
chaque liste d’adjacence sont généralement listés selon un ordre arbitraire.
1
2
345
FIGURE 1.6 – Un digraphe
La liste d’adjacence de digraphe 1.6 est donc :
1 2 3 4 5
2 3
3 4
4−
5 1 410 Chapitre 1. Les graphes
1.3.2 Matrices d’adjacence
Définition 1.6: Mat. Adjacence
Soit G=(V,E) un graphe (orienté) d’ordre n. On peut numéroter V={1,2,..., n}.La matrice d’adjacence
deGest la matrice carrée A=(ai j) d’ordre n, définie par :
ai j=(
1 si ( i j)∈E;
0 sinon.
Remarque 3.
1. Si le graphe G est non orienté et simple, alors la matrice A est symétrique avec des 0sur la diagonale. Pour un
digraphe simple, on a toujours des 0sur la diagonale, mais la matrice n’est pas symétrique en général.
2. Pour les multigraphes, il peut y avoir des termes diagonaux (pour les boucles) et s’il y a plusieurs arêtes de i à
j , le coefficient de la matrice a i jest le nombre d’arêtes de i à j .
3. Pour un (di)graphe valué G =(V,E,w), on pose :
ai j=(
w(i,j)si(i j)∈E ;
∞ sinon.
La matrice d’adjacence de la figure 1.4 est :

∞ 5∞ 4 3 ∞
∞ ∞ 3∞ 1∞
∞ ∞ ∞ ∞ ∞ 5
∞ ∞ 3∞ 3 3
∞ ∞ ∞ ∞ ∞ 8
∞ ∞ ∞ ∞ ∞ ∞

1.3.3 Matrice d’incidence
Définition 1.7: Mat. Incidence
Soit G=(V,E) un graphe (simple) d’ordre net de taille m. On pose V={v1,v2,..., vn} etE={e1,e2,..., em}.
La matrice d’incidence deGest la matrice de type n×m B=(bi j), définie par :
•Si G orienté
bi j=

1 si ej=vi→ • (i.e. viest l’extrémité initiale de ej) ;
−1 si ej= • → vi(i.e. viest l’extrémité terminale de ej) ;
0 sinon.
•Si G non-orienté
bi j=(
1 si viest une extrémité de ej;
0 sinon.
Exercice 1.3
1. Donner la matrice d’incidence du graphe 1.6.
2. Montrer le théorème 1.1 avec la matrice d’incidence.CHAPITRE 2
La connexité
Il est important de savoir si on peut suivre un chemin d’un sommet donné à un autre dans un graphe donné.
Cette propriété (de connexité) doit être maintenue dans différents types de réseaux.
2.1 Les chaînes et les cycles
Définition 2.1: (chaine – cycle) (chemin – circuit)
•Graphe non orienté
1. Une chaîne (walk ) reliant xày, notée µ(x,y), est définie par une suite finie d’arêtes consécutives,
reliant xày, ou encore une séquence de sommets (puisque non multigraphe)
µ(x,y)=<v0,v1,..., vk>
tels que v0=x,vk=yet (vi−1,vi)∈E(G) pour tout i=1... k. Six=yla chaîne est dite fermée .
Lalongueur du chaîne l(µ(x,y)) est le nombre d’arcs dans la chaîne, c’est-à-dire k.
2. Une chaîne élémentaire (a path ) si tous les sommets sont distincts. Une chaîne simple (a simple
walk, a trail ) est une chaîne ne passant pas deux fois par une même arête, c’est-à-dire dont toutes
les arêtes sont distinctes. Remarquer que : élémentaire =⇒ simple.
3. Un cycle v0v1...vnde longueur n≥3 est une chaîne simple fermée ( v0=vn) tel que les sommets
v0,v1,..., vn−1sont tous distincts. Un graphe sans cycle est dit acyclique .
•Graphe orienté
Dans un graphe orienté, on parlera de chemin au lieu de chaîne, et de circuit au lieu de cycle.
Example 2.1
abxcd xa est une chaîne simple et fermée (non cycle!) de longueur 6 (mais, c’est un graphe eulérien - voir
plus loin). Y a-t-il un cycle de longueur 3,4 ?
a b
x
c dÏ
Remarque 4.
1. On peut pivoter une chaine fermée (l’orienter de manière arbitraire) , i.e.
<v0,v1,v2,..., v0>=< vk,vk+1,..., v0,v1,..., vk>
1112 Chapitre 2. La connexité
2. Soient x ,y∈V . La distance de x à y est définie par :
d(x,y)=(
k si le plus court chemin/chaîne de x vers y est de longueur k
∞ sinon
On convient que d (x,x)=0.
3. Le diamètre du graphe la plus grande distance entre deux sommets.
L ’observation suivante, bien que très facile à prouver, sera utile.
Théorème 2.1
S’il existe une chaîne du sommet yau sommet zdans le graphe G, où y̸=z, alors il existe une chaîne élé-
mentaire ( path ) dans Gavec pour premier sommet yet pour dernier sommet z.
Preuve. Soit la chaine
W1=µ(y,z)=x0x1...xn; avec x0=yetxn=z.
Si les sommets x0,x1,..., xnsont tous distincts, alors W1est une chaîne élémentaire, et nous avons terminé. Sinon,
il existe xi=xj(i<j) et on écrit :
W2=x0x1...xixj+1...xn.
Alors, l(W2)<l(W1). Si W2ne contient aucun sommet répété, alors c’est la chaîne recherché. Sinon, par la même
procédure, il existe W3(y z−chaîne) tel que
l(W3)<l(W2)<l(W1).
Ce processus doit s’arrêter à un certain stade, car chaque chaîne est plus courte que la précédente et la longueur
ne peut jamais être inférieure à 1
1< ··· < l(Wk)< ··· < l(W3)<l(W2)<l(W1).
Ainsi, pour un certain k,Wkne peut pas être réduit en longueur. Donc, la chaîne Wkne contient aucun sommet
répété et est donc une y z−chaîne élémentaire (path).
Exercice 2.1
Dans le graphe suivant, construire un path à partir de la chaîne W=v2v3v4v5v6v4v2v8v1
v1
 v2
v3
v4
v5
v6
v7
 v8
 v9
Calculer d(v1,v7) et le diamètre de G.
/pythonpython : >>G = nx.Graph([(1, 2), (2, 3), (2, 4), ...]) >>nx.diameter(G)
Les cycles fournissent la caractérisation suivante pour les graphes bipartis .H. SABRI 13
Théorème 2.2
Un graphe est biparti si et seulement s’il ne contient aucun cycle de longueur impaire.
Preuve.
⇒On suppose que G=U˙∪Vest un graphe biparti. Soit W=< x1,x2,..., x2k+1,x1>un cycle de longueur im-
paire (2 k+1). Si x1∈U, alors
x1∈U=⇒ x2∈V=⇒ x3∈U=⇒ ··· =⇒ x2k+1∈U=⇒ x1∈V/exclamati⌢n-triangle
absurde, d’où le résultat.
⇐On suppose que Gest connexe (car l’union des composantes connexes bipartis est un graphe biparti). Soit
xun sommet de Get on pose :
U={y∈V(G):d(x,y) est paire} et V={z∈V(G):d(x,z) est impaire}
S’il existe y1,y2∈Utel que y1y2∈E(G), alors on a :
W1=<x,..., y1>est une chaîne de longueur paire =2k1
W2=<x,..., y2>est une chaîne de longueur paire =2k2
=⇒ W3=<x,..., y1,y2,..., x>est un cycle de longueur impaire =2k1+2k2+1/exclamati⌢n-triangle
Donc G=U˙∪Vest un graphe biparti.
Exercice 2.2
Vérifier si le graphe maison est un graphe biparti. Faire de même pour la grille G4,4.
maison grille
2.2 Graphe connexe, eulérien, hamiltonien
Définition 2.2: Graphe connexe
Un graphe est dit connexe si deux points peuvent toujours être joints par une chaîne, i.e.
∀x,y∈V(G),d(x,y)< ∞
— Une composante connexe d’un graphe est un sous-graphe induit maximal connexe.
— Un point d’articulation d’un graphe est un sommet dont la suppression augmente le nombre de
composantes connexes.
Par exemple, le graphe suivant :14 Chapitre 2. La connexité
a
 b
d
 c
e
f
 g
n’est pas connexe car il n’existe pas de chaîne entre les sommets aete. On a donc 2 composantes connexes. En
revanche, le sous-graphe induit par les sommets { a,b,c,d} est connexe dont aest le seul point d’articulation.
Remarque 5.
1. Un graphe connexe à n sommets possède au moins n −1arêtes ( faite une preuve par récurrence ).
2. L’algorithme de parcours en profondeur permet de déterminer si un graphe est connexe ou non.
3. Même définitions dans un graphe orienté . Graphe orienté (fortement) connexe et de composante connexe .
Définition 2.3: Graphe eulérien
— Une chaîne joignant deux sommets xetyest dite chaîne eulérienne si elle emprunte chaque arête
deGune et une seule fois. On parle de chemin eulérien dans le cas d’un graphe orienté.
— Un cycle eulérien est une chaîne eulérienne dont les extrémités coïncident. Un graphe qui admet
un cycle (resp. circuit) eulérien est dit graphe eulérien .
/flushedRemarquer qu’un cycle eulérien n’est pas forcément un cycle comme définit dans la définition 2.1
Si un graphe (ou multigraphe) Gpossède une chaîne eulérienne, alors soit Gpossède deux sommets impairs, le
début et la fin de cette chaîne, soit Gn’a aucun sommet impair, et la promenade d’Euler commence et se termine
au même point (cycle eulérien). Une autre condition nécessaire évidente est que Gdoit être connexe. Ces deux
conditions sont ensemble suffisantes.
Théorème 2.3 Euler
Soit Gun graphe (multigraphe) connexe.
— Si Gn’a pas de sommets impairs, alors il possède un cycle eulérien (commençant à n’importe quel
point).
i.e.∀x,d(x)≡0 mod 2 =⇒ Gest un graphe eulérien.
— Si Ga deux sommets impairs, alors il possède une chaîne eulérienne dont le début et la fin sont les
sommets impairs.
La réciproque est aussi vraie.
Preuve.
⇐On commence par la réciproque. S’il existe une chaîne eulérienne µ(x,y), alors on peut crée une arête fictive
e=(y,x) et par la suite on obtient un cycle eulérien. Donc il suffit de montrer que si Gadmet un cycle
eulérien alors tous les sommets sont de degré pair.
Soit W=< v1,v2,..., vn,v1>un cycle eulérien. Soit le sommet vjavec j̸=1, il est donc claire que chaque
fois vjapparaît dans W, il ya deux arcs distincts incidents en vj( (•,vj) et ( vj,•)). Comme toutes les arêtes
sont utilisées, on voit que d(vj) est pair. Même chose pour v1car on ajoute deux arcs ( v1,v2) et ( v1,vn).
⇒On suppose que tous les sommets sont de degré pair. Montrons que Gadmet un cycle eulérien. Puisque
tous les sommets sont de degré pair on peut construire d’abord une chaîne simple fermée (quelconque)
W1=<v1,v2,..., vk,v1>
SiW1contient chaque arête de G, alors c’est finis, c’est un cycle eulérien. Sinon (puisque Gest connexe), il
existe une arête e=(vi,c) qui n’est pas dans W1(avec visommet de W1). On pose le sous-graphe
G′=G−{ arêtes de W1}H. SABRI 15
Il est donc claire que les sommets de G′sont aussi de degré pair. Alors, par la même procédure on construit
une chaîne simple fermée dans G′de la forme : <vi,c,d,..., vi>et par la suite on insère cette chaîne dans
W1pour obtenir :
W2=<v1,v2,..., vi,c,d,..., vi,vi+1,..., vk,v1>
Sil(W2)< |E(G)|, on construit W3de longueur plus grand. Ainsi, on a :
l(W1)<l(W2)<l(W3)< ··· ≤ | E(G)|
Donc, nécessairement, il existe Wk(chaîne simple fermée de longueur |E(G)|) donc c’est un cycle eulérien.
Finalement , si∃a,b∈V(G):d(a)≡d(b)≡1 mod 2, et tous les autres sommets sont de degré pair, alors on
pose :
G′=G+{a,b}
et donc tous les sommets de G′sont de degré pair. Avec la construction précédente, il existe un cycle eulérien
dans G′:
W=<a,b,v1,..., a>
est donc la chaîne <b,v2,..., a>est une chaîne eulérienne dans G.
Algorithme 1 : Euler
Entrées : Gun graphe eulérien
Output : Un cycle eulérien W
/* On suppose que G est eulérien, i.e. les sommets sont de degré pair */
1Gaux←G;W←µ(v,v) une chaîne simple (quelconque) de G; // Initialisation
2tant que l(W)<e(G)faire
3 Gaux←G−{ arêtes de W} ;
4 Choisir ( x,c)∈E(Gaux) tel que x∈W;
5 L←< x,c,..., x>une chaîne simple de Gaux ;
6 Dans W, remplacer (juste ce) xpar la séquence L;
7fin
8retourner W;
Exercice 2.3
1. Montrer que le graphe de l’exercice 2.1 est un graphe eulérien et donner un cycle eulérien.
2. Tracer cette maison d’un seul trait.
Remarque 6. Le théorème d’Euler dans un graphe orienté connexe s’écrit :
Admet un circuit eulérien si, et seulement si, pour tout sommet, le degré entrant est égal au degré sortant.
∀v∈V(G),d+(v)=d−(v)
Admet un chemin eulérien de a vers b si, et seulement si,


d+(v)=d−(v) ;∀v̸=a,b,
d−(a)=d+(a)−1
d−(b)=d+(b)+116 Chapitre 2. La connexité
Définition 2.4: Graphe hamiltonien
Soit Gun graphe connexe d’ordre n. On appelle :
1. On appelle cycle hamiltonien deGun cycle passant (une et une seule fois) par chacun des sommets
deG. Un graphe est dit hamiltonien s’il possède un cycle hamiltonien.
2. Une chaîne hamiltonienne est une chaîne passant une et une seule fois par chacun des sommets de
G. Un graphe ne possédant que des chaînes hamiltoniennes est semi-hamiltonien .
3. Dans un digraphe, on change cycle par circuit et chaîne par chemin .
Remarque 7.
— Une chaîne hamiltonienne est une chaîne élémentaire de longueur n −1.
— Un graphe peut être eulérien, hamiltonien, les deux à la fois, ou aucun des deux.
— De nombreux problèmes concrets peuvent être formulés en termes de recherche de parcours hamiltoniens : pro-
blème du voyageur de commerce (chercher un cycle hamiltonien de longueur totale minimale), l’ ordonancement
de tâches .
— Le problème du chaîne hamiltonienne est un problème NP-complet .
Exercice 2.4
Donner un graphe (connexe, simple) qui soit :
1. hamiltonien et eulérien.
2. hamiltonien et non eulérien.
3. eulérien et non hamiltonien.
4. non hamiltonien et non eulérien.
Aucune condition nécessaire et suffisante adéquate n’est connue pour l’existence de cycles hamiltoniens. Le
résultat suivant constitue une condition suffisante utile.
Théorème 2.4 Ore
Soit Gun graphe simple d’ordre n≥3. Si pour toute paire { x,y} de sommets non adjacents, on a d(x)+d(y)≥
n, alors Gest hamiltonien.
Preuve. On suppose que le théorème est faux. Alors, il existe un graphe Gsimple d’ordre nnon hamiltonien tel que
d(u)+d(v)≥npour tout sommets non adjacents uetv. On prend Gun tel graphe d’ordre nde taille maximale qui
vérifie cette propriété (remarquer que le graphe complet Knest hamiltonien).
Soient uetvdeux sommets non adjacents de G. Par maximalité de G, le graphe G+uv(d’ordre n) doit être
hamiltonien. Donc il existe dans G+uvun cycle hamiltonien :
W=<u,x1,x2,..., xn−2,v,u>
u
x1
xi xi+1xn−2
v
... ...
Or, si uxi+1∈E(G) etv xi∈E(G) (les arcs en rouge), alors on peut construire dans Gle cycle hamiltonien :
<u,x1,x2,..., xi,v,xn−2,..., xi+1,u>H. SABRI 17
Ceci est absurde car Gest non hamiltonien. Donc si xi+1est un sommet voisin à u, alors le sommet xin’est pas
voisin de v:
xi+1∈Γ(u)=⇒ xi∉Γ(v)
Donc :
d(u)= |Γ(u)| =p=⇒ d(v)≤(n−1)−p
et par la suite
d(u)+d(v)≤n−1
ce qui absurde par hypothèse. Donc Gest hamiltonien.
Une conséquence immédiate est le théorème de Dirac :
Proposition 2.1 Dirac
Soit Gun graphe simple d’ordre n≥3. Si pour tout sommet xdeG, on a d(x)≥n
2, alors Gest hamiltonien.
2.3 Arbres
Définition 2.5: Arbres et forêts
On appelle arbre tout graphe (non orienté) connexe et acyclique . Les composantes connexes dans un
graphe acyclique sont des arbres et le graphe est dit forêt . Une feuille ou sommet pendant est un som-
met de degré 1.
Un forêt avec deux arbres
Un graphe Gest une arborescence s’il existe un sommet Rappelé racine deGtel que, pour tout sommet
SdeG, il existe un chemin et un seul de Rvers S. Donc, c’est un arbre orienté dans lequel on choisit un
sommet Rcomme racine et on dirige les arcs vers le sens sortant de la racine.
Remarque 8.
— Un graphe G d’ordre n est un arbre ssi G est sans cycle et possède n −1arêtes.
— Un graphe G d’ordre n est un arbre ssi G est connexe et possède n −1arêtes.
— G est un arbre si pour chaque paire u ,v de sommets distincts est reliée par une seule chaîne (donc chaîne
élémentaire d’après le théorème 2.1).
— Un arbre (ou forêt) est nécessairement un graphe simple.
Pour démontrer les remarques précédentes, il suffit de prouver le théorème suivant :
Théorème 2.5
Soit Gun graphe ayant marêtes, nsommets et pcomposantes connexes, on définit nu( G) :
ν(G)=m−n+p
Alors, on a :
1.ν(G)≥0.
2.ν(G)=0⇐⇒ Gest acyclique.18 Chapitre 2. La connexité
Preuve. Par récurrence sur la taille mdu graphe. Le résultat est évident pour m=0 et m=1. On suppose le résultat
est vrai pour les graphe de taille m, et montrons que ceci est vrai pour un graphe de taille m+1. Soit donc Gun
graphe d’ordre nde taille m+1 ayant pcomposantes connexes.
•On suppose que Gest un graphe acyclique. Soit uvune arête de Gdans la composante C. Si on supprime uv,
la composante Cse transforme en deux composantes connexes (sinon on a un cycle dans G). Par la suite,
le graphe G′=G−uvest un graphe acyclique d’ordre n, de taille met ayant p+1 composantes connexes.
Donc d’après l’hypothèse de récurrence :
ν(G′)=0=(m−1)−n+(p+1)=m−n+p=ν(G)
•Maintenant, si Gcontient un cycle Wdans la composante connexe C. Soit uvune arête de W, alors si on
supprime l’arête uv, la composante Creste connexe. Donc le graphe G′=G−uvest un graphe d’ordre nde
taille m−1 ayant pcomposantes connexes. Donc, d’après l’hypothèse de récurrence :
ν(G′)=(m−1)−n−p≥0
=⇒ν(G)=m−n−p≥1>0
D’où le résultat – car si ν(G)=0,Gne peut être que acyclique, sinon 0 =ν(G)≥1/exclamati⌢n-triangle
2.3.1 Codage et décodage d’un arbre – Prüfer code
Soit Tun arbre ayant nsommet numérotés {1,2,..., n}. Le codage de Prüfer représente l’arbre Tarbre de avec
une suite P=(x1,x2,x3,..., xn−2) de n−2 termes (les n° des sommets avec répétition possible). Une suite Pdonnée
correspond à un et un seul arbre numéroté. Voici les algorithmes de codage et de décodage.
Algorithme 2 : Codage de Prüfer
Entrées : Un arbre T
Output : Séquence de Prüfer P
1P←() ; // Initialisation de P comme séquence vide
2tant que v(T)>2faire
3 x←feuille de Tayant le n° minimum ; // donc d(x)=1
4 P←(P,s) où sest le seul (n°) sommet adjacent à x;
5 T←T−x;
6fin
7retourner P;
Example 2.2
Donner le code de Prüfer de l’arbre :
126 345
Indice : on trouve, P=(2,3,3,2)
Pour faire la réciproque, étant donnée une séquence P=(x1,x2,..., xn−2) où les xi∈{1,2,..., n}, on construit
l’arbre Tdont les sommets sont {1,2,..., n} avec l’algorithme suivant (le décodage) :H. SABRI 19
Algorithme 3 : Décodage de Prüfer
Entrées : Une séquence Pde taille n−2
Output : L ’arbre Tcorrespondante
1I←{1,2,..., n};
2T←graphe tel que V(T)=IetE(T)= ; ; // T graphe à n sommets isolés
3tant que P̸=()faire
4 i←min {x∈I:x∉P};
5 T←T+(i,P[1]) ; // ajouter l'arc (i,P[1])
6 P←P−P[1];I←I−{i};
7fin
8T←T+(a,b) ; // a,b sont les deux éléments restant dans I
9retourner T;
Example 2.3
Donner l’arbre dont le code de Prüfer est : P=(2,3,3,3)
Puisqu’il ya une bijection entre les arbres d’ordre net les suites Pde longueur n−2 à coefficients dans {1,2,..., n},
on déduit le théorème de Cayley :
Théorème 2.6 Formule de Cayley
Le nombre d’arbres que l’on peut construire sur n(n≥2) sommets numérotés est égal à nn−2.
2.3.2 Arbre couvrant de poids minimum – ACM
Soit Gun graphe (non orienté). Un arbre couvrant (spanning tree) TdeGest un sous graphe couvrant de G
tel que Test un arbre. Remarquer que, Gdoit être connexe, sinon un arbre couvrant de Gn’existe pas. Le nombre
des arbres couvrant de Gest noté a(G). Remarquer que a(Kn)=nn−2(le nombre de Cayley). Un problème algo-
rithmique classique est de trouver, dans un graphe valué , un arbre couvrant de poids minimal . On dispose de
plusieurs algorithmes (l’algorithme de Prim, l’algorithme de Kruskal ...).
Algorithme 4 : Kruskal
Entrées : Un graphe Gvalué d’ordre net de taille m
Output : Arbre (ou forêt) couvrant de poids minimum
1Numéroter les arêtes de Gpar poids minimum : w(e1)≤w(e2)≤ ··· ≤ w(em)
2T←graphe tel que V(T)=V(G) etE(T)= ; ; // T graphe à n sommets isolés
3k←0;
4tant que k<m et e (T)<n−1faire
5 siT+ek+1est acyclique alors
6 T←T+ek+1;
7 k←k+1;
8fin
9retourner T;
Appliquer l’algorithme de Kruskal dans le graphe suivant :
CHAPITRE 3
Les algorithmes de base
Beaucoup de problèmes sur les graphes nécessitent que l’on parcourt l’ensemble des sommets et des arcs. Par
exemple, pour vérifier que le graphe est connexe, chercher un sommet particulier, construire un arbre couvrant,
trouver un plus court chemin ...etc.
3.1 Parcours en profondeur (DFS) / largeur (BFS)
Une manière simple de tester si un graphe Gest connexe ou non est d’exécuter l’algorithme DFS ouBFS dans
Gen commençant par n’importe quel sommet et en enregistrant les sommets visités pendant l’exécution dans une
liste. Si la liste contient tous les sommets de G, alors Gest connexe. Une petite modification permet de donner les
composantes connexes de G. L ’algorithme DFS_Component suivant donne les composantes connexes de G. Il est
donné sous forme d’implémentation récursive.
Algorithme 5 : DFS_Component
Entrées : Un graphe G=(V,E)
Output : Les composantes connexes C=(C1,C2,..., Ck) de G.
1VisitedNodes ← ; ;
2k←0 ; // k est le nombre des composantes connexes
3pour chaque u∈Vfaire
4 siu∉VisitedNodes alors
5 k←k+1;
6 DFS( u);
7 fin
8fin
9retourner (C1,C2,..., Ck);
1Procedure DFS( u )
2 VisitedNodes ←VisitedNodes ∪{u};
3 Ck←Ck∪{u};
4 pour chaque x∈Γ(u)faire
5 six∉VisitedNodes alors
6 DFS( x);
7 fin
8 fin
Note : -
Il est possible de d’implémenter la procédure DFS itérativement à l’aide d’une pile LIFO (stack) contenant les
sommets à explorer : on désempile un sommet et on empile ses voisins non encore explorés.
20H. SABRI 21
Pseudocode :
stack . push ( root )
while stack . isEmpty ( ) = f a l s e do
node = stack . pop ( ) // so mark i t as v i s i t e d
for each x in node . childNodes do
i f x i s not v i s i t e d then
stack . push ( x )
. . .
endfor
endwhile
Example 3.1 (DFS )
Ici on empile (gris) les sommets les plus à droite, alors l’ordre des sommets visité (noir) est ( a,b,d,e,g,c,f).
Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b
 c
d
 e
f
g
a
b
 c
d e
f
ga
b
 c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g
L ’utilisation d’une file (FIFO) au lieu d’une pile transforme l’algorithme du parcours en profondeur en algo-
rithme de parcours en largeur ( BFS ). Avec BFS l’exemple précédent devient (en enfile le plus à gauche) :
Example 3.2 (BFS )
Ici, avec BFS, on enfile (gris) les sommets les plus à gauche d’abord, alors l’ordre des sommets visité (noir)
est ( a,b,d,e,g,c,f). Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b c
d
 e
f
g
a
b c
d
 e
f
ga
b c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g22 Chapitre 3. Les algorithmes de base
Exercice 3.1
1. Écrire la procédure BFS .
2. Utiliser DFS (ou BFS) pour la construction d’un arbre couvrant d’un graphe connexe. L ’appliquer
pour le graphe triangle.
3. Utiliser DFS pour écrire une procédure DFS_Cycle pour détecter un cycle dans un graphe.
On sait qu’un graphe orienté G=(V,E) est fortement connexe si pour chaque paire de sommets u,v∈V, il
existe un chemin de uàvet il existe un chemin de vàu. En d’autres termes, nous avons besoin d’une connectivité
dans les deux directions .
Une procédure pour tester si un graphe orienté est fortement connexe ou non peut être conçue avec l’idée
suivante. En partant d’un sommet arbitraire vdu graphe G, on exécute l’algorithme BFS ouDFS et l’on note les
sommets visités. Ensuite, on obtient la transposée de G,GT, en inversant la direction des arêtes de G, et l’on
exécute à nouveau l’algorithme BFS ou DFS à partir du sommet v. Si les sommets visités dans les deux cas sont
égaux à V, alors le graphe orienté est fortement connexe. Cette méthode est illustrée dans l’algorithme 6.
Algorithme 6 : Fortement_connexe
Entrées : Un graphe orienté G=(V,E)
Output : true siGest fortement connexe et false sinon
1X← ; ;
2Y← ; ;
3v←un sommet quelconque de V;
4X←DFS( G,v) ; // Enregistrez les sommets visités dans X
5GT←Gavec flèches inversées;
6Y←DFS( GT,v);
7siX=Y=Valors
8 retourner TRUE.
9sinon
10 retourner FALSE.
11fin
3.2 Recherche des chemins
3.2.1 Matrice d’adjacence et nombre de chemins
La puissance de la matrice d’adjacence Amontre qu’il y a des chemins (ou chaînes) de longueur kallant de xà
ycomme le montre le théorème suivant.
Théorème 3.1
Soit G=(V,E) un (di)graphe. On note V={1,2,..., n} et Asa matrice d’adjacence et Akla puissance k-ème
deA. Alors le terme d’indices i,jdeAkest le nombre de chemins (chaînes) de longueur kallant de iàj.
Preuve. Par récurrence sur k. Pour k=1 c’est clair. On suppose le résultat est vrai à l’ordre ket montrons qu’elle
est vrai pour k+1. Soit S=(si,j)=Ak. Si on a un chemin de iàjde longueur k+1, alors on va d’abord de ià un
sommet ravec kpas et puis de ràj. Or d’après l’hypothèse de récurrence on a si,rchemins possibles pour aller de
iàret finalement ar,jpas (1 ou 0) pour aller de ràj. Ainsi, le nombre totale possibles (i.e. tous les sommets r) est :
nX
r=1si,rar,j=³
Ak×A´
i,jH. SABRI 23
ce qui est bien le terme ( i,j) de la matrice Ak+1.
3.2.2 Plus court chemin et l’algorithme de Dijkstra
Dans cette partie on suppose que le (di)graphe G=(V,E,w) est valué positivement (i.e.∀e∈E,w(e)>0). Notre
objectif est de chercher un plus court chemin (i.e., un chemin de poids minimal ) d’un sommet ufixé à un sommet
quelconque de G.
Il est clair que l’on peut restreindre ce problème au cas d’un (di)graphe simple1. On suppose aussi que Gest
connexe (sinon, certains trajets sont impossibles). Il est aussi claire (d’après théorème 2.1), qu’un plus court chemin
est nécessairement un chemin élémentaire (path).
L ’algorithme de Dijkstra (1959) permet de calculer le plus court chemin entre un sommet particulier u(racine )
et tous les autres sommets. L ’algorithme fonctionne de la manière suivante :
Pour tout sommet vdeG, on associe une valeur T(v), initialisée à w(u,v) et une liste de sommets C(v) qui
correspond à un chemin de uàv. À la fin de l’algorithme, T(v) contient le poids minimal des chemins joignant uà
v(ou T(v)= ∞ siu↛v) et la liste C(v) réalise un tel chemin. Voici donc l’algorithme de Dijkstra :
Algorithme 7 : Algorithme de Dijkstra
Entrées : Un (di)graphe valué G=(V,E,w) et un sommet racine u
Output : Le coût minimum d’un chemin de uàv(∀v∈V) et un trajet pour chaque coût minimal obtenu
1∀v∈V,T(v)←w(u,v) etC(v)←(u,v); // Initialisation de T(v) et la liste C(v)
2X←{u};
3tant que X̸=Vfaire
4 Choisir v∈V−Xtel que ∀y∈V−X,T(v)≤T(y);
5 X←X∪{v};
6 pour chaque y∈V−Xfaire // Faire les mises à jours pour les autres sommets
7 siT(y)>T(v)+w(v,y)alors
8 T(y)←T(v)+w(v,y);
9 C(y)←[C(v),y]; // On ajoute à la liste C(v) l'élément y
10
11 fin
12 fin
13fin
Example 3.3
Voici une application de l’algorithme de Dijkstra au digraphe suivant. On prend Ecomme sommet racine.
EA
B
CD
FG
S5
4
21
12
2
34
4
215
7
1. En effet, passer par une boucle ne ferait qu’augmenter inutilement le poids de ce chemin. De même, si plusieurs arcs joignent deux
sommets, il suffit de conserver l’arc de poids minimal.24 Chapitre 3. Les algorithmes de base
Ainsi, pour l’initialisation, on a : X={E} et on a les valeurs :
v  E A B C D F G S
T(v) 0 5 4 2 ∞ ∞ ∞ ∞
C(v)(E,E) ( E,A) ( E,B) ( E,C) ( E,D) ( E,F) ( E,G) ( E,S)
Maintenant, on choisit (un seul choix) le sommet C, donc X={E,C}. Le tableau est mis à jour :
v  E A B  C D F G S
T(v) 0 5 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À l’étape suivante, on est forcé de choisir B. Ainsi, X={E,C,B} et la mise à jour est :
v  E A  B  C D F G S
T(v) 0 4 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À présent, on a le choix entre AetF. On choisit A. Donc X={E,C,B,A} et on a :
v  E  A  B  C D F G S
T(v) 0 4 3 2 6 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,B,A,D) ( E,C,F) ( E,C,G) ( E,S)
Puis, on prend le sommet F. D’où X={E,C,B,A,F} et :
v  E  A  B  C D  F G S
T(v) 0 4 3 2 5 4 5 11
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,S)
On prend Det on obtient X={E,C,B,A,F,D} et :
v  E  A  B  C  D  F G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Finalement, on prend Gpuis Set on voit que ceci ne change rien. D’où le tableau finale :
v  E  A  B  C  D  F  G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Ainsi le chemin minimum pour aller de EàSest de coût 10 et un trajet de coût minimal de EàSest : EC F DS .H. SABRI 25
3.3 Problèmes d’ordonnancement et chemin critique
Un problème d’ordonnancement peut-être représenté sous la forme d’un digraphe. Les sommets sont des évé-
nements (début et fin de la tâche) et les arcs des tâches, La longueur (ou poids) de chaque arc représente la durée
d’exécution de la tâche. Ainsi, la tâche correspondant à l’arc ( i,j) ne peut commencer que si toutes les tâches cor-
respondant à des arcs ( k,i) ont été complétées. On ajoute deux sommets pour le début (s) et de fin(t) du projet .
Le digraphe peut contenir des tâches fictives dedurée nulle afin de forcer certaines précédences (postériorité).
Ainsi, un réseau PERT est un digraphe valué G=(V,E,w,s,t) où la fonction poids (ou longueur) w:E→R+
etsle sommet source (début) et tle sommet puits (fin). Un chemin critique est un chemin de sàtdelongueur
maximale . S’il n’existe pas de chemin critique, le projet n’est pas réalisable (e.g. un circuit). Le temps minimal
requis pour l’exécution d’un projet réalisable est égal à la longueur d’un chemin critique. Les tâches figurant sur un
chemin critique sont aussi appelées critiques, ce qui s’explique par le fait que tout retard d’exécution d’une tâche
critique retarde d’autant l’exécution du projet.
3.3.1 Algorithmes de tri topologique et de chemin critique
Il faut d’abord numérotés les sommets de 1 à nde manière compatible au pré-ordre (rang) avec l’algorithme du
rang suivant (tri topologique) :
Algorithme 8 : Algorithme du rang
Entrées : Un digraphe G=(V,E) sans circuit
Output : Le rang r(v) de chaque sommet v∈Vde G
1r←0;X←V;
2R←{v∈X:Γ−
X(v)= ;} ; // l'ensemble des sommets de X sans prédécesseur dans X
3tant que X̸= ; faire
4 r(v)←rpour chaque sommet v∈R;
5 X←X−R;
6 R←l’ensemble des sommets de Xsans prédécesseur dans X;
7 r←r+1;
8fin
On supposera dorénavant que les sommets ont déjà été numérotés de 1 à nde manière compatible avec leurs
rangs, c’est-à-dire que r(j)>r(i) implique j>i(donc 1 =setn=t). Enfin, on supposera éliminés les arcs paral-
lèles par l’introduction de tâches fictives de durée nulle .
Pour un sommet i, on note tiledébut au plus tôt des tâches correspondant aux arcs i→jet par Tilafin au
plus tard des tâches correspondant aux arcs j→i.
Algorithme 9 : Algorithme du chemin critique
Entrées : Un digraphe G=(V,E) sans circuit trié topologiquement
Output : La durée du chemin critique et les dates ti,Ti
1t1←0;
2pour j=2···nfaire // Calcul des dates de début au plus tôt  récurrence en avançant
3 tj←max i∈Γ−(j){ti+w(i,j)}
4fin
5Tn←tn;
6pour j=n−1···1faire // Calcul des dates de fin au plus tard  récurrence en reculant
7 Tj←min i∈Γ+(j){Ti−w(j,i)}
8fin26 Chapitre 3. Les algorithmes de base
Définition 3.1
— Un sommet iest critique si ti=Ti.
— Un arc ( i,j) est critique les sommets ietjsont critiques ettj−ti=w(i,j).
— Un chemin critique est un chemin de 1 à nn’utilisant que des arcs critiques.
— La durée du chemin critique est donnée par Tn(ou par tn). Elle correspond à la durée minimale du
projet .
Example 3.4
L ’application de l’algorithme du chemin critique au digraphe suivant (trié topologiquement) est :
1 23
45
6B
9A
3
C
5D
8
E
4
F7G
20
H6I5
=⇒
 1
0,02
9,933,16
4
16,23513,24
6
29,29B
9A
3
C
5D
8
E
4
F7G
20
H6I5
Les tâches critiques sont BetG. La durée totale minimale du projet est donc 29.
Exercice 3.2
Les tâches ( durée et précédences ) pour la construction d’un entrepôt sont données dans le tableau suivant :
Tâches Nature Précédences Durée (jours)
A Acceptation des plans par le propriétaire – 4
B Préparation du terrain – 2
C Commande des matériaux A 1
D Creusage des fondations A, B 1
E Commande des portes et fenêtres A 2
F Livraison des matériaux C 2
G Coulage des fondations D, F 2
H Livraison des portes et fenêtres E 10
I Pose des murs, de la charpente et du toit G 4
J Mise en place des portes et fenêtres H, I 1
1. Représentez le graphe des précédences de ce projet (trié topologiquement).
2. Déterminez une durée totale minimale en exhibant un chemin critique dans ce graphe.CHAPITRE 4
Programmation linéaire
La programmation linéaire est le processus de minimiser ou maximiser une fonction objective linéaire sou-
mise à un nombre fini de contraintes d’égalités et d’inégalités linéaires.
La programmation linéaire a de nombreuses applications dans le domaine de l’informatique théorique. Elle
peut être utilisée pour résoudre de nombreux problèmes combinatoires variés, tels que la recherche de flot maxi-
mum dans un réseau, la recherche d’un couplage maximal dans un graphe et la coloration d’un graphe parfait.
Example 4.1 (Problème de régime)
On suppose qu’on a quatre plats : de la truite ( XT), un sandwich au corned-beef ( XC B), un burrito ( XBU R )
et un hamburger ( XHB). Le tableau suivant répertorie la valeur nutritionnelle de chaque plat (vitamines et
calories) et notre besoin journalier des vitamines.
Vit. A Vit. C Vit. D Calories
Truite 203 92 100 600
Corned-beef 90 84 230 350
Burrito 270 80 512 250
Humburger 500 90 210 500
Besoins 2000 300 430
Notre objectif est de minimiser le nombre total de calories consommées : 600 XT+350XC B+250XBU R+
500XHBtout en satisfaisant les trois besoins nutritionnels en vitamines. Le programme linéaire résultant
s’écrit :
min 600 XT+350XC B+250XBU R+500XHB
s.t. 203 XT+90XC B+270XBU R+500XHB≥2000, (Besoins de Vit. A),
92XT+84XC B+80XBU R+90XHB≥300, (Besoins de Vit. C),
100XT+230XC B+512XBU R+210XHB≥430, (Besoins de Vit. D),
XT,XC B,XBU R ,XHB≥0
Définition 4.1: Forme canonique – Forme standard
On peut écrire un P .L. sous deux formes spéciales :
•Canonique
max
mincTX+c0
s.t. AX≤b(≥bsi min),
X≥0•Standard
max cTX+c0
s.t. AX=b,
X≥0Avec :
cTX=¡
c1··· cn¢
x1
...
xn

cTX+c0=c1x1+c2x2+···+ cnxn+c0
2728 Chapitre 4. Programmation linéaire
Remarque 9. Un P .L. général peut être formulé selon une forme standard ou canonique par la méthode suivante :
générale =⇒ standard il faut éliminer les contraintes d’inégalité et les variables sans contrainte de positivité.
— Si dT
iX≤biest une contrainte d’inégalité, alors créer une nouvelle variable ( d’écart ) siet remplacer l’in-
égalité dT
iX≤bipar dT
iX+si=biet s i≥0.
Si dT
iX≥bi, alors on peut écrire dT
iX−si=biet s i≥0.
— Si une variable x i≶0est de signe quelconque, alors créez deux nouvelles variables x+
iet x−
iet remplacez
xipartout par x+
i−x−
i, et ajoutez les contraintes de signe : x+
i≥0,x−
i≥0.
générale =⇒ canonique
— Si dT
iX=biest une contrainte d’égalité, alors remplacer cette égalité par une paire d’inégalités :
dT
iX≥biet−dT
iX≥ −bi
— Même chose que précédemment si la variable x i≶0.
Il est facile de voir que les problèmes qui en résultent sont équivalents aux problème d’origine. Pour l’algorithme
simplexe , nous utiliserons la forme standard .
On remarque aussi qu’en utilisant la relation min f(x)= − max¡
−f(x)¢
dans laquelle f (x)représente la fonction-
nelle linéaire à optimiser, on peut toujours se ramener à un problème de minimisation (ou de maximisation).
Example 4.2
Le P .L :max 5 x+4y
s.t. x≤6
1
4x+y≤6
3x+2y≤22
x,y≥0s’écrit sous forme standard :max 5 x1+4x2
s.t. x1+e1=6
1
4x1+x2+e2=6
3x1+2x2+e3=22
x1,x2,e1,e2,e3≥0
Donc (sous la forme matricielle) on a :
cT=¡
5 4 0 0 0¢
;A=
1 0 1 0 0
1
41 0 1 0
3 2 0 0 1
;X=
x1
x2
e1
e2
e3
et b=
6
6
22

4.1 La méthode simplexe
4.1.1 Solution de base admissible
On suppose que la matrice Adu programme linéaire est de type m×netde rang m(pourquoi !). Soit Bla
matrice carrée extraite de Aformée par les mcolonnes j1,j2,..., jmlinéairement indépendants de A(les vecteurs
de base). Alors, Best une matrice inversible. Ainsi si on pose xl=0 sil∉{j1,..., jm} etxjklak-ième composante de
B−1b. Alors, on a AX B=b. Si de plus XB≥0(i.e. chaque xi≥0), alors :
Xest une solution de base admissible (ou réalisable)
Dans l’exemple 4.2, la matrice extraite B=
1 0 0
0 1 0
0 0 1
est inversible et B−1b=
6
6
22
. Donc XB=
0
0
6
6
22
≥0, par suite
XBest une solution de base admissible. On appelle les variables xjklesvariables de base . Les autres variables xl
sont les variables hors-base .
Parfois, il n’est pas évident de trouver une solution de base admissible, comme le montre l’exercice suivant :H. SABRI 29
Exercice 4.1
Écrire le programme linéaire suivant sous forme standard et montrer qu’on n’a pas une solution de base
admissible. Résoudre le programme linéaire.
max −x+y
s.t. x+y≥1,
3x+2y=6,
x,y≥0
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux
Dans cette section, on suppose qu’on a déjà trouvé une solution de base admissible X(produite avec B=Im)
du programme linéaire ( P: max z=cTX+c0etb≥0pour garantir que 0est une solution de AX≤b).
La méthode du simplexe est une méthode itérative qui génère une séquence de solutions de base réalisable
(correspondant à différentes bases) et s’arrête finalement lorsqu’elle a trouvé une solution de base réalisable opti-
male. Remarquer qu’on peut toujours prendre c0=0.
Algorithme 10 : Algorithme du simplexe
Entrées : Un P .L. standard P(max) avec une solution de base réalisable
Output : La solution optimale (ou non)
1On commence à écrire le tableau initiale (avec les variables de base xj1,..., xjm)
VB x1 ... xn b
xj1 b1
... A...
xjm bm
c1 ... cn−c0
2Sicj≤0 (∀j:xjest hors base), alors solution optimale (STOP) // min ⇝cj≥0
3Trouver la colonne s(hors base) tel que cs=max©
cj:cj>0ª// min ⇝cs=min©
cj:cj<0ª
4Siai,s≤0∀i=1... m, alors pas de solution optimale (STOP)
5Min Ratio Test : trouver la ligne rtel que
br
ar,s=min
i=1...m½bi
ai,s:ai,s>0¾
6Appliquer la procédure de Gauss autour de pivot ar,s(ar,s⇝1 et on annule les coefficients situés sous et
sur le pivot dans la colonne s, par combinaisons de lignes) // Ne pas oublier la dernière ligne
7Remplacer (dans VB) la variable de base ( sortante ) située à la ligne rpar la variable ( entrante )xs
8Retourner à l’étape 2 // l'algorithme termine si le programme linéaire est non dégénéré
Remarque 10.
— La dernière ligne représente l’équation linéaire −z+c1x1+···+ cnxn= −c0.
— La valeur de la variable de base de V Bde la ligne k est égale à la valeur b k(de la ligne k).
— La solution optimale du problème est la valeur finale (dernière cellule) (×− 1).
— Si on n’a pas au départ B =Im(à l’aide des variables d’écart) alors, on ajoute les variables artificielles (et on
applique d’abord la phase I - voir section suivante).30 Chapitre 4. Programmation linéaire
Exercice 4.2
Soit le programme linéaire :
max 2 x1+x2
s.t. x1−x2≤3,
x1+2x2≤6,
−x1+2x2≤2,
x1,x2≥0
Rajouter les variables d’écart. Puis résoudre le problème par l’algorithme du simplexe.
Remarque 11. Vérifier le résultat de l’exercice précédent, par la méthode graphique.
4.1.3 Initialisation - Phase I du simplexe
Un programme linéaire est dit sous forme simpliciale si la matrice Acontient la matrice identité Imcomme
sous matrice. On suppose que le programme linéaire P, après la mise en forme AX=b, n’est pas simpliciale
(possible dans le cas de contraintes du type ≥ou du type =). Soit Bune matrice d’ordre mextraite de Ainversible
tel que B−1b≥0et soit XBla solution de base réalisable ( XB≥0etAX B=b), alors on peut changer l’équation
matricielle :
AX B=b
⇐⇒ (B−1A)XB=B−1b
⇐⇒ A∗XB=b∗
et la matrice A∗contient la matrice identité Imcomme matrice extraite ( B−1A=B−1(H|B)=¡
B−1H|Im¢
). Ainsi, on
peut appliquer directement l’algorithme 10 en remplaçant Apar A∗etbpar b∗. Cependant, cette méthode n’est
pas efficace, car il faut trouver une matrice extraite Bréalisable correspondante. Pour une matrice Ade type m×n,
il existe¡m
n¢
matrices extraites à tester !
L ’idée est d’ajouter des variables, dites artificielles w1,w2,..., wm, pour faire apparaître une forme simpliciale
du programme linéaire P: (AX=b). Mais, il faut que w1= ··· = wm=0. Donc, il faut minimiser d’abord le pro-
gramme linéaire P0suivant :
P0=min W=w1+···+ wm
s.t. (A|Im)×(x1...xnw1...wm)T=b
x1,..., xn,w1,..., wm ≥0
On exprime Wà l’aide des autres variables (hors base) et puis on applique l’algorithme du simplexe 10 pour P0
(phase I). À la fin, si on trouve que les wi=0, alors les variables de bases xj1,..., xjmforment une première base
admissible pour démarrer le simplexe pour le programme d’origine P.H. SABRI 31
Remarque 12. On ajoute la ligne de Z :c1 ... cn−c0dans le tableau du simplexe de P0(phase I) et on lui
applique les opérations élémentaire comme avec les autres lignes. À la fin de la phase I, on supprime les colonnes des
wiet la ligne de la fonction W . Finalement, on utilise ce tableau pour résoudre le problème initiale P.
Example 4.3
Soit le programme linéaire P:
min 6 x1+3x2
s.t. x1+x2≥1,
2x1−x2≥1,
3x2≤2,
x1,x2≥0sous forme standard (max)= = = = = = = = = = = = = = = = = = ⇒max Z= −6x1−3x2
s.t. x1+x2−e1=1,
2x1−x2−e2=1,
3x2+e3=2,
x1,x2,e1,e2,e3≥0
La matrice Aest :
A=x1 x2 e1 e2 e3

1 1 −1 0 0
2−1 0 −1 0
0 3 0 0 1
est par suite Pn’est pas sous forme simpliciale (il n’ ya pas de sous matrice I3). Donc on peut ajouter 2
variables artificielles pour construire le problème initiale P0:
max −w1−w2=3x1−e1−e2−2
s.t. x1+x2−e1+w1=1,
2x1−x2−e2+w2=1,
3x2+e3=2,
x1,x2,e1,e2,e3,w1,w2≥0dont le vecteur X=

0 x1
0 x2
0 e1
0 e2
2 e3
1 w1
1 w2est une solution de base réalisable.
Ainsi, on commence notre algorithme 10 pour le programme P0. Le tableau initial est :
x1 x2 e1 e2 e3 w1 w2 b

w1 1 1 −1 0 0 1 0 1
w2 2−1 0 −1 0 0 1 1
e3 0 3 0 0 1 0 0 2
W: 3 0 −1−1 0 0 0 2
Z:−6−3 0 0 0 0 0 0
Le pivot c’est a2,1donc x1est la variable entrante et w2est sortante. On obtient après pivotement le tableau :
L2←1
2L2− − − − − − − − →
L1←L1−L2
L4←L4−3L2
L5←L5+6L2x1 x2 e1 e2 e3 w1 w2 b

w1 03
2−11
20 1−1
21
2
x1 1−1
20−1
20 01
21
2
e3 0 3 0 0 1 0 0 2
W: 03
2−11
20 0−3
21
2
Z: 0 −6 0 −3 0 0 3 3
Le pivot est a1,2(Min ratio test =1
3). On obtient alors :32 Chapitre 4. Programmation linéaire
L1←2
3L1− − − − − − − − →
L2←L2+1
2L1
L3←L3−3L1
L4←L4−3
2L1
L5←L5+6L1x1 x2 e1 e2 e3 w1 w2 b


x2 0 1−2
31
302
3−1
31
3
x1 1 0−1
3−1
301
31
32
3
e3 0 0 2 −1 1 −2 1 1
W: 0 0 0 0 0 −1−1 0
Z: 0 0 −4−1 0 4 1 5
Ainsi, la phase I se termine avec W=0 et x1=2
3,x2=1
3,e3=1 et e1=e2=w1=w2=0. Le tableau pour la
phase II est donc :
x1 x2 e1 e2 e3 b


x2 0 1−2
31
301
3
x1 1 0−1
3−1
302
3
e3 0 0 2 −1 1 1
Z: 0 0 −4−1 0 5
On remarque donc que les cj≤0, donc (STOP) la solution est optimale et le max est −5. Ainsi la solution
optimale pour le programme P=min6 x1+3x2est−(−5)=5=6×2
3+3×1
3.
4.2 Dualité
SoitPun P .L. sous forme canonique. Le programme dualDdePest définit par :
P=max z=cTX
s.t. AX ≤ b
X≥ 0le dual est= = = = = = = ⇒D=min w=bTY
s.t. ATY≥ c
Y≥ 0
Le programme Pest dit primal . On remarque que si Ade type m×n, alors X∈RnetY∈Rmpour le dual.
Théorème 4.1 Théorème de dualité
Si un problème primal ou dual admet une solution, alors l’autre problème admet aussi une solution et on a :
max z=cTX =
s.t. AX ≤ b
X≥ 0min w=bTY
s.t. ATY≥ c
Y≥ 0
Exercice 4.3
Soit le problème suivant de type régime :
D=min w=340x1+2400 x2+560x3
s.t. x1+2x2+x3≥ 1200
x1+3x2+2x3≥ 1400
x1+x2+3x3≥ 1500
x1,x2,x3≥ 0
Écrire le programme primal PdeD. Résoudre le programme Pet déduire la valeur minimale de w, a-t-on
besoin de faire les deux phases du simplexe ?
7} A B oS



HOUSSEM SABRI
Graphes et Optimisation
2`emeannée
LISI  LSI
Institut Supérieur des Sciences Appliquées et de Technologie de Sousse
A.U. 2023-2024
28 novembre 2023Table des matières
1 Les graphes 3
1.1 Définitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.1 Graphes non orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.2 Graphes orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.2 Opérations et quelques types de graphes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.3 Représentation d’un graphe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.1 Listes d’adjacences (ou de succession) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.2 Matrices d’adjacence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.3.3 Matrice d’incidence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2 La connexité 11
2.1 Les chaînes et les cycles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.2 Graphe connexe, eulérien, hamiltonien . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.3 Arbres . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.3.1 Codage et décodage d’un arbre – Prüfer code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.3.2 Arbre couvrant de poids minimum – ACM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3 Les algorithmes de base 20
3.1 Parcours en profondeur (DFS) / largeur (BFS) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
3.2 Recherche des chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.1 Matrice d’adjacence et nombre de chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.2 Plus court chemin et l’algorithme de Dijkstra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
3.3 Problèmes d’ordonnancement et chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
3.3.1 Algorithmes de tri topologique et de chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . 25
4 Programmation linéaire 27
4.1 La méthode simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.1 Solution de base admissible . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux . . . . . . . . . . . . . . . . . . . . . . . . 29
4.1.3 Initialisation - Phase I du simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
4.2 Dualité . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
2CHAPITRE 1
Les graphes
L ’exemple classique pour introduire la théorie des graphes est le problème des ponts de Königsberg, étudié par
Euler en 1736. Quel itinéraire doit-on suivre pour traverser chaque pont exactement une fois? Une telle prome-
nade n’existe pas, et c’est Euler qui donna la solution de ce problème en caractérisant les graphes que l’on appelle
aujourd’hui eulériens .
A
B
Ce1 e2
e3 e4
De5
e6e7
FIGURE 1.1 – Les ponts de Königsberg
Les graphes introduisent une simplification : les régions se transforment en des "points" (aussi appelés noeuds
ousommet ), les ponts se transforment en des lignes (aussi appelées arêtes ouarcs ), et ce principe s’applique dès
lors qu’une relation existe entre des objets. Les graphes relèvent de la combinatoire plutôt que de la géométrie (les
intersections, les longueurs, et la forme des arêtes n’ont aucune importance, sauf en ce qui concerne la lisibilité de
la représentation).
1.1 Définitions
Dans la suite, il est toujours supposé que les graphes sont finis, sauf indication contraire.
1.1.1 Graphes non orientés
Définition 1.1: Graphe
Un graphe Gest un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V{2}des pairs non ordon-
nées de V.Vest l’ensemble des noeuds (Vertices en anglais) et Ec’est l’ensemble des arêtes de G(Edges en
anglais). Lorsque e={x,y} est une arête, on dit que x, y sont les extrémités de cette arête, que eest incidente
enxet en y. On joint x et y par un trait et on dit que x, y sont adjacents (ou voisins). On note aussi e=x you
encore e=(x,y) (attention , dans ce cas : ( x,y)=(y,x)).
SiGest un graphe alors, on note par V(G) l’ensemble de noeuds et par E(G) l’ensemble des arcs.
Remarque 1.
— Une arête e ={x,x}s’appelle boucle .
— Dans un graphe, il peut exister des arêtes parallèles (on parle donc de multigraphe ).
Dans l’exemple des ponts on a : e 1=e2=(A,B).
34 Chapitre 1. Les graphes
— Un graphe est dit simple s’il ne comporte ni arêtes multiples ni de boucles, c’est-à-dire chaque paire de nœuds
distincts est reliée par au plus une arête, ou encore E (G)⊆P2(G).
Dans la plupart des cas, les graphes sont considérés comme simples par défaut.
Définition 1.2: ordre – taille – degré
Soit G=(V,E) un graphe.
1. On appelle ordre d’un graphe noté v(G) le nombre de ses sommets :
v(G)= |V|
2. On appelle taille d’un graphe noté e(G) le nombre de ses arêtes :
e(G)= |E|
3. Le degré (ou valence) d’un sommet xnoté d(x) est le nombre d’arêtes contenant x. (Attention! Une
boucle sur un sommet compte double).
Si on note par Γ(x) l’ensemble des voisins de x, i.e.
Γ(x)={y∈V:x y∈E}
alors, siGest simple , on a :
d(x)= |Γ(x)|
Example 1.1 (Graphe complet)
Un graphe d’ordre nest dit complet noté Knsi chaque sommet du graphe est relié directement à tous les
autres sommets, i.e. E(Kn)=P2(V(Kn)).
Représenter graphiquement K3,K4,k5. Calculer la taille de K3,k4,...Kn.
Example 1.2 (Graphe biparti)
Un graphe G=(V,E) est dit biparti si son ensemble de sommets V=V1˙∪V2, i.e. peut être divisé en deux
sous-ensembles disjoints V1etV2tels que chaque arête ait une extrémité dans V1et l’autre dans V2.
Si∀x∈V1,∀y∈V2;x y∈E, alors Gest dit biparti complet noté Kn,moùn= |V1|etm= |V2|.
a1
 a2
 a3
 a4
b1
 b2
 b3
FIGURE 1.2 – Un graphe biparti
Théorème 1.1 Lemme des poignées de main – Handshaking lemma
Soit Gun graphe alors, on a :X
x∈V(G)d(x)=2e(G)
Dans ce théorème d(x) est le nombre de personnes à qui xserre la main et e(G) le nombre total de poignées
de mains.H. SABRI 5
Preuve.
•Méthode simple Il y en a d(x) arêtes en un sommet xfixé. Pour tout les sommets cela fait doncP
x∈V(G)d(x).
Mais avec cette manière chaque arête est comptée deux fois, une fois à chacune de ses extrémités, d’où le
résultat en divisant par 2.
•Preuve par double dénombrement On pose
Z={(x,e)∈V×E:x∈e}⊆V×E
et les deux projections :
p:Z→V
(x,e)7→xet q:Z→E
(x,e)7→e
L ’idée est de calculer |Z|de deux manières différentes. D’abord, on rappelle que si f:A→Best une fonction
quelconque, alors :X
b∈B|f−1[b]| = | A|
oùf−1[b] désigne l’image réciproque de { b} par f(pourquoi ˙S
b∈Bf−1[b] est une union disjointe ?).
Ainsi on obtient :
|Z| =X
x∈V|p−1[x]| =X
e∈E|q−1[e]|
Or,|p−1[x]| =d(x) et|q−1[e]| = |{x∈V:x∈e}| =2. Donc :
X
x∈Vd(x)=X
e∈E2=2|E|
Remarque 2.
— Un sommet de degré 0est appelé sommet isolé .
— Un graphe tel que : ∀x∈V,d(x)=kest dit graphe k-régulier .
— Le graphe complet K nest un graphe (n−1)-régulier .
Exercice 1.1
Montrer que dans un graphe le nombre de sommets d’ordre impairs est toujours pair. En particulier un
graphe k-régulier avec kimpaire est un graphe d’ordre pair.
Voici quelques exemples comme application :
1. Est-il possible de relier 15 ordinateurs en réseau de sorte que chacun soit relié à exactement 3 autres ?
2. Une ligue de football comprenant 11 clubs organise un tournoi. Pour gagner du temps on décide que chaque
équipe ne jouera que la moitié des matches possibles. Comment organiser le tournoi ?
Proposition 1.1
Soit G=(V,E) un graphe (simple) d’ordre n≥2. Alors :
∃u,v∈V,u̸=v:d(u)=d(v)
Preuve. Supposons le contraire, c’est-à-dire ∀u,v∈V;d(u)̸=d(v). Or dans un graphe (simple) on a toujours d(x)∈
{0,1,..., n−1}. Dans ce cas, puisque tous les nsommets ont des degrés distincts, alors il existe une bijection
{d(x):x∈V}←→ {0,1,..., n−1}
Donc, il existe un sommet uavec un degré 0, et un sommet vavec degré n−1, donc vest connecté à tous les autres
sommets du graphe, ce qui signifie que une peut pas être un sommet isolé, d’où une contradiction.6 Chapitre 1. Les graphes
1.1.2 Graphes orientés
Les arêtes d’un graphe peuvent être orientées, auquel cas une flèche indique la direction. De tels graphes sont
appelés des graphes orientés ou des digraphes , et une arête ( a,b) dans un tel graphe indique que cette arête est
dirigée de sommet avers b, i.e. ( a,b)=− →ab̸=(b,a)=− →ba. D’où la définition :
Définition 1.3: Graphe orienté - digraphe
Un graphe orienté G(ou− →G) est un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V2des pairs
ordonnées de V.Eest l’ensemble des arêtes (ou flèches, arcs) de G. Lorsque e=(x,y) est une arête, on dit
que xestl’origine (ou sommet initiale) et yl’extrémité (ou sommet terminale) de e, que eest sortant en x
et incident en y, et que yest un successeur de xtandis que xest un prédécesseur de y. On note l’arête e
par :
e=(x,y)=− →x y=x→y
De la même façon, une arête x→xest une boucle. On peut toujours supprimer les boucles pour obtenir des
digraphes simples. Voici l’exemple d’un digraphe G=(V,E) d’une fonction f:E→Eoù ( x,y) est un arc si et seule-
ment si y=f(x). On l’appelle digraphe fonctionnelle.
0
3
1214
11 568
169
4
2 1
713 10
15
FIGURE 1.3 – Le digraphe fonctionnelle Gfdex7→(x2+3) mod 17.
Comme dans les graphes on peut définir les degrés (entrant, sortant) d’un sommet dans un digraphe.
Définition 1.4: indegree - outdegree
Soit G=(V,E) un digraphe. Pour v∈V, on note par :
d+(v) le degré extérieur (sortant - outdegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité initiale.
d+(v)= |{v→ •}|
d−(v) le degré intérieur (entrant - indegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité finale.
d−(v)= |{• → v}|
On définit le degré : d(v)=d−(v)+d+(v).
Un sommet de degré entrant non nul et de degré sortant nul est appelé puits , tandis qu’un sommet de
degré entrant nul et de degré sortant non nul est appelé source ouracine .
Dans un graphe orienté, les voisins d’un sommet vsont soit des successeurs ou des prédécesseurs. On les notes
par :
Γ+(x)=Succ (x)={y∈V:x→y∈E} et Γ−(x)=Pr ed (x)={y∈V:y→x∈E}H. SABRI 7
Si le digraphe est simple (ni boucle ni arcs parallèles) on a :
d−(v)= |Γ−(v)|et d+(v)= |Γ+(v)|
Proposition 1.2
Soit Gun digraphe, alors :X
v∈Vd−(v)=X
v∈Vd+(v)= |E|
Preuve. On a
E=˙[
v∈V{• → v}=˙[
v∈V{v→ •}
=⇒ | E| =X
v∈V|{• → v}| =X
v∈V|{v→ •}| =⇒ | E| =X
v∈Vd−(v)=X
v∈Vd+(v)
1.2 Opérations et quelques types de graphes
Une opération sur les graphes permet de construire un nouveau graphe comme résultat de l’opération. Les
opérations courantes sur les graphes sont la suppression, la valuation, l’union, l’intersection et le produit cartésien.
Graphe valué
Tout d’abord, on peut vouloir attribuer des valeurs aux arcs ou arêtes pour tenir compte de contraintes : dis-
tance, coût ...
Définition 1.5: (di)graphe valué
Un (di)graphe valué G=(V,E,w) est un (di)graphe muni d’une application w:E→R. L ’application west
appelée application poids ou coût. On indique sur chaque arête son poids (ou son coût). On note w(x,y)
au lieu de w((x,y)). On convient (même que ceci n’a pas de sens!) que w(x,y)= +∞ si (x,y)∉E.
ab
c
d
ef53
43
3
335
81
FIGURE 1.4 – Un digraphe valué
/pythonPython code : -
Implémenter le digraphe valué précédent avec python. Indice – use chatGPT : how to build a weighted digraph with
python8 Chapitre 1. Les graphes
Sous graphes
Soit G=(V,E) un graphe (orienté ou non). Un sous graphe de Gest un graphe de la forme G′=(V′,E′) où
V′⊆V,E′⊆Etels que toute arête de E′a ses extrémités dans V′(ou encore G′est aussi un graphe). On a :
•Sous-graphe induit Un sous-graphe G′=(V′,E′) de G=(V,E) est appelé un sous-graphe induit deGsi :
∀x,y∈V′; (x,y)∈E′⇐⇒ (x,y)∈E
En d’autres termes, deux sommets de G′qui sont connectés dans G, sont également connectés dans G′.
•Sous-graphe couvrant Un sous-graphe couvrant G′deGcontient tous les sommets de G, i.e. V′=V.
•G−vSupprimer un sommet vd’un graphe Gconsiste à supprimer vet toutes ses arêtes incidentes. Le sous-
graphe obtenu de cette opération est noté G−v, i.e.
V′=V−{v} et E′=E−{(v,y): (v,y)∈E}
De manière similaire, une arête epeut être supprimée (resp. ajoutée) d’un graphe G, et le sous-graphe
résultant est représenté par G−e(resp. G+e). Notez que la suppression d’une arête ne retire pas de sommets
du graphe.
•G−V′=G[V′] On supprimer tous les sommets v∈V′du graphe Gavec les arêtes incidentes. Le sous-graphe
obtenu de cette opération est noté G[V′], i.e.
V(G[V′])=V−V′et E(G[V′])=E−{(v,y)∈E:v∈V′}
•Clique Une clique Cd’un graphe Gest un sous-ensemble des sommets de Gdont le sous-graphe induit G′=
(C,E′) est un graphe complet, en d’autres termes, deux sommets quelconques de la clique Csont toujours
adjacents.
•Stable Un stable – appelé aussi ensemble indépendant (independent set en anglais) est un ensemble de som-
mets deux à deux non adjacents. Donc le sous-graphe induit est sans arcs.
FIGURE 1.5 – L ’ensemble des sommets en bleu dans ce graphe est un stable maximal du graphe.
Note : -
Le problème décisionnel de la clique (c’est à dire existe t-il une clique de taille k) est NP-complet . De même la
recherche d’un stable de taille maximum dans un graphe est un problème NP-complet et difficile à approximer.
Exercice 1.2
Trouver un plus grand stable et une plus grande clique du graphe suivant :
8
4
62 7
3
1 5
Indice : vérifier le résultat avec networkx.find_cliques(G) et.maximum_independent_set(G) de python.H. SABRI 9
Opérations binaires
Union L ’union de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∪H=(VF,EF) dans lequel
VF=VG∪VH et EF=EG∪EH
Intersection L ’intersection de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∩H=(VF,EF)
dans lequel
VF=VG∩VH et EF=EG∩EH
1.3 Représentation d’un graphe
Il est important de savoir comment représenter les graphes au sein d’un ordinateur. Il ya plusieurs méthodes
selon la nature des traitements que l’on souhaite appliquer au graphe considéré.
1.3.1 Listes d’adjacences (ou de succession)
Soit Gun (di)graphe. On suppose que les sommets de Gsont numérotés de S1àSn. La représentation par listes
d’adjacence de Gconsiste en un tableau (ou des listes chainées) tel que la ligne i=1... ncorrespond au sommet Si
et comporte la liste des voisins/successeurs (ou des prédécesseurs) de ce sommet notée T[Si]. Les sommets dans
chaque liste d’adjacence sont généralement listés selon un ordre arbitraire.
1
2
345
FIGURE 1.6 – Un digraphe
La liste d’adjacence de digraphe 1.6 est donc :
1 2 3 4 5
2 3
3 4
4−
5 1 410 Chapitre 1. Les graphes
1.3.2 Matrices d’adjacence
Définition 1.6: Mat. Adjacence
Soit G=(V,E) un graphe (orienté) d’ordre n. On peut numéroter V={1,2,..., n}.La matrice d’adjacence
deGest la matrice carrée A=(ai j) d’ordre n, définie par :
ai j=(
1 si ( i j)∈E;
0 sinon.
Remarque 3.
1. Si le graphe G est non orienté et simple, alors la matrice A est symétrique avec des 0sur la diagonale. Pour un
digraphe simple, on a toujours des 0sur la diagonale, mais la matrice n’est pas symétrique en général.
2. Pour les multigraphes, il peut y avoir des termes diagonaux (pour les boucles) et s’il y a plusieurs arêtes de i à
j , le coefficient de la matrice a i jest le nombre d’arêtes de i à j .
3. Pour un (di)graphe valué G =(V,E,w), on pose :
ai j=(
w(i,j)si(i j)∈E ;
∞ sinon.
La matrice d’adjacence de la figure 1.4 est :

∞ 5∞ 4 3 ∞
∞ ∞ 3∞ 1∞
∞ ∞ ∞ ∞ ∞ 5
∞ ∞ 3∞ 3 3
∞ ∞ ∞ ∞ ∞ 8
∞ ∞ ∞ ∞ ∞ ∞

1.3.3 Matrice d’incidence
Définition 1.7: Mat. Incidence
Soit G=(V,E) un graphe (simple) d’ordre net de taille m. On pose V={v1,v2,..., vn} etE={e1,e2,..., em}.
La matrice d’incidence deGest la matrice de type n×m B=(bi j), définie par :
•Si G orienté
bi j=

1 si ej=vi→ • (i.e. viest l’extrémité initiale de ej) ;
−1 si ej= • → vi(i.e. viest l’extrémité terminale de ej) ;
0 sinon.
•Si G non-orienté
bi j=(
1 si viest une extrémité de ej;
0 sinon.
Exercice 1.3
1. Donner la matrice d’incidence du graphe 1.6.
2. Montrer le théorème 1.1 avec la matrice d’incidence.CHAPITRE 2
La connexité
Il est important de savoir si on peut suivre un chemin d’un sommet donné à un autre dans un graphe donné.
Cette propriété (de connexité) doit être maintenue dans différents types de réseaux.
2.1 Les chaînes et les cycles
Définition 2.1: (chaine – cycle) (chemin – circuit)
•Graphe non orienté
1. Une chaîne (walk ) reliant xày, notée µ(x,y), est définie par une suite finie d’arêtes consécutives,
reliant xày, ou encore une séquence de sommets (puisque non multigraphe)
µ(x,y)=<v0,v1,..., vk>
tels que v0=x,vk=yet (vi−1,vi)∈E(G) pour tout i=1... k. Six=yla chaîne est dite fermée .
Lalongueur du chaîne l(µ(x,y)) est le nombre d’arcs dans la chaîne, c’est-à-dire k.
2. Une chaîne élémentaire (a path ) si tous les sommets sont distincts. Une chaîne simple (a simple
walk, a trail ) est une chaîne ne passant pas deux fois par une même arête, c’est-à-dire dont toutes
les arêtes sont distinctes. Remarquer que : élémentaire =⇒ simple.
3. Un cycle v0v1...vnde longueur n≥3 est une chaîne simple fermée ( v0=vn) tel que les sommets
v0,v1,..., vn−1sont tous distincts. Un graphe sans cycle est dit acyclique .
•Graphe orienté
Dans un graphe orienté, on parlera de chemin au lieu de chaîne, et de circuit au lieu de cycle.
Example 2.1
abxcd xa est une chaîne simple et fermée (non cycle!) de longueur 6 (mais, c’est un graphe eulérien - voir
plus loin). Y a-t-il un cycle de longueur 3,4 ?
a b
x
c dÏ
Remarque 4.
1. On peut pivoter une chaine fermée (l’orienter de manière arbitraire) , i.e.
<v0,v1,v2,..., v0>=< vk,vk+1,..., v0,v1,..., vk>
1112 Chapitre 2. La connexité
2. Soient x ,y∈V . La distance de x à y est définie par :
d(x,y)=(
k si le plus court chemin/chaîne de x vers y est de longueur k
∞ sinon
On convient que d (x,x)=0.
3. Le diamètre du graphe la plus grande distance entre deux sommets.
L ’observation suivante, bien que très facile à prouver, sera utile.
Théorème 2.1
S’il existe une chaîne du sommet yau sommet zdans le graphe G, où y̸=z, alors il existe une chaîne élé-
mentaire ( path ) dans Gavec pour premier sommet yet pour dernier sommet z.
Preuve. Soit la chaine
W1=µ(y,z)=x0x1...xn; avec x0=yetxn=z.
Si les sommets x0,x1,..., xnsont tous distincts, alors W1est une chaîne élémentaire, et nous avons terminé. Sinon,
il existe xi=xj(i<j) et on écrit :
W2=x0x1...xixj+1...xn.
Alors, l(W2)<l(W1). Si W2ne contient aucun sommet répété, alors c’est la chaîne recherché. Sinon, par la même
procédure, il existe W3(y z−chaîne) tel que
l(W3)<l(W2)<l(W1).
Ce processus doit s’arrêter à un certain stade, car chaque chaîne est plus courte que la précédente et la longueur
ne peut jamais être inférieure à 1
1< ··· < l(Wk)< ··· < l(W3)<l(W2)<l(W1).
Ainsi, pour un certain k,Wkne peut pas être réduit en longueur. Donc, la chaîne Wkne contient aucun sommet
répété et est donc une y z−chaîne élémentaire (path).
Exercice 2.1
Dans le graphe suivant, construire un path à partir de la chaîne W=v2v3v4v5v6v4v2v8v1
v1
 v2
v3
v4
v5
v6
v7
 v8
 v9
Calculer d(v1,v7) et le diamètre de G.
/pythonpython : >>G = nx.Graph([(1, 2), (2, 3), (2, 4), ...]) >>nx.diameter(G)
Les cycles fournissent la caractérisation suivante pour les graphes bipartis .H. SABRI 13
Théorème 2.2
Un graphe est biparti si et seulement s’il ne contient aucun cycle de longueur impaire.
Preuve.
⇒On suppose que G=U˙∪Vest un graphe biparti. Soit W=< x1,x2,..., x2k+1,x1>un cycle de longueur im-
paire (2 k+1). Si x1∈U, alors
x1∈U=⇒ x2∈V=⇒ x3∈U=⇒ ··· =⇒ x2k+1∈U=⇒ x1∈V/exclamati⌢n-triangle
absurde, d’où le résultat.
⇐On suppose que Gest connexe (car l’union des composantes connexes bipartis est un graphe biparti). Soit
xun sommet de Get on pose :
U={y∈V(G):d(x,y) est paire} et V={z∈V(G):d(x,z) est impaire}
S’il existe y1,y2∈Utel que y1y2∈E(G), alors on a :
W1=<x,..., y1>est une chaîne de longueur paire =2k1
W2=<x,..., y2>est une chaîne de longueur paire =2k2
=⇒ W3=<x,..., y1,y2,..., x>est un cycle de longueur impaire =2k1+2k2+1/exclamati⌢n-triangle
Donc G=U˙∪Vest un graphe biparti.
Exercice 2.2
Vérifier si le graphe maison est un graphe biparti. Faire de même pour la grille G4,4.
maison grille
2.2 Graphe connexe, eulérien, hamiltonien
Définition 2.2: Graphe connexe
Un graphe est dit connexe si deux points peuvent toujours être joints par une chaîne, i.e.
∀x,y∈V(G),d(x,y)< ∞
— Une composante connexe d’un graphe est un sous-graphe induit maximal connexe.
— Un point d’articulation d’un graphe est un sommet dont la suppression augmente le nombre de
composantes connexes.
Par exemple, le graphe suivant :14 Chapitre 2. La connexité
a
 b
d
 c
e
f
 g
n’est pas connexe car il n’existe pas de chaîne entre les sommets aete. On a donc 2 composantes connexes. En
revanche, le sous-graphe induit par les sommets { a,b,c,d} est connexe dont aest le seul point d’articulation.
Remarque 5.
1. Un graphe connexe à n sommets possède au moins n −1arêtes ( faite une preuve par récurrence ).
2. L’algorithme de parcours en profondeur permet de déterminer si un graphe est connexe ou non.
3. Même définitions dans un graphe orienté . Graphe orienté (fortement) connexe et de composante connexe .
Définition 2.3: Graphe eulérien
— Une chaîne joignant deux sommets xetyest dite chaîne eulérienne si elle emprunte chaque arête
deGune et une seule fois. On parle de chemin eulérien dans le cas d’un graphe orienté.
— Un cycle eulérien est une chaîne eulérienne dont les extrémités coïncident. Un graphe qui admet
un cycle (resp. circuit) eulérien est dit graphe eulérien .
/flushedRemarquer qu’un cycle eulérien n’est pas forcément un cycle comme définit dans la définition 2.1
Si un graphe (ou multigraphe) Gpossède une chaîne eulérienne, alors soit Gpossède deux sommets impairs, le
début et la fin de cette chaîne, soit Gn’a aucun sommet impair, et la promenade d’Euler commence et se termine
au même point (cycle eulérien). Une autre condition nécessaire évidente est que Gdoit être connexe. Ces deux
conditions sont ensemble suffisantes.
Théorème 2.3 Euler
Soit Gun graphe (multigraphe) connexe.
— Si Gn’a pas de sommets impairs, alors il possède un cycle eulérien (commençant à n’importe quel
point).
i.e.∀x,d(x)≡0 mod 2 =⇒ Gest un graphe eulérien.
— Si Ga deux sommets impairs, alors il possède une chaîne eulérienne dont le début et la fin sont les
sommets impairs.
La réciproque est aussi vraie.
Preuve.
⇐On commence par la réciproque. S’il existe une chaîne eulérienne µ(x,y), alors on peut crée une arête fictive
e=(y,x) et par la suite on obtient un cycle eulérien. Donc il suffit de montrer que si Gadmet un cycle
eulérien alors tous les sommets sont de degré pair.
Soit W=< v1,v2,..., vn,v1>un cycle eulérien. Soit le sommet vjavec j̸=1, il est donc claire que chaque
fois vjapparaît dans W, il ya deux arcs distincts incidents en vj( (•,vj) et ( vj,•)). Comme toutes les arêtes
sont utilisées, on voit que d(vj) est pair. Même chose pour v1car on ajoute deux arcs ( v1,v2) et ( v1,vn).
⇒On suppose que tous les sommets sont de degré pair. Montrons que Gadmet un cycle eulérien. Puisque
tous les sommets sont de degré pair on peut construire d’abord une chaîne simple fermée (quelconque)
W1=<v1,v2,..., vk,v1>
SiW1contient chaque arête de G, alors c’est finis, c’est un cycle eulérien. Sinon (puisque Gest connexe), il
existe une arête e=(vi,c) qui n’est pas dans W1(avec visommet de W1). On pose le sous-graphe
G′=G−{ arêtes de W1}H. SABRI 15
Il est donc claire que les sommets de G′sont aussi de degré pair. Alors, par la même procédure on construit
une chaîne simple fermée dans G′de la forme : <vi,c,d,..., vi>et par la suite on insère cette chaîne dans
W1pour obtenir :
W2=<v1,v2,..., vi,c,d,..., vi,vi+1,..., vk,v1>
Sil(W2)< |E(G)|, on construit W3de longueur plus grand. Ainsi, on a :
l(W1)<l(W2)<l(W3)< ··· ≤ | E(G)|
Donc, nécessairement, il existe Wk(chaîne simple fermée de longueur |E(G)|) donc c’est un cycle eulérien.
Finalement , si∃a,b∈V(G):d(a)≡d(b)≡1 mod 2, et tous les autres sommets sont de degré pair, alors on
pose :
G′=G+{a,b}
et donc tous les sommets de G′sont de degré pair. Avec la construction précédente, il existe un cycle eulérien
dans G′:
W=<a,b,v1,..., a>
est donc la chaîne <b,v2,..., a>est une chaîne eulérienne dans G.
Algorithme 1 : Euler
Entrées : Gun graphe eulérien
Output : Un cycle eulérien W
/* On suppose que G est eulérien, i.e. les sommets sont de degré pair */
1Gaux←G;W←µ(v,v) une chaîne simple (quelconque) de G; // Initialisation
2tant que l(W)<e(G)faire
3 Gaux←G−{ arêtes de W} ;
4 Choisir ( x,c)∈E(Gaux) tel que x∈W;
5 L←< x,c,..., x>une chaîne simple de Gaux ;
6 Dans W, remplacer (juste ce) xpar la séquence L;
7fin
8retourner W;
Exercice 2.3
1. Montrer que le graphe de l’exercice 2.1 est un graphe eulérien et donner un cycle eulérien.
2. Tracer cette maison d’un seul trait.
Remarque 6. Le théorème d’Euler dans un graphe orienté connexe s’écrit :
Admet un circuit eulérien si, et seulement si, pour tout sommet, le degré entrant est égal au degré sortant.
∀v∈V(G),d+(v)=d−(v)
Admet un chemin eulérien de a vers b si, et seulement si,


d+(v)=d−(v) ;∀v̸=a,b,
d−(a)=d+(a)−1
d−(b)=d+(b)+116 Chapitre 2. La connexité
Définition 2.4: Graphe hamiltonien
Soit Gun graphe connexe d’ordre n. On appelle :
1. On appelle cycle hamiltonien deGun cycle passant (une et une seule fois) par chacun des sommets
deG. Un graphe est dit hamiltonien s’il possède un cycle hamiltonien.
2. Une chaîne hamiltonienne est une chaîne passant une et une seule fois par chacun des sommets de
G. Un graphe ne possédant que des chaînes hamiltoniennes est semi-hamiltonien .
3. Dans un digraphe, on change cycle par circuit et chaîne par chemin .
Remarque 7.
— Une chaîne hamiltonienne est une chaîne élémentaire de longueur n −1.
— Un graphe peut être eulérien, hamiltonien, les deux à la fois, ou aucun des deux.
— De nombreux problèmes concrets peuvent être formulés en termes de recherche de parcours hamiltoniens : pro-
blème du voyageur de commerce (chercher un cycle hamiltonien de longueur totale minimale), l’ ordonancement
de tâches .
— Le problème du chaîne hamiltonienne est un problème NP-complet .
Exercice 2.4
Donner un graphe (connexe, simple) qui soit :
1. hamiltonien et eulérien.
2. hamiltonien et non eulérien.
3. eulérien et non hamiltonien.
4. non hamiltonien et non eulérien.
Aucune condition nécessaire et suffisante adéquate n’est connue pour l’existence de cycles hamiltoniens. Le
résultat suivant constitue une condition suffisante utile.
Théorème 2.4 Ore
Soit Gun graphe simple d’ordre n≥3. Si pour toute paire { x,y} de sommets non adjacents, on a d(x)+d(y)≥
n, alors Gest hamiltonien.
Preuve. On suppose que le théorème est faux. Alors, il existe un graphe Gsimple d’ordre nnon hamiltonien tel que
d(u)+d(v)≥npour tout sommets non adjacents uetv. On prend Gun tel graphe d’ordre nde taille maximale qui
vérifie cette propriété (remarquer que le graphe complet Knest hamiltonien).
Soient uetvdeux sommets non adjacents de G. Par maximalité de G, le graphe G+uv(d’ordre n) doit être
hamiltonien. Donc il existe dans G+uvun cycle hamiltonien :
W=<u,x1,x2,..., xn−2,v,u>
u
x1
xi xi+1xn−2
v
... ...
Or, si uxi+1∈E(G) etv xi∈E(G) (les arcs en rouge), alors on peut construire dans Gle cycle hamiltonien :
<u,x1,x2,..., xi,v,xn−2,..., xi+1,u>H. SABRI 17
Ceci est absurde car Gest non hamiltonien. Donc si xi+1est un sommet voisin à u, alors le sommet xin’est pas
voisin de v:
xi+1∈Γ(u)=⇒ xi∉Γ(v)
Donc :
d(u)= |Γ(u)| =p=⇒ d(v)≤(n−1)−p
et par la suite
d(u)+d(v)≤n−1
ce qui absurde par hypothèse. Donc Gest hamiltonien.
Une conséquence immédiate est le théorème de Dirac :
Proposition 2.1 Dirac
Soit Gun graphe simple d’ordre n≥3. Si pour tout sommet xdeG, on a d(x)≥n
2, alors Gest hamiltonien.
2.3 Arbres
Définition 2.5: Arbres et forêts
On appelle arbre tout graphe (non orienté) connexe et acyclique . Les composantes connexes dans un
graphe acyclique sont des arbres et le graphe est dit forêt . Une feuille ou sommet pendant est un som-
met de degré 1.
Un forêt avec deux arbres
Un graphe Gest une arborescence s’il existe un sommet Rappelé racine deGtel que, pour tout sommet
SdeG, il existe un chemin et un seul de Rvers S. Donc, c’est un arbre orienté dans lequel on choisit un
sommet Rcomme racine et on dirige les arcs vers le sens sortant de la racine.
Remarque 8.
— Un graphe G d’ordre n est un arbre ssi G est sans cycle et possède n −1arêtes.
— Un graphe G d’ordre n est un arbre ssi G est connexe et possède n −1arêtes.
— G est un arbre si pour chaque paire u ,v de sommets distincts est reliée par une seule chaîne (donc chaîne
élémentaire d’après le théorème 2.1).
— Un arbre (ou forêt) est nécessairement un graphe simple.
Pour démontrer les remarques précédentes, il suffit de prouver le théorème suivant :
Théorème 2.5
Soit Gun graphe ayant marêtes, nsommets et pcomposantes connexes, on définit nu( G) :
ν(G)=m−n+p
Alors, on a :
1.ν(G)≥0.
2.ν(G)=0⇐⇒ Gest acyclique.18 Chapitre 2. La connexité
Preuve. Par récurrence sur la taille mdu graphe. Le résultat est évident pour m=0 et m=1. On suppose le résultat
est vrai pour les graphe de taille m, et montrons que ceci est vrai pour un graphe de taille m+1. Soit donc Gun
graphe d’ordre nde taille m+1 ayant pcomposantes connexes.
•On suppose que Gest un graphe acyclique. Soit uvune arête de Gdans la composante C. Si on supprime uv,
la composante Cse transforme en deux composantes connexes (sinon on a un cycle dans G). Par la suite,
le graphe G′=G−uvest un graphe acyclique d’ordre n, de taille met ayant p+1 composantes connexes.
Donc d’après l’hypothèse de récurrence :
ν(G′)=0=(m−1)−n+(p+1)=m−n+p=ν(G)
•Maintenant, si Gcontient un cycle Wdans la composante connexe C. Soit uvune arête de W, alors si on
supprime l’arête uv, la composante Creste connexe. Donc le graphe G′=G−uvest un graphe d’ordre nde
taille m−1 ayant pcomposantes connexes. Donc, d’après l’hypothèse de récurrence :
ν(G′)=(m−1)−n−p≥0
=⇒ν(G)=m−n−p≥1>0
D’où le résultat – car si ν(G)=0,Gne peut être que acyclique, sinon 0 =ν(G)≥1/exclamati⌢n-triangle
2.3.1 Codage et décodage d’un arbre – Prüfer code
Soit Tun arbre ayant nsommet numérotés {1,2,..., n}. Le codage de Prüfer représente l’arbre Tarbre de avec
une suite P=(x1,x2,x3,..., xn−2) de n−2 termes (les n° des sommets avec répétition possible). Une suite Pdonnée
correspond à un et un seul arbre numéroté. Voici les algorithmes de codage et de décodage.
Algorithme 2 : Codage de Prüfer
Entrées : Un arbre T
Output : Séquence de Prüfer P
1P←() ; // Initialisation de P comme séquence vide
2tant que v(T)>2faire
3 x←feuille de Tayant le n° minimum ; // donc d(x)=1
4 P←(P,s) où sest le seul (n°) sommet adjacent à x;
5 T←T−x;
6fin
7retourner P;
Example 2.2
Donner le code de Prüfer de l’arbre :
126 345
Indice : on trouve, P=(2,3,3,2)
Pour faire la réciproque, étant donnée une séquence P=(x1,x2,..., xn−2) où les xi∈{1,2,..., n}, on construit
l’arbre Tdont les sommets sont {1,2,..., n} avec l’algorithme suivant (le décodage) :H. SABRI 19
Algorithme 3 : Décodage de Prüfer
Entrées : Une séquence Pde taille n−2
Output : L ’arbre Tcorrespondante
1I←{1,2,..., n};
2T←graphe tel que V(T)=IetE(T)= ; ; // T graphe à n sommets isolés
3tant que P̸=()faire
4 i←min {x∈I:x∉P};
5 T←T+(i,P[1]) ; // ajouter l'arc (i,P[1])
6 P←P−P[1];I←I−{i};
7fin
8T←T+(a,b) ; // a,b sont les deux éléments restant dans I
9retourner T;
Example 2.3
Donner l’arbre dont le code de Prüfer est : P=(2,3,3,3)
Puisqu’il ya une bijection entre les arbres d’ordre net les suites Pde longueur n−2 à coefficients dans {1,2,..., n},
on déduit le théorème de Cayley :
Théorème 2.6 Formule de Cayley
Le nombre d’arbres que l’on peut construire sur n(n≥2) sommets numérotés est égal à nn−2.
2.3.2 Arbre couvrant de poids minimum – ACM
Soit Gun graphe (non orienté). Un arbre couvrant (spanning tree) TdeGest un sous graphe couvrant de G
tel que Test un arbre. Remarquer que, Gdoit être connexe, sinon un arbre couvrant de Gn’existe pas. Le nombre
des arbres couvrant de Gest noté a(G). Remarquer que a(Kn)=nn−2(le nombre de Cayley). Un problème algo-
rithmique classique est de trouver, dans un graphe valué , un arbre couvrant de poids minimal . On dispose de
plusieurs algorithmes (l’algorithme de Prim, l’algorithme de Kruskal ...).
Algorithme 4 : Kruskal
Entrées : Un graphe Gvalué d’ordre net de taille m
Output : Arbre (ou forêt) couvrant de poids minimum
1Numéroter les arêtes de Gpar poids minimum : w(e1)≤w(e2)≤ ··· ≤ w(em)
2T←graphe tel que V(T)=V(G) etE(T)= ; ; // T graphe à n sommets isolés
3k←0;
4tant que k<m et e (T)<n−1faire
5 siT+ek+1est acyclique alors
6 T←T+ek+1;
7 k←k+1;
8fin
9retourner T;
Appliquer l’algorithme de Kruskal dans le graphe suivant :
CHAPITRE 3
Les algorithmes de base
Beaucoup de problèmes sur les graphes nécessitent que l’on parcourt l’ensemble des sommets et des arcs. Par
exemple, pour vérifier que le graphe est connexe, chercher un sommet particulier, construire un arbre couvrant,
trouver un plus court chemin ...etc.
3.1 Parcours en profondeur (DFS) / largeur (BFS)
Une manière simple de tester si un graphe Gest connexe ou non est d’exécuter l’algorithme DFS ouBFS dans
Gen commençant par n’importe quel sommet et en enregistrant les sommets visités pendant l’exécution dans une
liste. Si la liste contient tous les sommets de G, alors Gest connexe. Une petite modification permet de donner les
composantes connexes de G. L ’algorithme DFS_Component suivant donne les composantes connexes de G. Il est
donné sous forme d’implémentation récursive.
Algorithme 5 : DFS_Component
Entrées : Un graphe G=(V,E)
Output : Les composantes connexes C=(C1,C2,..., Ck) de G.
1VisitedNodes ← ; ;
2k←0 ; // k est le nombre des composantes connexes
3pour chaque u∈Vfaire
4 siu∉VisitedNodes alors
5 k←k+1;
6 DFS( u);
7 fin
8fin
9retourner (C1,C2,..., Ck);
1Procedure DFS( u )
2 VisitedNodes ←VisitedNodes ∪{u};
3 Ck←Ck∪{u};
4 pour chaque x∈Γ(u)faire
5 six∉VisitedNodes alors
6 DFS( x);
7 fin
8 fin
Note : -
Il est possible de d’implémenter la procédure DFS itérativement à l’aide d’une pile LIFO (stack) contenant les
sommets à explorer : on désempile un sommet et on empile ses voisins non encore explorés.
20H. SABRI 21
Pseudocode :
stack . push ( root )
while stack . isEmpty ( ) = f a l s e do
node = stack . pop ( ) // so mark i t as v i s i t e d
for each x in node . childNodes do
i f x i s not v i s i t e d then
stack . push ( x )
. . .
endfor
endwhile
Example 3.1 (DFS )
Ici on empile (gris) les sommets les plus à droite, alors l’ordre des sommets visité (noir) est ( a,b,d,e,g,c,f).
Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b
 c
d
 e
f
g
a
b
 c
d e
f
ga
b
 c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g
L ’utilisation d’une file (FIFO) au lieu d’une pile transforme l’algorithme du parcours en profondeur en algo-
rithme de parcours en largeur ( BFS ). Avec BFS l’exemple précédent devient (en enfile le plus à gauche) :
Example 3.2 (BFS )
Ici, avec BFS, on enfile (gris) les sommets les plus à gauche d’abord, alors l’ordre des sommets visité (noir)
est ( a,b,d,e,g,c,f). Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b c
d
 e
f
g
a
b c
d
 e
f
ga
b c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g22 Chapitre 3. Les algorithmes de base
Exercice 3.1
1. Écrire la procédure BFS .
2. Utiliser DFS (ou BFS) pour la construction d’un arbre couvrant d’un graphe connexe. L ’appliquer
pour le graphe triangle.
3. Utiliser DFS pour écrire une procédure DFS_Cycle pour détecter un cycle dans un graphe.
On sait qu’un graphe orienté G=(V,E) est fortement connexe si pour chaque paire de sommets u,v∈V, il
existe un chemin de uàvet il existe un chemin de vàu. En d’autres termes, nous avons besoin d’une connectivité
dans les deux directions .
Une procédure pour tester si un graphe orienté est fortement connexe ou non peut être conçue avec l’idée
suivante. En partant d’un sommet arbitraire vdu graphe G, on exécute l’algorithme BFS ouDFS et l’on note les
sommets visités. Ensuite, on obtient la transposée de G,GT, en inversant la direction des arêtes de G, et l’on
exécute à nouveau l’algorithme BFS ou DFS à partir du sommet v. Si les sommets visités dans les deux cas sont
égaux à V, alors le graphe orienté est fortement connexe. Cette méthode est illustrée dans l’algorithme 6.
Algorithme 6 : Fortement_connexe
Entrées : Un graphe orienté G=(V,E)
Output : true siGest fortement connexe et false sinon
1X← ; ;
2Y← ; ;
3v←un sommet quelconque de V;
4X←DFS( G,v) ; // Enregistrez les sommets visités dans X
5GT←Gavec flèches inversées;
6Y←DFS( GT,v);
7siX=Y=Valors
8 retourner TRUE.
9sinon
10 retourner FALSE.
11fin
3.2 Recherche des chemins
3.2.1 Matrice d’adjacence et nombre de chemins
La puissance de la matrice d’adjacence Amontre qu’il y a des chemins (ou chaînes) de longueur kallant de xà
ycomme le montre le théorème suivant.
Théorème 3.1
Soit G=(V,E) un (di)graphe. On note V={1,2,..., n} et Asa matrice d’adjacence et Akla puissance k-ème
deA. Alors le terme d’indices i,jdeAkest le nombre de chemins (chaînes) de longueur kallant de iàj.
Preuve. Par récurrence sur k. Pour k=1 c’est clair. On suppose le résultat est vrai à l’ordre ket montrons qu’elle
est vrai pour k+1. Soit S=(si,j)=Ak. Si on a un chemin de iàjde longueur k+1, alors on va d’abord de ià un
sommet ravec kpas et puis de ràj. Or d’après l’hypothèse de récurrence on a si,rchemins possibles pour aller de
iàret finalement ar,jpas (1 ou 0) pour aller de ràj. Ainsi, le nombre totale possibles (i.e. tous les sommets r) est :
nX
r=1si,rar,j=³
Ak×A´
i,jH. SABRI 23
ce qui est bien le terme ( i,j) de la matrice Ak+1.
3.2.2 Plus court chemin et l’algorithme de Dijkstra
Dans cette partie on suppose que le (di)graphe G=(V,E,w) est valué positivement (i.e.∀e∈E,w(e)>0). Notre
objectif est de chercher un plus court chemin (i.e., un chemin de poids minimal ) d’un sommet ufixé à un sommet
quelconque de G.
Il est clair que l’on peut restreindre ce problème au cas d’un (di)graphe simple1. On suppose aussi que Gest
connexe (sinon, certains trajets sont impossibles). Il est aussi claire (d’après théorème 2.1), qu’un plus court chemin
est nécessairement un chemin élémentaire (path).
L ’algorithme de Dijkstra (1959) permet de calculer le plus court chemin entre un sommet particulier u(racine )
et tous les autres sommets. L ’algorithme fonctionne de la manière suivante :
Pour tout sommet vdeG, on associe une valeur T(v), initialisée à w(u,v) et une liste de sommets C(v) qui
correspond à un chemin de uàv. À la fin de l’algorithme, T(v) contient le poids minimal des chemins joignant uà
v(ou T(v)= ∞ siu↛v) et la liste C(v) réalise un tel chemin. Voici donc l’algorithme de Dijkstra :
Algorithme 7 : Algorithme de Dijkstra
Entrées : Un (di)graphe valué G=(V,E,w) et un sommet racine u
Output : Le coût minimum d’un chemin de uàv(∀v∈V) et un trajet pour chaque coût minimal obtenu
1∀v∈V,T(v)←w(u,v) etC(v)←(u,v); // Initialisation de T(v) et la liste C(v)
2X←{u};
3tant que X̸=Vfaire
4 Choisir v∈V−Xtel que ∀y∈V−X,T(v)≤T(y);
5 X←X∪{v};
6 pour chaque y∈V−Xfaire // Faire les mises à jours pour les autres sommets
7 siT(y)>T(v)+w(v,y)alors
8 T(y)←T(v)+w(v,y);
9 C(y)←[C(v),y]; // On ajoute à la liste C(v) l'élément y
10
11 fin
12 fin
13fin
Example 3.3
Voici une application de l’algorithme de Dijkstra au digraphe suivant. On prend Ecomme sommet racine.
EA
B
CD
FG
S5
4
21
12
2
34
4
215
7
1. En effet, passer par une boucle ne ferait qu’augmenter inutilement le poids de ce chemin. De même, si plusieurs arcs joignent deux
sommets, il suffit de conserver l’arc de poids minimal.24 Chapitre 3. Les algorithmes de base
Ainsi, pour l’initialisation, on a : X={E} et on a les valeurs :
v  E A B C D F G S
T(v) 0 5 4 2 ∞ ∞ ∞ ∞
C(v)(E,E) ( E,A) ( E,B) ( E,C) ( E,D) ( E,F) ( E,G) ( E,S)
Maintenant, on choisit (un seul choix) le sommet C, donc X={E,C}. Le tableau est mis à jour :
v  E A B  C D F G S
T(v) 0 5 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À l’étape suivante, on est forcé de choisir B. Ainsi, X={E,C,B} et la mise à jour est :
v  E A  B  C D F G S
T(v) 0 4 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À présent, on a le choix entre AetF. On choisit A. Donc X={E,C,B,A} et on a :
v  E  A  B  C D F G S
T(v) 0 4 3 2 6 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,B,A,D) ( E,C,F) ( E,C,G) ( E,S)
Puis, on prend le sommet F. D’où X={E,C,B,A,F} et :
v  E  A  B  C D  F G S
T(v) 0 4 3 2 5 4 5 11
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,S)
On prend Det on obtient X={E,C,B,A,F,D} et :
v  E  A  B  C  D  F G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Finalement, on prend Gpuis Set on voit que ceci ne change rien. D’où le tableau finale :
v  E  A  B  C  D  F  G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Ainsi le chemin minimum pour aller de EàSest de coût 10 et un trajet de coût minimal de EàSest : EC F DS .H. SABRI 25
3.3 Problèmes d’ordonnancement et chemin critique
Un problème d’ordonnancement peut-être représenté sous la forme d’un digraphe. Les sommets sont des évé-
nements (début et fin de la tâche) et les arcs des tâches, La longueur (ou poids) de chaque arc représente la durée
d’exécution de la tâche. Ainsi, la tâche correspondant à l’arc ( i,j) ne peut commencer que si toutes les tâches cor-
respondant à des arcs ( k,i) ont été complétées. On ajoute deux sommets pour le début (s) et de fin(t) du projet .
Le digraphe peut contenir des tâches fictives dedurée nulle afin de forcer certaines précédences (postériorité).
Ainsi, un réseau PERT est un digraphe valué G=(V,E,w,s,t) où la fonction poids (ou longueur) w:E→R+
etsle sommet source (début) et tle sommet puits (fin). Un chemin critique est un chemin de sàtdelongueur
maximale . S’il n’existe pas de chemin critique, le projet n’est pas réalisable (e.g. un circuit). Le temps minimal
requis pour l’exécution d’un projet réalisable est égal à la longueur d’un chemin critique. Les tâches figurant sur un
chemin critique sont aussi appelées critiques, ce qui s’explique par le fait que tout retard d’exécution d’une tâche
critique retarde d’autant l’exécution du projet.
3.3.1 Algorithmes de tri topologique et de chemin critique
Il faut d’abord numérotés les sommets de 1 à nde manière compatible au pré-ordre (rang) avec l’algorithme du
rang suivant (tri topologique) :
Algorithme 8 : Algorithme du rang
Entrées : Un digraphe G=(V,E) sans circuit
Output : Le rang r(v) de chaque sommet v∈Vde G
1r←0;X←V;
2R←{v∈X:Γ−
X(v)= ;} ; // l'ensemble des sommets de X sans prédécesseur dans X
3tant que X̸= ; faire
4 r(v)←rpour chaque sommet v∈R;
5 X←X−R;
6 R←l’ensemble des sommets de Xsans prédécesseur dans X;
7 r←r+1;
8fin
On supposera dorénavant que les sommets ont déjà été numérotés de 1 à nde manière compatible avec leurs
rangs, c’est-à-dire que r(j)>r(i) implique j>i(donc 1 =setn=t). Enfin, on supposera éliminés les arcs paral-
lèles par l’introduction de tâches fictives de durée nulle .
Pour un sommet i, on note tiledébut au plus tôt des tâches correspondant aux arcs i→jet par Tilafin au
plus tard des tâches correspondant aux arcs j→i.
Algorithme 9 : Algorithme du chemin critique
Entrées : Un digraphe G=(V,E) sans circuit trié topologiquement
Output : La durée du chemin critique et les dates ti,Ti
1t1←0;
2pour j=2···nfaire // Calcul des dates de début au plus tôt  récurrence en avançant
3 tj←max i∈Γ−(j){ti+w(i,j)}
4fin
5Tn←tn;
6pour j=n−1···1faire // Calcul des dates de fin au plus tard  récurrence en reculant
7 Tj←min i∈Γ+(j){Ti−w(j,i)}
8fin26 Chapitre 3. Les algorithmes de base
Définition 3.1
— Un sommet iest critique si ti=Ti.
— Un arc ( i,j) est critique les sommets ietjsont critiques ettj−ti=w(i,j).
— Un chemin critique est un chemin de 1 à nn’utilisant que des arcs critiques.
— La durée du chemin critique est donnée par Tn(ou par tn). Elle correspond à la durée minimale du
projet .
Example 3.4
L ’application de l’algorithme du chemin critique au digraphe suivant (trié topologiquement) est :
1 23
45
6B
9A
3
C
5D
8
E
4
F7G
20
H6I5
=⇒
 1
0,02
9,933,16
4
16,23513,24
6
29,29B
9A
3
C
5D
8
E
4
F7G
20
H6I5
Les tâches critiques sont BetG. La durée totale minimale du projet est donc 29.
Exercice 3.2
Les tâches ( durée et précédences ) pour la construction d’un entrepôt sont données dans le tableau suivant :
Tâches Nature Précédences Durée (jours)
A Acceptation des plans par le propriétaire – 4
B Préparation du terrain – 2
C Commande des matériaux A 1
D Creusage des fondations A, B 1
E Commande des portes et fenêtres A 2
F Livraison des matériaux C 2
G Coulage des fondations D, F 2
H Livraison des portes et fenêtres E 10
I Pose des murs, de la charpente et du toit G 4
J Mise en place des portes et fenêtres H, I 1
1. Représentez le graphe des précédences de ce projet (trié topologiquement).
2. Déterminez une durée totale minimale en exhibant un chemin critique dans ce graphe.CHAPITRE 4
Programmation linéaire
La programmation linéaire est le processus de minimiser ou maximiser une fonction objective linéaire sou-
mise à un nombre fini de contraintes d’égalités et d’inégalités linéaires.
La programmation linéaire a de nombreuses applications dans le domaine de l’informatique théorique. Elle
peut être utilisée pour résoudre de nombreux problèmes combinatoires variés, tels que la recherche de flot maxi-
mum dans un réseau, la recherche d’un couplage maximal dans un graphe et la coloration d’un graphe parfait.
Example 4.1 (Problème de régime)
On suppose qu’on a quatre plats : de la truite ( XT), un sandwich au corned-beef ( XC B), un burrito ( XBU R )
et un hamburger ( XHB). Le tableau suivant répertorie la valeur nutritionnelle de chaque plat (vitamines et
calories) et notre besoin journalier des vitamines.
Vit. A Vit. C Vit. D Calories
Truite 203 92 100 600
Corned-beef 90 84 230 350
Burrito 270 80 512 250
Humburger 500 90 210 500
Besoins 2000 300 430
Notre objectif est de minimiser le nombre total de calories consommées : 600 XT+350XC B+250XBU R+
500XHBtout en satisfaisant les trois besoins nutritionnels en vitamines. Le programme linéaire résultant
s’écrit :
min 600 XT+350XC B+250XBU R+500XHB
s.t. 203 XT+90XC B+270XBU R+500XHB≥2000, (Besoins de Vit. A),
92XT+84XC B+80XBU R+90XHB≥300, (Besoins de Vit. C),
100XT+230XC B+512XBU R+210XHB≥430, (Besoins de Vit. D),
XT,XC B,XBU R ,XHB≥0
Définition 4.1: Forme canonique – Forme standard
On peut écrire un P .L. sous deux formes spéciales :
•Canonique
max
mincTX+c0
s.t. AX≤b(≥bsi min),
X≥0•Standard
max cTX+c0
s.t. AX=b,
X≥0Avec :
cTX=¡
c1··· cn¢
x1
...
xn

cTX+c0=c1x1+c2x2+···+ cnxn+c0
2728 Chapitre 4. Programmation linéaire
Remarque 9. Un P .L. général peut être formulé selon une forme standard ou canonique par la méthode suivante :
générale =⇒ standard il faut éliminer les contraintes d’inégalité et les variables sans contrainte de positivité.
— Si dT
iX≤biest une contrainte d’inégalité, alors créer une nouvelle variable ( d’écart ) siet remplacer l’in-
égalité dT
iX≤bipar dT
iX+si=biet s i≥0.
Si dT
iX≥bi, alors on peut écrire dT
iX−si=biet s i≥0.
— Si une variable x i≶0est de signe quelconque, alors créez deux nouvelles variables x+
iet x−
iet remplacez
xipartout par x+
i−x−
i, et ajoutez les contraintes de signe : x+
i≥0,x−
i≥0.
générale =⇒ canonique
— Si dT
iX=biest une contrainte d’égalité, alors remplacer cette égalité par une paire d’inégalités :
dT
iX≥biet−dT
iX≥ −bi
— Même chose que précédemment si la variable x i≶0.
Il est facile de voir que les problèmes qui en résultent sont équivalents aux problème d’origine. Pour l’algorithme
simplexe , nous utiliserons la forme standard .
On remarque aussi qu’en utilisant la relation min f(x)= − max¡
−f(x)¢
dans laquelle f (x)représente la fonction-
nelle linéaire à optimiser, on peut toujours se ramener à un problème de minimisation (ou de maximisation).
Example 4.2
Le P .L :max 5 x+4y
s.t. x≤6
1
4x+y≤6
3x+2y≤22
x,y≥0s’écrit sous forme standard :max 5 x1+4x2
s.t. x1+e1=6
1
4x1+x2+e2=6
3x1+2x2+e3=22
x1,x2,e1,e2,e3≥0
Donc (sous la forme matricielle) on a :
cT=¡
5 4 0 0 0¢
;A=
1 0 1 0 0
1
41 0 1 0
3 2 0 0 1
;X=
x1
x2
e1
e2
e3
et b=
6
6
22

4.1 La méthode simplexe
4.1.1 Solution de base admissible
On suppose que la matrice Adu programme linéaire est de type m×netde rang m(pourquoi !). Soit Bla
matrice carrée extraite de Aformée par les mcolonnes j1,j2,..., jmlinéairement indépendants de A(les vecteurs
de base). Alors, Best une matrice inversible. Ainsi si on pose xl=0 sil∉{j1,..., jm} etxjklak-ième composante de
B−1b. Alors, on a AX B=b. Si de plus XB≥0(i.e. chaque xi≥0), alors :
Xest une solution de base admissible (ou réalisable)
Dans l’exemple 4.2, la matrice extraite B=
1 0 0
0 1 0
0 0 1
est inversible et B−1b=
6
6
22
. Donc XB=
0
0
6
6
22
≥0, par suite
XBest une solution de base admissible. On appelle les variables xjklesvariables de base . Les autres variables xl
sont les variables hors-base .
Parfois, il n’est pas évident de trouver une solution de base admissible, comme le montre l’exercice suivant :H. SABRI 29
Exercice 4.1
Écrire le programme linéaire suivant sous forme standard et montrer qu’on n’a pas une solution de base
admissible. Résoudre le programme linéaire.
max −x+y
s.t. x+y≥1,
3x+2y=6,
x,y≥0
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux
Dans cette section, on suppose qu’on a déjà trouvé une solution de base admissible X(produite avec B=Im)
du programme linéaire ( P: max z=cTX+c0etb≥0pour garantir que 0est une solution de AX≤b).
La méthode du simplexe est une méthode itérative qui génère une séquence de solutions de base réalisable
(correspondant à différentes bases) et s’arrête finalement lorsqu’elle a trouvé une solution de base réalisable opti-
male. Remarquer qu’on peut toujours prendre c0=0.
Algorithme 10 : Algorithme du simplexe
Entrées : Un P .L. standard P(max) avec une solution de base réalisable
Output : La solution optimale (ou non)
1On commence à écrire le tableau initiale (avec les variables de base xj1,..., xjm)
VB x1 ... xn b
xj1 b1
... A...
xjm bm
c1 ... cn−c0
2Sicj≤0 (∀j:xjest hors base), alors solution optimale (STOP) // min ⇝cj≥0
3Trouver la colonne s(hors base) tel que cs=max©
cj:cj>0ª// min ⇝cs=min©
cj:cj<0ª
4Siai,s≤0∀i=1... m, alors pas de solution optimale (STOP)
5Min Ratio Test : trouver la ligne rtel que
br
ar,s=min
i=1...m½bi
ai,s:ai,s>0¾
6Appliquer la procédure de Gauss autour de pivot ar,s(ar,s⇝1 et on annule les coefficients situés sous et
sur le pivot dans la colonne s, par combinaisons de lignes) // Ne pas oublier la dernière ligne
7Remplacer (dans VB) la variable de base ( sortante ) située à la ligne rpar la variable ( entrante )xs
8Retourner à l’étape 2 // l'algorithme termine si le programme linéaire est non dégénéré
Remarque 10.
— La dernière ligne représente l’équation linéaire −z+c1x1+···+ cnxn= −c0.
— La valeur de la variable de base de V Bde la ligne k est égale à la valeur b k(de la ligne k).
— La solution optimale du problème est la valeur finale (dernière cellule) (×− 1).
— Si on n’a pas au départ B =Im(à l’aide des variables d’écart) alors, on ajoute les variables artificielles (et on
applique d’abord la phase I - voir section suivante).30 Chapitre 4. Programmation linéaire
Exercice 4.2
Soit le programme linéaire :
max 2 x1+x2
s.t. x1−x2≤3,
x1+2x2≤6,
−x1+2x2≤2,
x1,x2≥0
Rajouter les variables d’écart. Puis résoudre le problème par l’algorithme du simplexe.
Remarque 11. Vérifier le résultat de l’exercice précédent, par la méthode graphique.
4.1.3 Initialisation - Phase I du simplexe
Un programme linéaire est dit sous forme simpliciale si la matrice Acontient la matrice identité Imcomme
sous matrice. On suppose que le programme linéaire P, après la mise en forme AX=b, n’est pas simpliciale
(possible dans le cas de contraintes du type ≥ou du type =). Soit Bune matrice d’ordre mextraite de Ainversible
tel que B−1b≥0et soit XBla solution de base réalisable ( XB≥0etAX B=b), alors on peut changer l’équation
matricielle :
AX B=b
⇐⇒ (B−1A)XB=B−1b
⇐⇒ A∗XB=b∗
et la matrice A∗contient la matrice identité Imcomme matrice extraite ( B−1A=B−1(H|B)=¡
B−1H|Im¢
). Ainsi, on
peut appliquer directement l’algorithme 10 en remplaçant Apar A∗etbpar b∗. Cependant, cette méthode n’est
pas efficace, car il faut trouver une matrice extraite Bréalisable correspondante. Pour une matrice Ade type m×n,
il existe¡m
n¢
matrices extraites à tester !
L ’idée est d’ajouter des variables, dites artificielles w1,w2,..., wm, pour faire apparaître une forme simpliciale
du programme linéaire P: (AX=b). Mais, il faut que w1= ··· = wm=0. Donc, il faut minimiser d’abord le pro-
gramme linéaire P0suivant :
P0=min W=w1+···+ wm
s.t. (A|Im)×(x1...xnw1...wm)T=b
x1,..., xn,w1,..., wm ≥0
On exprime Wà l’aide des autres variables (hors base) et puis on applique l’algorithme du simplexe 10 pour P0
(phase I). À la fin, si on trouve que les wi=0, alors les variables de bases xj1,..., xjmforment une première base
admissible pour démarrer le simplexe pour le programme d’origine P.H. SABRI 31
Remarque 12. On ajoute la ligne de Z :c1 ... cn−c0dans le tableau du simplexe de P0(phase I) et on lui
applique les opérations élémentaire comme avec les autres lignes. À la fin de la phase I, on supprime les colonnes des
wiet la ligne de la fonction W . Finalement, on utilise ce tableau pour résoudre le problème initiale P.
Example 4.3
Soit le programme linéaire P:
min 6 x1+3x2
s.t. x1+x2≥1,
2x1−x2≥1,
3x2≤2,
x1,x2≥0sous forme standard (max)= = = = = = = = = = = = = = = = = = ⇒max Z= −6x1−3x2
s.t. x1+x2−e1=1,
2x1−x2−e2=1,
3x2+e3=2,
x1,x2,e1,e2,e3≥0
La matrice Aest :
A=x1 x2 e1 e2 e3

1 1 −1 0 0
2−1 0 −1 0
0 3 0 0 1
est par suite Pn’est pas sous forme simpliciale (il n’ ya pas de sous matrice I3). Donc on peut ajouter 2
variables artificielles pour construire le problème initiale P0:
max −w1−w2=3x1−e1−e2−2
s.t. x1+x2−e1+w1=1,
2x1−x2−e2+w2=1,
3x2+e3=2,
x1,x2,e1,e2,e3,w1,w2≥0dont le vecteur X=

0 x1
0 x2
0 e1
0 e2
2 e3
1 w1
1 w2est une solution de base réalisable.
Ainsi, on commence notre algorithme 10 pour le programme P0. Le tableau initial est :
x1 x2 e1 e2 e3 w1 w2 b

w1 1 1 −1 0 0 1 0 1
w2 2−1 0 −1 0 0 1 1
e3 0 3 0 0 1 0 0 2
W: 3 0 −1−1 0 0 0 2
Z:−6−3 0 0 0 0 0 0
Le pivot c’est a2,1donc x1est la variable entrante et w2est sortante. On obtient après pivotement le tableau :
L2←1
2L2− − − − − − − − →
L1←L1−L2
L4←L4−3L2
L5←L5+6L2x1 x2 e1 e2 e3 w1 w2 b

w1 03
2−11
20 1−1
21
2
x1 1−1
20−1
20 01
21
2
e3 0 3 0 0 1 0 0 2
W: 03
2−11
20 0−3
21
2
Z: 0 −6 0 −3 0 0 3 3
Le pivot est a1,2(Min ratio test =1
3). On obtient alors :32 Chapitre 4. Programmation linéaire
L1←2
3L1− − − − − − − − →
L2←L2+1
2L1
L3←L3−3L1
L4←L4−3
2L1
L5←L5+6L1x1 x2 e1 e2 e3 w1 w2 b


x2 0 1−2
31
302
3−1
31
3
x1 1 0−1
3−1
301
31
32
3
e3 0 0 2 −1 1 −2 1 1
W: 0 0 0 0 0 −1−1 0
Z: 0 0 −4−1 0 4 1 5
Ainsi, la phase I se termine avec W=0 et x1=2
3,x2=1
3,e3=1 et e1=e2=w1=w2=0. Le tableau pour la
phase II est donc :
x1 x2 e1 e2 e3 b


x2 0 1−2
31
301
3
x1 1 0−1
3−1
302
3
e3 0 0 2 −1 1 1
Z: 0 0 −4−1 0 5
On remarque donc que les cj≤0, donc (STOP) la solution est optimale et le max est −5. Ainsi la solution
optimale pour le programme P=min6 x1+3x2est−(−5)=5=6×2
3+3×1
3.
4.2 Dualité
SoitPun P .L. sous forme canonique. Le programme dualDdePest définit par :
P=max z=cTX
s.t. AX ≤ b
X≥ 0le dual est= = = = = = = ⇒D=min w=bTY
s.t. ATY≥ c
Y≥ 0
Le programme Pest dit primal . On remarque que si Ade type m×n, alors X∈RnetY∈Rmpour le dual.
Théorème 4.1 Théorème de dualité
Si un problème primal ou dual admet une solution, alors l’autre problème admet aussi une solution et on a :
max z=cTX =
s.t. AX ≤ b
X≥ 0min w=bTY
s.t. ATY≥ c
Y≥ 0
Exercice 4.3
Soit le problème suivant de type régime :
D=min w=340x1+2400 x2+560x3
s.t. x1+2x2+x3≥ 1200
x1+3x2+2x3≥ 1400
x1+x2+3x3≥ 1500
x1,x2,x3≥ 0
Écrire le programme primal PdeD. Résoudre le programme Pet déduire la valeur minimale de w, a-t-on
besoin de faire les deux phases du simplexe ?
7} A B oS



HOUSSEM SABRI
Graphes et Optimisation
2`emeannée
LISI  LSI
Institut Supérieur des Sciences Appliquées et de Technologie de Sousse
A.U. 2023-2024
28 novembre 2023Table des matières
1 Les graphes 3
1.1 Définitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.1 Graphes non orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.2 Graphes orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.2 Opérations et quelques types de graphes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.3 Représentation d’un graphe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.1 Listes d’adjacences (ou de succession) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.2 Matrices d’adjacence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.3.3 Matrice d’incidence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2 La connexité 11
2.1 Les chaînes et les cycles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.2 Graphe connexe, eulérien, hamiltonien . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.3 Arbres . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.3.1 Codage et décodage d’un arbre – Prüfer code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.3.2 Arbre couvrant de poids minimum – ACM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3 Les algorithmes de base 20
3.1 Parcours en profondeur (DFS) / largeur (BFS) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
3.2 Recherche des chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.1 Matrice d’adjacence et nombre de chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.2 Plus court chemin et l’algorithme de Dijkstra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
3.3 Problèmes d’ordonnancement et chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
3.3.1 Algorithmes de tri topologique et de chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . 25
4 Programmation linéaire 27
4.1 La méthode simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.1 Solution de base admissible . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux . . . . . . . . . . . . . . . . . . . . . . . . 29
4.1.3 Initialisation - Phase I du simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
4.2 Dualité . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
2CHAPITRE 1
Les graphes
L ’exemple classique pour introduire la théorie des graphes est le problème des ponts de Königsberg, étudié par
Euler en 1736. Quel itinéraire doit-on suivre pour traverser chaque pont exactement une fois? Une telle prome-
nade n’existe pas, et c’est Euler qui donna la solution de ce problème en caractérisant les graphes que l’on appelle
aujourd’hui eulériens .
A
B
Ce1 e2
e3 e4
De5
e6e7
FIGURE 1.1 – Les ponts de Königsberg
Les graphes introduisent une simplification : les régions se transforment en des "points" (aussi appelés noeuds
ousommet ), les ponts se transforment en des lignes (aussi appelées arêtes ouarcs ), et ce principe s’applique dès
lors qu’une relation existe entre des objets. Les graphes relèvent de la combinatoire plutôt que de la géométrie (les
intersections, les longueurs, et la forme des arêtes n’ont aucune importance, sauf en ce qui concerne la lisibilité de
la représentation).
1.1 Définitions
Dans la suite, il est toujours supposé que les graphes sont finis, sauf indication contraire.
1.1.1 Graphes non orientés
Définition 1.1: Graphe
Un graphe Gest un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V{2}des pairs non ordon-
nées de V.Vest l’ensemble des noeuds (Vertices en anglais) et Ec’est l’ensemble des arêtes de G(Edges en
anglais). Lorsque e={x,y} est une arête, on dit que x, y sont les extrémités de cette arête, que eest incidente
enxet en y. On joint x et y par un trait et on dit que x, y sont adjacents (ou voisins). On note aussi e=x you
encore e=(x,y) (attention , dans ce cas : ( x,y)=(y,x)).
SiGest un graphe alors, on note par V(G) l’ensemble de noeuds et par E(G) l’ensemble des arcs.
Remarque 1.
— Une arête e ={x,x}s’appelle boucle .
— Dans un graphe, il peut exister des arêtes parallèles (on parle donc de multigraphe ).
Dans l’exemple des ponts on a : e 1=e2=(A,B).
34 Chapitre 1. Les graphes
— Un graphe est dit simple s’il ne comporte ni arêtes multiples ni de boucles, c’est-à-dire chaque paire de nœuds
distincts est reliée par au plus une arête, ou encore E (G)⊆P2(G).
Dans la plupart des cas, les graphes sont considérés comme simples par défaut.
Définition 1.2: ordre – taille – degré
Soit G=(V,E) un graphe.
1. On appelle ordre d’un graphe noté v(G) le nombre de ses sommets :
v(G)= |V|
2. On appelle taille d’un graphe noté e(G) le nombre de ses arêtes :
e(G)= |E|
3. Le degré (ou valence) d’un sommet xnoté d(x) est le nombre d’arêtes contenant x. (Attention! Une
boucle sur un sommet compte double).
Si on note par Γ(x) l’ensemble des voisins de x, i.e.
Γ(x)={y∈V:x y∈E}
alors, siGest simple , on a :
d(x)= |Γ(x)|
Example 1.1 (Graphe complet)
Un graphe d’ordre nest dit complet noté Knsi chaque sommet du graphe est relié directement à tous les
autres sommets, i.e. E(Kn)=P2(V(Kn)).
Représenter graphiquement K3,K4,k5. Calculer la taille de K3,k4,...Kn.
Example 1.2 (Graphe biparti)
Un graphe G=(V,E) est dit biparti si son ensemble de sommets V=V1˙∪V2, i.e. peut être divisé en deux
sous-ensembles disjoints V1etV2tels que chaque arête ait une extrémité dans V1et l’autre dans V2.
Si∀x∈V1,∀y∈V2;x y∈E, alors Gest dit biparti complet noté Kn,moùn= |V1|etm= |V2|.
a1
 a2
 a3
 a4
b1
 b2
 b3
FIGURE 1.2 – Un graphe biparti
Théorème 1.1 Lemme des poignées de main – Handshaking lemma
Soit Gun graphe alors, on a :X
x∈V(G)d(x)=2e(G)
Dans ce théorème d(x) est le nombre de personnes à qui xserre la main et e(G) le nombre total de poignées
de mains.H. SABRI 5
Preuve.
•Méthode simple Il y en a d(x) arêtes en un sommet xfixé. Pour tout les sommets cela fait doncP
x∈V(G)d(x).
Mais avec cette manière chaque arête est comptée deux fois, une fois à chacune de ses extrémités, d’où le
résultat en divisant par 2.
•Preuve par double dénombrement On pose
Z={(x,e)∈V×E:x∈e}⊆V×E
et les deux projections :
p:Z→V
(x,e)7→xet q:Z→E
(x,e)7→e
L ’idée est de calculer |Z|de deux manières différentes. D’abord, on rappelle que si f:A→Best une fonction
quelconque, alors :X
b∈B|f−1[b]| = | A|
oùf−1[b] désigne l’image réciproque de { b} par f(pourquoi ˙S
b∈Bf−1[b] est une union disjointe ?).
Ainsi on obtient :
|Z| =X
x∈V|p−1[x]| =X
e∈E|q−1[e]|
Or,|p−1[x]| =d(x) et|q−1[e]| = |{x∈V:x∈e}| =2. Donc :
X
x∈Vd(x)=X
e∈E2=2|E|
Remarque 2.
— Un sommet de degré 0est appelé sommet isolé .
— Un graphe tel que : ∀x∈V,d(x)=kest dit graphe k-régulier .
— Le graphe complet K nest un graphe (n−1)-régulier .
Exercice 1.1
Montrer que dans un graphe le nombre de sommets d’ordre impairs est toujours pair. En particulier un
graphe k-régulier avec kimpaire est un graphe d’ordre pair.
Voici quelques exemples comme application :
1. Est-il possible de relier 15 ordinateurs en réseau de sorte que chacun soit relié à exactement 3 autres ?
2. Une ligue de football comprenant 11 clubs organise un tournoi. Pour gagner du temps on décide que chaque
équipe ne jouera que la moitié des matches possibles. Comment organiser le tournoi ?
Proposition 1.1
Soit G=(V,E) un graphe (simple) d’ordre n≥2. Alors :
∃u,v∈V,u̸=v:d(u)=d(v)
Preuve. Supposons le contraire, c’est-à-dire ∀u,v∈V;d(u)̸=d(v). Or dans un graphe (simple) on a toujours d(x)∈
{0,1,..., n−1}. Dans ce cas, puisque tous les nsommets ont des degrés distincts, alors il existe une bijection
{d(x):x∈V}←→ {0,1,..., n−1}
Donc, il existe un sommet uavec un degré 0, et un sommet vavec degré n−1, donc vest connecté à tous les autres
sommets du graphe, ce qui signifie que une peut pas être un sommet isolé, d’où une contradiction.6 Chapitre 1. Les graphes
1.1.2 Graphes orientés
Les arêtes d’un graphe peuvent être orientées, auquel cas une flèche indique la direction. De tels graphes sont
appelés des graphes orientés ou des digraphes , et une arête ( a,b) dans un tel graphe indique que cette arête est
dirigée de sommet avers b, i.e. ( a,b)=− →ab̸=(b,a)=− →ba. D’où la définition :
Définition 1.3: Graphe orienté - digraphe
Un graphe orienté G(ou− →G) est un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V2des pairs
ordonnées de V.Eest l’ensemble des arêtes (ou flèches, arcs) de G. Lorsque e=(x,y) est une arête, on dit
que xestl’origine (ou sommet initiale) et yl’extrémité (ou sommet terminale) de e, que eest sortant en x
et incident en y, et que yest un successeur de xtandis que xest un prédécesseur de y. On note l’arête e
par :
e=(x,y)=− →x y=x→y
De la même façon, une arête x→xest une boucle. On peut toujours supprimer les boucles pour obtenir des
digraphes simples. Voici l’exemple d’un digraphe G=(V,E) d’une fonction f:E→Eoù ( x,y) est un arc si et seule-
ment si y=f(x). On l’appelle digraphe fonctionnelle.
0
3
1214
11 568
169
4
2 1
713 10
15
FIGURE 1.3 – Le digraphe fonctionnelle Gfdex7→(x2+3) mod 17.
Comme dans les graphes on peut définir les degrés (entrant, sortant) d’un sommet dans un digraphe.
Définition 1.4: indegree - outdegree
Soit G=(V,E) un digraphe. Pour v∈V, on note par :
d+(v) le degré extérieur (sortant - outdegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité initiale.
d+(v)= |{v→ •}|
d−(v) le degré intérieur (entrant - indegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité finale.
d−(v)= |{• → v}|
On définit le degré : d(v)=d−(v)+d+(v).
Un sommet de degré entrant non nul et de degré sortant nul est appelé puits , tandis qu’un sommet de
degré entrant nul et de degré sortant non nul est appelé source ouracine .
Dans un graphe orienté, les voisins d’un sommet vsont soit des successeurs ou des prédécesseurs. On les notes
par :
Γ+(x)=Succ (x)={y∈V:x→y∈E} et Γ−(x)=Pr ed (x)={y∈V:y→x∈E}H. SABRI 7
Si le digraphe est simple (ni boucle ni arcs parallèles) on a :
d−(v)= |Γ−(v)|et d+(v)= |Γ+(v)|
Proposition 1.2
Soit Gun digraphe, alors :X
v∈Vd−(v)=X
v∈Vd+(v)= |E|
Preuve. On a
E=˙[
v∈V{• → v}=˙[
v∈V{v→ •}
=⇒ | E| =X
v∈V|{• → v}| =X
v∈V|{v→ •}| =⇒ | E| =X
v∈Vd−(v)=X
v∈Vd+(v)
1.2 Opérations et quelques types de graphes
Une opération sur les graphes permet de construire un nouveau graphe comme résultat de l’opération. Les
opérations courantes sur les graphes sont la suppression, la valuation, l’union, l’intersection et le produit cartésien.
Graphe valué
Tout d’abord, on peut vouloir attribuer des valeurs aux arcs ou arêtes pour tenir compte de contraintes : dis-
tance, coût ...
Définition 1.5: (di)graphe valué
Un (di)graphe valué G=(V,E,w) est un (di)graphe muni d’une application w:E→R. L ’application west
appelée application poids ou coût. On indique sur chaque arête son poids (ou son coût). On note w(x,y)
au lieu de w((x,y)). On convient (même que ceci n’a pas de sens!) que w(x,y)= +∞ si (x,y)∉E.
ab
c
d
ef53
43
3
335
81
FIGURE 1.4 – Un digraphe valué
/pythonPython code : -
Implémenter le digraphe valué précédent avec python. Indice – use chatGPT : how to build a weighted digraph with
python8 Chapitre 1. Les graphes
Sous graphes
Soit G=(V,E) un graphe (orienté ou non). Un sous graphe de Gest un graphe de la forme G′=(V′,E′) où
V′⊆V,E′⊆Etels que toute arête de E′a ses extrémités dans V′(ou encore G′est aussi un graphe). On a :
•Sous-graphe induit Un sous-graphe G′=(V′,E′) de G=(V,E) est appelé un sous-graphe induit deGsi :
∀x,y∈V′; (x,y)∈E′⇐⇒ (x,y)∈E
En d’autres termes, deux sommets de G′qui sont connectés dans G, sont également connectés dans G′.
•Sous-graphe couvrant Un sous-graphe couvrant G′deGcontient tous les sommets de G, i.e. V′=V.
•G−vSupprimer un sommet vd’un graphe Gconsiste à supprimer vet toutes ses arêtes incidentes. Le sous-
graphe obtenu de cette opération est noté G−v, i.e.
V′=V−{v} et E′=E−{(v,y): (v,y)∈E}
De manière similaire, une arête epeut être supprimée (resp. ajoutée) d’un graphe G, et le sous-graphe
résultant est représenté par G−e(resp. G+e). Notez que la suppression d’une arête ne retire pas de sommets
du graphe.
•G−V′=G[V′] On supprimer tous les sommets v∈V′du graphe Gavec les arêtes incidentes. Le sous-graphe
obtenu de cette opération est noté G[V′], i.e.
V(G[V′])=V−V′et E(G[V′])=E−{(v,y)∈E:v∈V′}
•Clique Une clique Cd’un graphe Gest un sous-ensemble des sommets de Gdont le sous-graphe induit G′=
(C,E′) est un graphe complet, en d’autres termes, deux sommets quelconques de la clique Csont toujours
adjacents.
•Stable Un stable – appelé aussi ensemble indépendant (independent set en anglais) est un ensemble de som-
mets deux à deux non adjacents. Donc le sous-graphe induit est sans arcs.
FIGURE 1.5 – L ’ensemble des sommets en bleu dans ce graphe est un stable maximal du graphe.
Note : -
Le problème décisionnel de la clique (c’est à dire existe t-il une clique de taille k) est NP-complet . De même la
recherche d’un stable de taille maximum dans un graphe est un problème NP-complet et difficile à approximer.
Exercice 1.2
Trouver un plus grand stable et une plus grande clique du graphe suivant :
8
4
62 7
3
1 5
Indice : vérifier le résultat avec networkx.find_cliques(G) et.maximum_independent_set(G) de python.H. SABRI 9
Opérations binaires
Union L ’union de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∪H=(VF,EF) dans lequel
VF=VG∪VH et EF=EG∪EH
Intersection L ’intersection de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∩H=(VF,EF)
dans lequel
VF=VG∩VH et EF=EG∩EH
1.3 Représentation d’un graphe
Il est important de savoir comment représenter les graphes au sein d’un ordinateur. Il ya plusieurs méthodes
selon la nature des traitements que l’on souhaite appliquer au graphe considéré.
1.3.1 Listes d’adjacences (ou de succession)
Soit Gun (di)graphe. On suppose que les sommets de Gsont numérotés de S1àSn. La représentation par listes
d’adjacence de Gconsiste en un tableau (ou des listes chainées) tel que la ligne i=1... ncorrespond au sommet Si
et comporte la liste des voisins/successeurs (ou des prédécesseurs) de ce sommet notée T[Si]. Les sommets dans
chaque liste d’adjacence sont généralement listés selon un ordre arbitraire.
1
2
345
FIGURE 1.6 – Un digraphe
La liste d’adjacence de digraphe 1.6 est donc :
1 2 3 4 5
2 3
3 4
4−
5 1 410 Chapitre 1. Les graphes
1.3.2 Matrices d’adjacence
Définition 1.6: Mat. Adjacence
Soit G=(V,E) un graphe (orienté) d’ordre n. On peut numéroter V={1,2,..., n}.La matrice d’adjacence
deGest la matrice carrée A=(ai j) d’ordre n, définie par :
ai j=(
1 si ( i j)∈E;
0 sinon.
Remarque 3.
1. Si le graphe G est non orienté et simple, alors la matrice A est symétrique avec des 0sur la diagonale. Pour un
digraphe simple, on a toujours des 0sur la diagonale, mais la matrice n’est pas symétrique en général.
2. Pour les multigraphes, il peut y avoir des termes diagonaux (pour les boucles) et s’il y a plusieurs arêtes de i à
j , le coefficient de la matrice a i jest le nombre d’arêtes de i à j .
3. Pour un (di)graphe valué G =(V,E,w), on pose :
ai j=(
w(i,j)si(i j)∈E ;
∞ sinon.
La matrice d’adjacence de la figure 1.4 est :

∞ 5∞ 4 3 ∞
∞ ∞ 3∞ 1∞
∞ ∞ ∞ ∞ ∞ 5
∞ ∞ 3∞ 3 3
∞ ∞ ∞ ∞ ∞ 8
∞ ∞ ∞ ∞ ∞ ∞

1.3.3 Matrice d’incidence
Définition 1.7: Mat. Incidence
Soit G=(V,E) un graphe (simple) d’ordre net de taille m. On pose V={v1,v2,..., vn} etE={e1,e2,..., em}.
La matrice d’incidence deGest la matrice de type n×m B=(bi j), définie par :
•Si G orienté
bi j=

1 si ej=vi→ • (i.e. viest l’extrémité initiale de ej) ;
−1 si ej= • → vi(i.e. viest l’extrémité terminale de ej) ;
0 sinon.
•Si G non-orienté
bi j=(
1 si viest une extrémité de ej;
0 sinon.
Exercice 1.3
1. Donner la matrice d’incidence du graphe 1.6.
2. Montrer le théorème 1.1 avec la matrice d’incidence.CHAPITRE 2
La connexité
Il est important de savoir si on peut suivre un chemin d’un sommet donné à un autre dans un graphe donné.
Cette propriété (de connexité) doit être maintenue dans différents types de réseaux.
2.1 Les chaînes et les cycles
Définition 2.1: (chaine – cycle) (chemin – circuit)
•Graphe non orienté
1. Une chaîne (walk ) reliant xày, notée µ(x,y), est définie par une suite finie d’arêtes consécutives,
reliant xày, ou encore une séquence de sommets (puisque non multigraphe)
µ(x,y)=<v0,v1,..., vk>
tels que v0=x,vk=yet (vi−1,vi)∈E(G) pour tout i=1... k. Six=yla chaîne est dite fermée .
Lalongueur du chaîne l(µ(x,y)) est le nombre d’arcs dans la chaîne, c’est-à-dire k.
2. Une chaîne élémentaire (a path ) si tous les sommets sont distincts. Une chaîne simple (a simple
walk, a trail ) est une chaîne ne passant pas deux fois par une même arête, c’est-à-dire dont toutes
les arêtes sont distinctes. Remarquer que : élémentaire =⇒ simple.
3. Un cycle v0v1...vnde longueur n≥3 est une chaîne simple fermée ( v0=vn) tel que les sommets
v0,v1,..., vn−1sont tous distincts. Un graphe sans cycle est dit acyclique .
•Graphe orienté
Dans un graphe orienté, on parlera de chemin au lieu de chaîne, et de circuit au lieu de cycle.
Example 2.1
abxcd xa est une chaîne simple et fermée (non cycle!) de longueur 6 (mais, c’est un graphe eulérien - voir
plus loin). Y a-t-il un cycle de longueur 3,4 ?
a b
x
c dÏ
Remarque 4.
1. On peut pivoter une chaine fermée (l’orienter de manière arbitraire) , i.e.
<v0,v1,v2,..., v0>=< vk,vk+1,..., v0,v1,..., vk>
1112 Chapitre 2. La connexité
2. Soient x ,y∈V . La distance de x à y est définie par :
d(x,y)=(
k si le plus court chemin/chaîne de x vers y est de longueur k
∞ sinon
On convient que d (x,x)=0.
3. Le diamètre du graphe la plus grande distance entre deux sommets.
L ’observation suivante, bien que très facile à prouver, sera utile.
Théorème 2.1
S’il existe une chaîne du sommet yau sommet zdans le graphe G, où y̸=z, alors il existe une chaîne élé-
mentaire ( path ) dans Gavec pour premier sommet yet pour dernier sommet z.
Preuve. Soit la chaine
W1=µ(y,z)=x0x1...xn; avec x0=yetxn=z.
Si les sommets x0,x1,..., xnsont tous distincts, alors W1est une chaîne élémentaire, et nous avons terminé. Sinon,
il existe xi=xj(i<j) et on écrit :
W2=x0x1...xixj+1...xn.
Alors, l(W2)<l(W1). Si W2ne contient aucun sommet répété, alors c’est la chaîne recherché. Sinon, par la même
procédure, il existe W3(y z−chaîne) tel que
l(W3)<l(W2)<l(W1).
Ce processus doit s’arrêter à un certain stade, car chaque chaîne est plus courte que la précédente et la longueur
ne peut jamais être inférieure à 1
1< ··· < l(Wk)< ··· < l(W3)<l(W2)<l(W1).
Ainsi, pour un certain k,Wkne peut pas être réduit en longueur. Donc, la chaîne Wkne contient aucun sommet
répété et est donc une y z−chaîne élémentaire (path).
Exercice 2.1
Dans le graphe suivant, construire un path à partir de la chaîne W=v2v3v4v5v6v4v2v8v1
v1
 v2
v3
v4
v5
v6
v7
 v8
 v9
Calculer d(v1,v7) et le diamètre de G.
/pythonpython : >>G = nx.Graph([(1, 2), (2, 3), (2, 4), ...]) >>nx.diameter(G)
Les cycles fournissent la caractérisation suivante pour les graphes bipartis .H. SABRI 13
Théorème 2.2
Un graphe est biparti si et seulement s’il ne contient aucun cycle de longueur impaire.
Preuve.
⇒On suppose que G=U˙∪Vest un graphe biparti. Soit W=< x1,x2,..., x2k+1,x1>un cycle de longueur im-
paire (2 k+1). Si x1∈U, alors
x1∈U=⇒ x2∈V=⇒ x3∈U=⇒ ··· =⇒ x2k+1∈U=⇒ x1∈V/exclamati⌢n-triangle
absurde, d’où le résultat.
⇐On suppose que Gest connexe (car l’union des composantes connexes bipartis est un graphe biparti). Soit
xun sommet de Get on pose :
U={y∈V(G):d(x,y) est paire} et V={z∈V(G):d(x,z) est impaire}
S’il existe y1,y2∈Utel que y1y2∈E(G), alors on a :
W1=<x,..., y1>est une chaîne de longueur paire =2k1
W2=<x,..., y2>est une chaîne de longueur paire =2k2
=⇒ W3=<x,..., y1,y2,..., x>est un cycle de longueur impaire =2k1+2k2+1/exclamati⌢n-triangle
Donc G=U˙∪Vest un graphe biparti.
Exercice 2.2
Vérifier si le graphe maison est un graphe biparti. Faire de même pour la grille G4,4.
maison grille
2.2 Graphe connexe, eulérien, hamiltonien
Définition 2.2: Graphe connexe
Un graphe est dit connexe si deux points peuvent toujours être joints par une chaîne, i.e.
∀x,y∈V(G),d(x,y)< ∞
— Une composante connexe d’un graphe est un sous-graphe induit maximal connexe.
— Un point d’articulation d’un graphe est un sommet dont la suppression augmente le nombre de
composantes connexes.
Par exemple, le graphe suivant :14 Chapitre 2. La connexité
a
 b
d
 c
e
f
 g
n’est pas connexe car il n’existe pas de chaîne entre les sommets aete. On a donc 2 composantes connexes. En
revanche, le sous-graphe induit par les sommets { a,b,c,d} est connexe dont aest le seul point d’articulation.
Remarque 5.
1. Un graphe connexe à n sommets possède au moins n −1arêtes ( faite une preuve par récurrence ).
2. L’algorithme de parcours en profondeur permet de déterminer si un graphe est connexe ou non.
3. Même définitions dans un graphe orienté . Graphe orienté (fortement) connexe et de composante connexe .
Définition 2.3: Graphe eulérien
— Une chaîne joignant deux sommets xetyest dite chaîne eulérienne si elle emprunte chaque arête
deGune et une seule fois. On parle de chemin eulérien dans le cas d’un graphe orienté.
— Un cycle eulérien est une chaîne eulérienne dont les extrémités coïncident. Un graphe qui admet
un cycle (resp. circuit) eulérien est dit graphe eulérien .
/flushedRemarquer qu’un cycle eulérien n’est pas forcément un cycle comme définit dans la définition 2.1
Si un graphe (ou multigraphe) Gpossède une chaîne eulérienne, alors soit Gpossède deux sommets impairs, le
début et la fin de cette chaîne, soit Gn’a aucun sommet impair, et la promenade d’Euler commence et se termine
au même point (cycle eulérien). Une autre condition nécessaire évidente est que Gdoit être connexe. Ces deux
conditions sont ensemble suffisantes.
Théorème 2.3 Euler
Soit Gun graphe (multigraphe) connexe.
— Si Gn’a pas de sommets impairs, alors il possède un cycle eulérien (commençant à n’importe quel
point).
i.e.∀x,d(x)≡0 mod 2 =⇒ Gest un graphe eulérien.
— Si Ga deux sommets impairs, alors il possède une chaîne eulérienne dont le début et la fin sont les
sommets impairs.
La réciproque est aussi vraie.
Preuve.
⇐On commence par la réciproque. S’il existe une chaîne eulérienne µ(x,y), alors on peut crée une arête fictive
e=(y,x) et par la suite on obtient un cycle eulérien. Donc il suffit de montrer que si Gadmet un cycle
eulérien alors tous les sommets sont de degré pair.
Soit W=< v1,v2,..., vn,v1>un cycle eulérien. Soit le sommet vjavec j̸=1, il est donc claire que chaque
fois vjapparaît dans W, il ya deux arcs distincts incidents en vj( (•,vj) et ( vj,•)). Comme toutes les arêtes
sont utilisées, on voit que d(vj) est pair. Même chose pour v1car on ajoute deux arcs ( v1,v2) et ( v1,vn).
⇒On suppose que tous les sommets sont de degré pair. Montrons que Gadmet un cycle eulérien. Puisque
tous les sommets sont de degré pair on peut construire d’abord une chaîne simple fermée (quelconque)
W1=<v1,v2,..., vk,v1>
SiW1contient chaque arête de G, alors c’est finis, c’est un cycle eulérien. Sinon (puisque Gest connexe), il
existe une arête e=(vi,c) qui n’est pas dans W1(avec visommet de W1). On pose le sous-graphe
G′=G−{ arêtes de W1}H. SABRI 15
Il est donc claire que les sommets de G′sont aussi de degré pair. Alors, par la même procédure on construit
une chaîne simple fermée dans G′de la forme : <vi,c,d,..., vi>et par la suite on insère cette chaîne dans
W1pour obtenir :
W2=<v1,v2,..., vi,c,d,..., vi,vi+1,..., vk,v1>
Sil(W2)< |E(G)|, on construit W3de longueur plus grand. Ainsi, on a :
l(W1)<l(W2)<l(W3)< ··· ≤ | E(G)|
Donc, nécessairement, il existe Wk(chaîne simple fermée de longueur |E(G)|) donc c’est un cycle eulérien.
Finalement , si∃a,b∈V(G):d(a)≡d(b)≡1 mod 2, et tous les autres sommets sont de degré pair, alors on
pose :
G′=G+{a,b}
et donc tous les sommets de G′sont de degré pair. Avec la construction précédente, il existe un cycle eulérien
dans G′:
W=<a,b,v1,..., a>
est donc la chaîne <b,v2,..., a>est une chaîne eulérienne dans G.
Algorithme 1 : Euler
Entrées : Gun graphe eulérien
Output : Un cycle eulérien W
/* On suppose que G est eulérien, i.e. les sommets sont de degré pair */
1Gaux←G;W←µ(v,v) une chaîne simple (quelconque) de G; // Initialisation
2tant que l(W)<e(G)faire
3 Gaux←G−{ arêtes de W} ;
4 Choisir ( x,c)∈E(Gaux) tel que x∈W;
5 L←< x,c,..., x>une chaîne simple de Gaux ;
6 Dans W, remplacer (juste ce) xpar la séquence L;
7fin
8retourner W;
Exercice 2.3
1. Montrer que le graphe de l’exercice 2.1 est un graphe eulérien et donner un cycle eulérien.
2. Tracer cette maison d’un seul trait.
Remarque 6. Le théorème d’Euler dans un graphe orienté connexe s’écrit :
Admet un circuit eulérien si, et seulement si, pour tout sommet, le degré entrant est égal au degré sortant.
∀v∈V(G),d+(v)=d−(v)
Admet un chemin eulérien de a vers b si, et seulement si,


d+(v)=d−(v) ;∀v̸=a,b,
d−(a)=d+(a)−1
d−(b)=d+(b)+116 Chapitre 2. La connexité
Définition 2.4: Graphe hamiltonien
Soit Gun graphe connexe d’ordre n. On appelle :
1. On appelle cycle hamiltonien deGun cycle passant (une et une seule fois) par chacun des sommets
deG. Un graphe est dit hamiltonien s’il possède un cycle hamiltonien.
2. Une chaîne hamiltonienne est une chaîne passant une et une seule fois par chacun des sommets de
G. Un graphe ne possédant que des chaînes hamiltoniennes est semi-hamiltonien .
3. Dans un digraphe, on change cycle par circuit et chaîne par chemin .
Remarque 7.
— Une chaîne hamiltonienne est une chaîne élémentaire de longueur n −1.
— Un graphe peut être eulérien, hamiltonien, les deux à la fois, ou aucun des deux.
— De nombreux problèmes concrets peuvent être formulés en termes de recherche de parcours hamiltoniens : pro-
blème du voyageur de commerce (chercher un cycle hamiltonien de longueur totale minimale), l’ ordonancement
de tâches .
— Le problème du chaîne hamiltonienne est un problème NP-complet .
Exercice 2.4
Donner un graphe (connexe, simple) qui soit :
1. hamiltonien et eulérien.
2. hamiltonien et non eulérien.
3. eulérien et non hamiltonien.
4. non hamiltonien et non eulérien.
Aucune condition nécessaire et suffisante adéquate n’est connue pour l’existence de cycles hamiltoniens. Le
résultat suivant constitue une condition suffisante utile.
Théorème 2.4 Ore
Soit Gun graphe simple d’ordre n≥3. Si pour toute paire { x,y} de sommets non adjacents, on a d(x)+d(y)≥
n, alors Gest hamiltonien.
Preuve. On suppose que le théorème est faux. Alors, il existe un graphe Gsimple d’ordre nnon hamiltonien tel que
d(u)+d(v)≥npour tout sommets non adjacents uetv. On prend Gun tel graphe d’ordre nde taille maximale qui
vérifie cette propriété (remarquer que le graphe complet Knest hamiltonien).
Soient uetvdeux sommets non adjacents de G. Par maximalité de G, le graphe G+uv(d’ordre n) doit être
hamiltonien. Donc il existe dans G+uvun cycle hamiltonien :
W=<u,x1,x2,..., xn−2,v,u>
u
x1
xi xi+1xn−2
v
... ...
Or, si uxi+1∈E(G) etv xi∈E(G) (les arcs en rouge), alors on peut construire dans Gle cycle hamiltonien :
<u,x1,x2,..., xi,v,xn−2,..., xi+1,u>H. SABRI 17
Ceci est absurde car Gest non hamiltonien. Donc si xi+1est un sommet voisin à u, alors le sommet xin’est pas
voisin de v:
xi+1∈Γ(u)=⇒ xi∉Γ(v)
Donc :
d(u)= |Γ(u)| =p=⇒ d(v)≤(n−1)−p
et par la suite
d(u)+d(v)≤n−1
ce qui absurde par hypothèse. Donc Gest hamiltonien.
Une conséquence immédiate est le théorème de Dirac :
Proposition 2.1 Dirac
Soit Gun graphe simple d’ordre n≥3. Si pour tout sommet xdeG, on a d(x)≥n
2, alors Gest hamiltonien.
2.3 Arbres
Définition 2.5: Arbres et forêts
On appelle arbre tout graphe (non orienté) connexe et acyclique . Les composantes connexes dans un
graphe acyclique sont des arbres et le graphe est dit forêt . Une feuille ou sommet pendant est un som-
met de degré 1.
Un forêt avec deux arbres
Un graphe Gest une arborescence s’il existe un sommet Rappelé racine deGtel que, pour tout sommet
SdeG, il existe un chemin et un seul de Rvers S. Donc, c’est un arbre orienté dans lequel on choisit un
sommet Rcomme racine et on dirige les arcs vers le sens sortant de la racine.
Remarque 8.
— Un graphe G d’ordre n est un arbre ssi G est sans cycle et possède n −1arêtes.
— Un graphe G d’ordre n est un arbre ssi G est connexe et possède n −1arêtes.
— G est un arbre si pour chaque paire u ,v de sommets distincts est reliée par une seule chaîne (donc chaîne
élémentaire d’après le théorème 2.1).
— Un arbre (ou forêt) est nécessairement un graphe simple.
Pour démontrer les remarques précédentes, il suffit de prouver le théorème suivant :
Théorème 2.5
Soit Gun graphe ayant marêtes, nsommets et pcomposantes connexes, on définit nu( G) :
ν(G)=m−n+p
Alors, on a :
1.ν(G)≥0.
2.ν(G)=0⇐⇒ Gest acyclique.18 Chapitre 2. La connexité
Preuve. Par récurrence sur la taille mdu graphe. Le résultat est évident pour m=0 et m=1. On suppose le résultat
est vrai pour les graphe de taille m, et montrons que ceci est vrai pour un graphe de taille m+1. Soit donc Gun
graphe d’ordre nde taille m+1 ayant pcomposantes connexes.
•On suppose que Gest un graphe acyclique. Soit uvune arête de Gdans la composante C. Si on supprime uv,
la composante Cse transforme en deux composantes connexes (sinon on a un cycle dans G). Par la suite,
le graphe G′=G−uvest un graphe acyclique d’ordre n, de taille met ayant p+1 composantes connexes.
Donc d’après l’hypothèse de récurrence :
ν(G′)=0=(m−1)−n+(p+1)=m−n+p=ν(G)
•Maintenant, si Gcontient un cycle Wdans la composante connexe C. Soit uvune arête de W, alors si on
supprime l’arête uv, la composante Creste connexe. Donc le graphe G′=G−uvest un graphe d’ordre nde
taille m−1 ayant pcomposantes connexes. Donc, d’après l’hypothèse de récurrence :
ν(G′)=(m−1)−n−p≥0
=⇒ν(G)=m−n−p≥1>0
D’où le résultat – car si ν(G)=0,Gne peut être que acyclique, sinon 0 =ν(G)≥1/exclamati⌢n-triangle
2.3.1 Codage et décodage d’un arbre – Prüfer code
Soit Tun arbre ayant nsommet numérotés {1,2,..., n}. Le codage de Prüfer représente l’arbre Tarbre de avec
une suite P=(x1,x2,x3,..., xn−2) de n−2 termes (les n° des sommets avec répétition possible). Une suite Pdonnée
correspond à un et un seul arbre numéroté. Voici les algorithmes de codage et de décodage.
Algorithme 2 : Codage de Prüfer
Entrées : Un arbre T
Output : Séquence de Prüfer P
1P←() ; // Initialisation de P comme séquence vide
2tant que v(T)>2faire
3 x←feuille de Tayant le n° minimum ; // donc d(x)=1
4 P←(P,s) où sest le seul (n°) sommet adjacent à x;
5 T←T−x;
6fin
7retourner P;
Example 2.2
Donner le code de Prüfer de l’arbre :
126 345
Indice : on trouve, P=(2,3,3,2)
Pour faire la réciproque, étant donnée une séquence P=(x1,x2,..., xn−2) où les xi∈{1,2,..., n}, on construit
l’arbre Tdont les sommets sont {1,2,..., n} avec l’algorithme suivant (le décodage) :H. SABRI 19
Algorithme 3 : Décodage de Prüfer
Entrées : Une séquence Pde taille n−2
Output : L ’arbre Tcorrespondante
1I←{1,2,..., n};
2T←graphe tel que V(T)=IetE(T)= ; ; // T graphe à n sommets isolés
3tant que P̸=()faire
4 i←min {x∈I:x∉P};
5 T←T+(i,P[1]) ; // ajouter l'arc (i,P[1])
6 P←P−P[1];I←I−{i};
7fin
8T←T+(a,b) ; // a,b sont les deux éléments restant dans I
9retourner T;
Example 2.3
Donner l’arbre dont le code de Prüfer est : P=(2,3,3,3)
Puisqu’il ya une bijection entre les arbres d’ordre net les suites Pde longueur n−2 à coefficients dans {1,2,..., n},
on déduit le théorème de Cayley :
Théorème 2.6 Formule de Cayley
Le nombre d’arbres que l’on peut construire sur n(n≥2) sommets numérotés est égal à nn−2.
2.3.2 Arbre couvrant de poids minimum – ACM
Soit Gun graphe (non orienté). Un arbre couvrant (spanning tree) TdeGest un sous graphe couvrant de G
tel que Test un arbre. Remarquer que, Gdoit être connexe, sinon un arbre couvrant de Gn’existe pas. Le nombre
des arbres couvrant de Gest noté a(G). Remarquer que a(Kn)=nn−2(le nombre de Cayley). Un problème algo-
rithmique classique est de trouver, dans un graphe valué , un arbre couvrant de poids minimal . On dispose de
plusieurs algorithmes (l’algorithme de Prim, l’algorithme de Kruskal ...).
Algorithme 4 : Kruskal
Entrées : Un graphe Gvalué d’ordre net de taille m
Output : Arbre (ou forêt) couvrant de poids minimum
1Numéroter les arêtes de Gpar poids minimum : w(e1)≤w(e2)≤ ··· ≤ w(em)
2T←graphe tel que V(T)=V(G) etE(T)= ; ; // T graphe à n sommets isolés
3k←0;
4tant que k<m et e (T)<n−1faire
5 siT+ek+1est acyclique alors
6 T←T+ek+1;
7 k←k+1;
8fin
9retourner T;
Appliquer l’algorithme de Kruskal dans le graphe suivant :
CHAPITRE 3
Les algorithmes de base
Beaucoup de problèmes sur les graphes nécessitent que l’on parcourt l’ensemble des sommets et des arcs. Par
exemple, pour vérifier que le graphe est connexe, chercher un sommet particulier, construire un arbre couvrant,
trouver un plus court chemin ...etc.
3.1 Parcours en profondeur (DFS) / largeur (BFS)
Une manière simple de tester si un graphe Gest connexe ou non est d’exécuter l’algorithme DFS ouBFS dans
Gen commençant par n’importe quel sommet et en enregistrant les sommets visités pendant l’exécution dans une
liste. Si la liste contient tous les sommets de G, alors Gest connexe. Une petite modification permet de donner les
composantes connexes de G. L ’algorithme DFS_Component suivant donne les composantes connexes de G. Il est
donné sous forme d’implémentation récursive.
Algorithme 5 : DFS_Component
Entrées : Un graphe G=(V,E)
Output : Les composantes connexes C=(C1,C2,..., Ck) de G.
1VisitedNodes ← ; ;
2k←0 ; // k est le nombre des composantes connexes
3pour chaque u∈Vfaire
4 siu∉VisitedNodes alors
5 k←k+1;
6 DFS( u);
7 fin
8fin
9retourner (C1,C2,..., Ck);
1Procedure DFS( u )
2 VisitedNodes ←VisitedNodes ∪{u};
3 Ck←Ck∪{u};
4 pour chaque x∈Γ(u)faire
5 six∉VisitedNodes alors
6 DFS( x);
7 fin
8 fin
Note : -
Il est possible de d’implémenter la procédure DFS itérativement à l’aide d’une pile LIFO (stack) contenant les
sommets à explorer : on désempile un sommet et on empile ses voisins non encore explorés.
20H. SABRI 21
Pseudocode :
stack . push ( root )
while stack . isEmpty ( ) = f a l s e do
node = stack . pop ( ) // so mark i t as v i s i t e d
for each x in node . childNodes do
i f x i s not v i s i t e d then
stack . push ( x )
. . .
endfor
endwhile
Example 3.1 (DFS )
Ici on empile (gris) les sommets les plus à droite, alors l’ordre des sommets visité (noir) est ( a,b,d,e,g,c,f).
Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b
 c
d
 e
f
g
a
b
 c
d e
f
ga
b
 c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g
L ’utilisation d’une file (FIFO) au lieu d’une pile transforme l’algorithme du parcours en profondeur en algo-
rithme de parcours en largeur ( BFS ). Avec BFS l’exemple précédent devient (en enfile le plus à gauche) :
Example 3.2 (BFS )
Ici, avec BFS, on enfile (gris) les sommets les plus à gauche d’abord, alors l’ordre des sommets visité (noir)
est ( a,b,d,e,g,c,f). Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b c
d
 e
f
g
a
b c
d
 e
f
ga
b c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g22 Chapitre 3. Les algorithmes de base
Exercice 3.1
1. Écrire la procédure BFS .
2. Utiliser DFS (ou BFS) pour la construction d’un arbre couvrant d’un graphe connexe. L ’appliquer
pour le graphe triangle.
3. Utiliser DFS pour écrire une procédure DFS_Cycle pour détecter un cycle dans un graphe.
On sait qu’un graphe orienté G=(V,E) est fortement connexe si pour chaque paire de sommets u,v∈V, il
existe un chemin de uàvet il existe un chemin de vàu. En d’autres termes, nous avons besoin d’une connectivité
dans les deux directions .
Une procédure pour tester si un graphe orienté est fortement connexe ou non peut être conçue avec l’idée
suivante. En partant d’un sommet arbitraire vdu graphe G, on exécute l’algorithme BFS ouDFS et l’on note les
sommets visités. Ensuite, on obtient la transposée de G,GT, en inversant la direction des arêtes de G, et l’on
exécute à nouveau l’algorithme BFS ou DFS à partir du sommet v. Si les sommets visités dans les deux cas sont
égaux à V, alors le graphe orienté est fortement connexe. Cette méthode est illustrée dans l’algorithme 6.
Algorithme 6 : Fortement_connexe
Entrées : Un graphe orienté G=(V,E)
Output : true siGest fortement connexe et false sinon
1X← ; ;
2Y← ; ;
3v←un sommet quelconque de V;
4X←DFS( G,v) ; // Enregistrez les sommets visités dans X
5GT←Gavec flèches inversées;
6Y←DFS( GT,v);
7siX=Y=Valors
8 retourner TRUE.
9sinon
10 retourner FALSE.
11fin
3.2 Recherche des chemins
3.2.1 Matrice d’adjacence et nombre de chemins
La puissance de la matrice d’adjacence Amontre qu’il y a des chemins (ou chaînes) de longueur kallant de xà
ycomme le montre le théorème suivant.
Théorème 3.1
Soit G=(V,E) un (di)graphe. On note V={1,2,..., n} et Asa matrice d’adjacence et Akla puissance k-ème
deA. Alors le terme d’indices i,jdeAkest le nombre de chemins (chaînes) de longueur kallant de iàj.
Preuve. Par récurrence sur k. Pour k=1 c’est clair. On suppose le résultat est vrai à l’ordre ket montrons qu’elle
est vrai pour k+1. Soit S=(si,j)=Ak. Si on a un chemin de iàjde longueur k+1, alors on va d’abord de ià un
sommet ravec kpas et puis de ràj. Or d’après l’hypothèse de récurrence on a si,rchemins possibles pour aller de
iàret finalement ar,jpas (1 ou 0) pour aller de ràj. Ainsi, le nombre totale possibles (i.e. tous les sommets r) est :
nX
r=1si,rar,j=³
Ak×A´
i,jH. SABRI 23
ce qui est bien le terme ( i,j) de la matrice Ak+1.
3.2.2 Plus court chemin et l’algorithme de Dijkstra
Dans cette partie on suppose que le (di)graphe G=(V,E,w) est valué positivement (i.e.∀e∈E,w(e)>0). Notre
objectif est de chercher un plus court chemin (i.e., un chemin de poids minimal ) d’un sommet ufixé à un sommet
quelconque de G.
Il est clair que l’on peut restreindre ce problème au cas d’un (di)graphe simple1. On suppose aussi que Gest
connexe (sinon, certains trajets sont impossibles). Il est aussi claire (d’après théorème 2.1), qu’un plus court chemin
est nécessairement un chemin élémentaire (path).
L ’algorithme de Dijkstra (1959) permet de calculer le plus court chemin entre un sommet particulier u(racine )
et tous les autres sommets. L ’algorithme fonctionne de la manière suivante :
Pour tout sommet vdeG, on associe une valeur T(v), initialisée à w(u,v) et une liste de sommets C(v) qui
correspond à un chemin de uàv. À la fin de l’algorithme, T(v) contient le poids minimal des chemins joignant uà
v(ou T(v)= ∞ siu↛v) et la liste C(v) réalise un tel chemin. Voici donc l’algorithme de Dijkstra :
Algorithme 7 : Algorithme de Dijkstra
Entrées : Un (di)graphe valué G=(V,E,w) et un sommet racine u
Output : Le coût minimum d’un chemin de uàv(∀v∈V) et un trajet pour chaque coût minimal obtenu
1∀v∈V,T(v)←w(u,v) etC(v)←(u,v); // Initialisation de T(v) et la liste C(v)
2X←{u};
3tant que X̸=Vfaire
4 Choisir v∈V−Xtel que ∀y∈V−X,T(v)≤T(y);
5 X←X∪{v};
6 pour chaque y∈V−Xfaire // Faire les mises à jours pour les autres sommets
7 siT(y)>T(v)+w(v,y)alors
8 T(y)←T(v)+w(v,y);
9 C(y)←[C(v),y]; // On ajoute à la liste C(v) l'élément y
10
11 fin
12 fin
13fin
Example 3.3
Voici une application de l’algorithme de Dijkstra au digraphe suivant. On prend Ecomme sommet racine.
EA
B
CD
FG
S5
4
21
12
2
34
4
215
7
1. En effet, passer par une boucle ne ferait qu’augmenter inutilement le poids de ce chemin. De même, si plusieurs arcs joignent deux
sommets, il suffit de conserver l’arc de poids minimal.24 Chapitre 3. Les algorithmes de base
Ainsi, pour l’initialisation, on a : X={E} et on a les valeurs :
v  E A B C D F G S
T(v) 0 5 4 2 ∞ ∞ ∞ ∞
C(v)(E,E) ( E,A) ( E,B) ( E,C) ( E,D) ( E,F) ( E,G) ( E,S)
Maintenant, on choisit (un seul choix) le sommet C, donc X={E,C}. Le tableau est mis à jour :
v  E A B  C D F G S
T(v) 0 5 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À l’étape suivante, on est forcé de choisir B. Ainsi, X={E,C,B} et la mise à jour est :
v  E A  B  C D F G S
T(v) 0 4 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À présent, on a le choix entre AetF. On choisit A. Donc X={E,C,B,A} et on a :
v  E  A  B  C D F G S
T(v) 0 4 3 2 6 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,B,A,D) ( E,C,F) ( E,C,G) ( E,S)
Puis, on prend le sommet F. D’où X={E,C,B,A,F} et :
v  E  A  B  C D  F G S
T(v) 0 4 3 2 5 4 5 11
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,S)
On prend Det on obtient X={E,C,B,A,F,D} et :
v  E  A  B  C  D  F G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Finalement, on prend Gpuis Set on voit que ceci ne change rien. D’où le tableau finale :
v  E  A  B  C  D  F  G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Ainsi le chemin minimum pour aller de EàSest de coût 10 et un trajet de coût minimal de EàSest : EC F DS .H. SABRI 25
3.3 Problèmes d’ordonnancement et chemin critique
Un problème d’ordonnancement peut-être représenté sous la forme d’un digraphe. Les sommets sont des évé-
nements (début et fin de la tâche) et les arcs des tâches, La longueur (ou poids) de chaque arc représente la durée
d’exécution de la tâche. Ainsi, la tâche correspondant à l’arc ( i,j) ne peut commencer que si toutes les tâches cor-
respondant à des arcs ( k,i) ont été complétées. On ajoute deux sommets pour le début (s) et de fin(t) du projet .
Le digraphe peut contenir des tâches fictives dedurée nulle afin de forcer certaines précédences (postériorité).
Ainsi, un réseau PERT est un digraphe valué G=(V,E,w,s,t) où la fonction poids (ou longueur) w:E→R+
etsle sommet source (début) et tle sommet puits (fin). Un chemin critique est un chemin de sàtdelongueur
maximale . S’il n’existe pas de chemin critique, le projet n’est pas réalisable (e.g. un circuit). Le temps minimal
requis pour l’exécution d’un projet réalisable est égal à la longueur d’un chemin critique. Les tâches figurant sur un
chemin critique sont aussi appelées critiques, ce qui s’explique par le fait que tout retard d’exécution d’une tâche
critique retarde d’autant l’exécution du projet.
3.3.1 Algorithmes de tri topologique et de chemin critique
Il faut d’abord numérotés les sommets de 1 à nde manière compatible au pré-ordre (rang) avec l’algorithme du
rang suivant (tri topologique) :
Algorithme 8 : Algorithme du rang
Entrées : Un digraphe G=(V,E) sans circuit
Output : Le rang r(v) de chaque sommet v∈Vde G
1r←0;X←V;
2R←{v∈X:Γ−
X(v)= ;} ; // l'ensemble des sommets de X sans prédécesseur dans X
3tant que X̸= ; faire
4 r(v)←rpour chaque sommet v∈R;
5 X←X−R;
6 R←l’ensemble des sommets de Xsans prédécesseur dans X;
7 r←r+1;
8fin
On supposera dorénavant que les sommets ont déjà été numérotés de 1 à nde manière compatible avec leurs
rangs, c’est-à-dire que r(j)>r(i) implique j>i(donc 1 =setn=t). Enfin, on supposera éliminés les arcs paral-
lèles par l’introduction de tâches fictives de durée nulle .
Pour un sommet i, on note tiledébut au plus tôt des tâches correspondant aux arcs i→jet par Tilafin au
plus tard des tâches correspondant aux arcs j→i.
Algorithme 9 : Algorithme du chemin critique
Entrées : Un digraphe G=(V,E) sans circuit trié topologiquement
Output : La durée du chemin critique et les dates ti,Ti
1t1←0;
2pour j=2···nfaire // Calcul des dates de début au plus tôt  récurrence en avançant
3 tj←max i∈Γ−(j){ti+w(i,j)}
4fin
5Tn←tn;
6pour j=n−1···1faire // Calcul des dates de fin au plus tard  récurrence en reculant
7 Tj←min i∈Γ+(j){Ti−w(j,i)}
8fin26 Chapitre 3. Les algorithmes de base
Définition 3.1
— Un sommet iest critique si ti=Ti.
— Un arc ( i,j) est critique les sommets ietjsont critiques ettj−ti=w(i,j).
— Un chemin critique est un chemin de 1 à nn’utilisant que des arcs critiques.
— La durée du chemin critique est donnée par Tn(ou par tn). Elle correspond à la durée minimale du
projet .
Example 3.4
L ’application de l’algorithme du chemin critique au digraphe suivant (trié topologiquement) est :
1 23
45
6B
9A
3
C
5D
8
E
4
F7G
20
H6I5
=⇒
 1
0,02
9,933,16
4
16,23513,24
6
29,29B
9A
3
C
5D
8
E
4
F7G
20
H6I5
Les tâches critiques sont BetG. La durée totale minimale du projet est donc 29.
Exercice 3.2
Les tâches ( durée et précédences ) pour la construction d’un entrepôt sont données dans le tableau suivant :
Tâches Nature Précédences Durée (jours)
A Acceptation des plans par le propriétaire – 4
B Préparation du terrain – 2
C Commande des matériaux A 1
D Creusage des fondations A, B 1
E Commande des portes et fenêtres A 2
F Livraison des matériaux C 2
G Coulage des fondations D, F 2
H Livraison des portes et fenêtres E 10
I Pose des murs, de la charpente et du toit G 4
J Mise en place des portes et fenêtres H, I 1
1. Représentez le graphe des précédences de ce projet (trié topologiquement).
2. Déterminez une durée totale minimale en exhibant un chemin critique dans ce graphe.CHAPITRE 4
Programmation linéaire
La programmation linéaire est le processus de minimiser ou maximiser une fonction objective linéaire sou-
mise à un nombre fini de contraintes d’égalités et d’inégalités linéaires.
La programmation linéaire a de nombreuses applications dans le domaine de l’informatique théorique. Elle
peut être utilisée pour résoudre de nombreux problèmes combinatoires variés, tels que la recherche de flot maxi-
mum dans un réseau, la recherche d’un couplage maximal dans un graphe et la coloration d’un graphe parfait.
Example 4.1 (Problème de régime)
On suppose qu’on a quatre plats : de la truite ( XT), un sandwich au corned-beef ( XC B), un burrito ( XBU R )
et un hamburger ( XHB). Le tableau suivant répertorie la valeur nutritionnelle de chaque plat (vitamines et
calories) et notre besoin journalier des vitamines.
Vit. A Vit. C Vit. D Calories
Truite 203 92 100 600
Corned-beef 90 84 230 350
Burrito 270 80 512 250
Humburger 500 90 210 500
Besoins 2000 300 430
Notre objectif est de minimiser le nombre total de calories consommées : 600 XT+350XC B+250XBU R+
500XHBtout en satisfaisant les trois besoins nutritionnels en vitamines. Le programme linéaire résultant
s’écrit :
min 600 XT+350XC B+250XBU R+500XHB
s.t. 203 XT+90XC B+270XBU R+500XHB≥2000, (Besoins de Vit. A),
92XT+84XC B+80XBU R+90XHB≥300, (Besoins de Vit. C),
100XT+230XC B+512XBU R+210XHB≥430, (Besoins de Vit. D),
XT,XC B,XBU R ,XHB≥0
Définition 4.1: Forme canonique – Forme standard
On peut écrire un P .L. sous deux formes spéciales :
•Canonique
max
mincTX+c0
s.t. AX≤b(≥bsi min),
X≥0•Standard
max cTX+c0
s.t. AX=b,
X≥0Avec :
cTX=¡
c1··· cn¢
x1
...
xn

cTX+c0=c1x1+c2x2+···+ cnxn+c0
2728 Chapitre 4. Programmation linéaire
Remarque 9. Un P .L. général peut être formulé selon une forme standard ou canonique par la méthode suivante :
générale =⇒ standard il faut éliminer les contraintes d’inégalité et les variables sans contrainte de positivité.
— Si dT
iX≤biest une contrainte d’inégalité, alors créer une nouvelle variable ( d’écart ) siet remplacer l’in-
égalité dT
iX≤bipar dT
iX+si=biet s i≥0.
Si dT
iX≥bi, alors on peut écrire dT
iX−si=biet s i≥0.
— Si une variable x i≶0est de signe quelconque, alors créez deux nouvelles variables x+
iet x−
iet remplacez
xipartout par x+
i−x−
i, et ajoutez les contraintes de signe : x+
i≥0,x−
i≥0.
générale =⇒ canonique
— Si dT
iX=biest une contrainte d’égalité, alors remplacer cette égalité par une paire d’inégalités :
dT
iX≥biet−dT
iX≥ −bi
— Même chose que précédemment si la variable x i≶0.
Il est facile de voir que les problèmes qui en résultent sont équivalents aux problème d’origine. Pour l’algorithme
simplexe , nous utiliserons la forme standard .
On remarque aussi qu’en utilisant la relation min f(x)= − max¡
−f(x)¢
dans laquelle f (x)représente la fonction-
nelle linéaire à optimiser, on peut toujours se ramener à un problème de minimisation (ou de maximisation).
Example 4.2
Le P .L :max 5 x+4y
s.t. x≤6
1
4x+y≤6
3x+2y≤22
x,y≥0s’écrit sous forme standard :max 5 x1+4x2
s.t. x1+e1=6
1
4x1+x2+e2=6
3x1+2x2+e3=22
x1,x2,e1,e2,e3≥0
Donc (sous la forme matricielle) on a :
cT=¡
5 4 0 0 0¢
;A=
1 0 1 0 0
1
41 0 1 0
3 2 0 0 1
;X=
x1
x2
e1
e2
e3
et b=
6
6
22

4.1 La méthode simplexe
4.1.1 Solution de base admissible
On suppose que la matrice Adu programme linéaire est de type m×netde rang m(pourquoi !). Soit Bla
matrice carrée extraite de Aformée par les mcolonnes j1,j2,..., jmlinéairement indépendants de A(les vecteurs
de base). Alors, Best une matrice inversible. Ainsi si on pose xl=0 sil∉{j1,..., jm} etxjklak-ième composante de
B−1b. Alors, on a AX B=b. Si de plus XB≥0(i.e. chaque xi≥0), alors :
Xest une solution de base admissible (ou réalisable)
Dans l’exemple 4.2, la matrice extraite B=
1 0 0
0 1 0
0 0 1
est inversible et B−1b=
6
6
22
. Donc XB=
0
0
6
6
22
≥0, par suite
XBest une solution de base admissible. On appelle les variables xjklesvariables de base . Les autres variables xl
sont les variables hors-base .
Parfois, il n’est pas évident de trouver une solution de base admissible, comme le montre l’exercice suivant :H. SABRI 29
Exercice 4.1
Écrire le programme linéaire suivant sous forme standard et montrer qu’on n’a pas une solution de base
admissible. Résoudre le programme linéaire.
max −x+y
s.t. x+y≥1,
3x+2y=6,
x,y≥0
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux
Dans cette section, on suppose qu’on a déjà trouvé une solution de base admissible X(produite avec B=Im)
du programme linéaire ( P: max z=cTX+c0etb≥0pour garantir que 0est une solution de AX≤b).
La méthode du simplexe est une méthode itérative qui génère une séquence de solutions de base réalisable
(correspondant à différentes bases) et s’arrête finalement lorsqu’elle a trouvé une solution de base réalisable opti-
male. Remarquer qu’on peut toujours prendre c0=0.
Algorithme 10 : Algorithme du simplexe
Entrées : Un P .L. standard P(max) avec une solution de base réalisable
Output : La solution optimale (ou non)
1On commence à écrire le tableau initiale (avec les variables de base xj1,..., xjm)
VB x1 ... xn b
xj1 b1
... A...
xjm bm
c1 ... cn−c0
2Sicj≤0 (∀j:xjest hors base), alors solution optimale (STOP) // min ⇝cj≥0
3Trouver la colonne s(hors base) tel que cs=max©
cj:cj>0ª// min ⇝cs=min©
cj:cj<0ª
4Siai,s≤0∀i=1... m, alors pas de solution optimale (STOP)
5Min Ratio Test : trouver la ligne rtel que
br
ar,s=min
i=1...m½bi
ai,s:ai,s>0¾
6Appliquer la procédure de Gauss autour de pivot ar,s(ar,s⇝1 et on annule les coefficients situés sous et
sur le pivot dans la colonne s, par combinaisons de lignes) // Ne pas oublier la dernière ligne
7Remplacer (dans VB) la variable de base ( sortante ) située à la ligne rpar la variable ( entrante )xs
8Retourner à l’étape 2 // l'algorithme termine si le programme linéaire est non dégénéré
Remarque 10.
— La dernière ligne représente l’équation linéaire −z+c1x1+···+ cnxn= −c0.
— La valeur de la variable de base de V Bde la ligne k est égale à la valeur b k(de la ligne k).
— La solution optimale du problème est la valeur finale (dernière cellule) (×− 1).
— Si on n’a pas au départ B =Im(à l’aide des variables d’écart) alors, on ajoute les variables artificielles (et on
applique d’abord la phase I - voir section suivante).30 Chapitre 4. Programmation linéaire
Exercice 4.2
Soit le programme linéaire :
max 2 x1+x2
s.t. x1−x2≤3,
x1+2x2≤6,
−x1+2x2≤2,
x1,x2≥0
Rajouter les variables d’écart. Puis résoudre le problème par l’algorithme du simplexe.
Remarque 11. Vérifier le résultat de l’exercice précédent, par la méthode graphique.
4.1.3 Initialisation - Phase I du simplexe
Un programme linéaire est dit sous forme simpliciale si la matrice Acontient la matrice identité Imcomme
sous matrice. On suppose que le programme linéaire P, après la mise en forme AX=b, n’est pas simpliciale
(possible dans le cas de contraintes du type ≥ou du type =). Soit Bune matrice d’ordre mextraite de Ainversible
tel que B−1b≥0et soit XBla solution de base réalisable ( XB≥0etAX B=b), alors on peut changer l’équation
matricielle :
AX B=b
⇐⇒ (B−1A)XB=B−1b
⇐⇒ A∗XB=b∗
et la matrice A∗contient la matrice identité Imcomme matrice extraite ( B−1A=B−1(H|B)=¡
B−1H|Im¢
). Ainsi, on
peut appliquer directement l’algorithme 10 en remplaçant Apar A∗etbpar b∗. Cependant, cette méthode n’est
pas efficace, car il faut trouver une matrice extraite Bréalisable correspondante. Pour une matrice Ade type m×n,
il existe¡m
n¢
matrices extraites à tester !
L ’idée est d’ajouter des variables, dites artificielles w1,w2,..., wm, pour faire apparaître une forme simpliciale
du programme linéaire P: (AX=b). Mais, il faut que w1= ··· = wm=0. Donc, il faut minimiser d’abord le pro-
gramme linéaire P0suivant :
P0=min W=w1+···+ wm
s.t. (A|Im)×(x1...xnw1...wm)T=b
x1,..., xn,w1,..., wm ≥0
On exprime Wà l’aide des autres variables (hors base) et puis on applique l’algorithme du simplexe 10 pour P0
(phase I). À la fin, si on trouve que les wi=0, alors les variables de bases xj1,..., xjmforment une première base
admissible pour démarrer le simplexe pour le programme d’origine P.H. SABRI 31
Remarque 12. On ajoute la ligne de Z :c1 ... cn−c0dans le tableau du simplexe de P0(phase I) et on lui
applique les opérations élémentaire comme avec les autres lignes. À la fin de la phase I, on supprime les colonnes des
wiet la ligne de la fonction W . Finalement, on utilise ce tableau pour résoudre le problème initiale P.
Example 4.3
Soit le programme linéaire P:
min 6 x1+3x2
s.t. x1+x2≥1,
2x1−x2≥1,
3x2≤2,
x1,x2≥0sous forme standard (max)= = = = = = = = = = = = = = = = = = ⇒max Z= −6x1−3x2
s.t. x1+x2−e1=1,
2x1−x2−e2=1,
3x2+e3=2,
x1,x2,e1,e2,e3≥0
La matrice Aest :
A=x1 x2 e1 e2 e3

1 1 −1 0 0
2−1 0 −1 0
0 3 0 0 1
est par suite Pn’est pas sous forme simpliciale (il n’ ya pas de sous matrice I3). Donc on peut ajouter 2
variables artificielles pour construire le problème initiale P0:
max −w1−w2=3x1−e1−e2−2
s.t. x1+x2−e1+w1=1,
2x1−x2−e2+w2=1,
3x2+e3=2,
x1,x2,e1,e2,e3,w1,w2≥0dont le vecteur X=

0 x1
0 x2
0 e1
0 e2
2 e3
1 w1
1 w2est une solution de base réalisable.
Ainsi, on commence notre algorithme 10 pour le programme P0. Le tableau initial est :
x1 x2 e1 e2 e3 w1 w2 b

w1 1 1 −1 0 0 1 0 1
w2 2−1 0 −1 0 0 1 1
e3 0 3 0 0 1 0 0 2
W: 3 0 −1−1 0 0 0 2
Z:−6−3 0 0 0 0 0 0
Le pivot c’est a2,1donc x1est la variable entrante et w2est sortante. On obtient après pivotement le tableau :
L2←1
2L2− − − − − − − − →
L1←L1−L2
L4←L4−3L2
L5←L5+6L2x1 x2 e1 e2 e3 w1 w2 b

w1 03
2−11
20 1−1
21
2
x1 1−1
20−1
20 01
21
2
e3 0 3 0 0 1 0 0 2
W: 03
2−11
20 0−3
21
2
Z: 0 −6 0 −3 0 0 3 3
Le pivot est a1,2(Min ratio test =1
3). On obtient alors :32 Chapitre 4. Programmation linéaire
L1←2
3L1− − − − − − − − →
L2←L2+1
2L1
L3←L3−3L1
L4←L4−3
2L1
L5←L5+6L1x1 x2 e1 e2 e3 w1 w2 b


x2 0 1−2
31
302
3−1
31
3
x1 1 0−1
3−1
301
31
32
3
e3 0 0 2 −1 1 −2 1 1
W: 0 0 0 0 0 −1−1 0
Z: 0 0 −4−1 0 4 1 5
Ainsi, la phase I se termine avec W=0 et x1=2
3,x2=1
3,e3=1 et e1=e2=w1=w2=0. Le tableau pour la
phase II est donc :
x1 x2 e1 e2 e3 b


x2 0 1−2
31
301
3
x1 1 0−1
3−1
302
3
e3 0 0 2 −1 1 1
Z: 0 0 −4−1 0 5
On remarque donc que les cj≤0, donc (STOP) la solution est optimale et le max est −5. Ainsi la solution
optimale pour le programme P=min6 x1+3x2est−(−5)=5=6×2
3+3×1
3.
4.2 Dualité
SoitPun P .L. sous forme canonique. Le programme dualDdePest définit par :
P=max z=cTX
s.t. AX ≤ b
X≥ 0le dual est= = = = = = = ⇒D=min w=bTY
s.t. ATY≥ c
Y≥ 0
Le programme Pest dit primal . On remarque que si Ade type m×n, alors X∈RnetY∈Rmpour le dual.
Théorème 4.1 Théorème de dualité
Si un problème primal ou dual admet une solution, alors l’autre problème admet aussi une solution et on a :
max z=cTX =
s.t. AX ≤ b
X≥ 0min w=bTY
s.t. ATY≥ c
Y≥ 0
Exercice 4.3
Soit le problème suivant de type régime :
D=min w=340x1+2400 x2+560x3
s.t. x1+2x2+x3≥ 1200
x1+3x2+2x3≥ 1400
x1+x2+3x3≥ 1500
x1,x2,x3≥ 0
Écrire le programme primal PdeD. Résoudre le programme Pet déduire la valeur minimale de w, a-t-on
besoin de faire les deux phases du simplexe ?
7} A B oS



HOUSSEM SABRI
Graphes et Optimisation
2`emeannée
LISI  LSI
Institut Supérieur des Sciences Appliquées et de Technologie de Sousse
A.U. 2023-2024
28 novembre 2023Table des matières
1 Les graphes 3
1.1 Définitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.1 Graphes non orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.2 Graphes orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.2 Opérations et quelques types de graphes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.3 Représentation d’un graphe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.1 Listes d’adjacences (ou de succession) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.2 Matrices d’adjacence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.3.3 Matrice d’incidence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2 La connexité 11
2.1 Les chaînes et les cycles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.2 Graphe connexe, eulérien, hamiltonien . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.3 Arbres . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.3.1 Codage et décodage d’un arbre – Prüfer code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.3.2 Arbre couvrant de poids minimum – ACM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3 Les algorithmes de base 20
3.1 Parcours en profondeur (DFS) / largeur (BFS) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
3.2 Recherche des chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.1 Matrice d’adjacence et nombre de chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.2 Plus court chemin et l’algorithme de Dijkstra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
3.3 Problèmes d’ordonnancement et chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
3.3.1 Algorithmes de tri topologique et de chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . 25
4 Programmation linéaire 27
4.1 La méthode simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.1 Solution de base admissible . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux . . . . . . . . . . . . . . . . . . . . . . . . 29
4.1.3 Initialisation - Phase I du simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
4.2 Dualité . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
2CHAPITRE 1
Les graphes
L ’exemple classique pour introduire la théorie des graphes est le problème des ponts de Königsberg, étudié par
Euler en 1736. Quel itinéraire doit-on suivre pour traverser chaque pont exactement une fois? Une telle prome-
nade n’existe pas, et c’est Euler qui donna la solution de ce problème en caractérisant les graphes que l’on appelle
aujourd’hui eulériens .
A
B
Ce1 e2
e3 e4
De5
e6e7
FIGURE 1.1 – Les ponts de Königsberg
Les graphes introduisent une simplification : les régions se transforment en des "points" (aussi appelés noeuds
ousommet ), les ponts se transforment en des lignes (aussi appelées arêtes ouarcs ), et ce principe s’applique dès
lors qu’une relation existe entre des objets. Les graphes relèvent de la combinatoire plutôt que de la géométrie (les
intersections, les longueurs, et la forme des arêtes n’ont aucune importance, sauf en ce qui concerne la lisibilité de
la représentation).
1.1 Définitions
Dans la suite, il est toujours supposé que les graphes sont finis, sauf indication contraire.
1.1.1 Graphes non orientés
Définition 1.1: Graphe
Un graphe Gest un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V{2}des pairs non ordon-
nées de V.Vest l’ensemble des noeuds (Vertices en anglais) et Ec’est l’ensemble des arêtes de G(Edges en
anglais). Lorsque e={x,y} est une arête, on dit que x, y sont les extrémités de cette arête, que eest incidente
enxet en y. On joint x et y par un trait et on dit que x, y sont adjacents (ou voisins). On note aussi e=x you
encore e=(x,y) (attention , dans ce cas : ( x,y)=(y,x)).
SiGest un graphe alors, on note par V(G) l’ensemble de noeuds et par E(G) l’ensemble des arcs.
Remarque 1.
— Une arête e ={x,x}s’appelle boucle .
— Dans un graphe, il peut exister des arêtes parallèles (on parle donc de multigraphe ).
Dans l’exemple des ponts on a : e 1=e2=(A,B).
34 Chapitre 1. Les graphes
— Un graphe est dit simple s’il ne comporte ni arêtes multiples ni de boucles, c’est-à-dire chaque paire de nœuds
distincts est reliée par au plus une arête, ou encore E (G)⊆P2(G).
Dans la plupart des cas, les graphes sont considérés comme simples par défaut.
Définition 1.2: ordre – taille – degré
Soit G=(V,E) un graphe.
1. On appelle ordre d’un graphe noté v(G) le nombre de ses sommets :
v(G)= |V|
2. On appelle taille d’un graphe noté e(G) le nombre de ses arêtes :
e(G)= |E|
3. Le degré (ou valence) d’un sommet xnoté d(x) est le nombre d’arêtes contenant x. (Attention! Une
boucle sur un sommet compte double).
Si on note par Γ(x) l’ensemble des voisins de x, i.e.
Γ(x)={y∈V:x y∈E}
alors, siGest simple , on a :
d(x)= |Γ(x)|
Example 1.1 (Graphe complet)
Un graphe d’ordre nest dit complet noté Knsi chaque sommet du graphe est relié directement à tous les
autres sommets, i.e. E(Kn)=P2(V(Kn)).
Représenter graphiquement K3,K4,k5. Calculer la taille de K3,k4,...Kn.
Example 1.2 (Graphe biparti)
Un graphe G=(V,E) est dit biparti si son ensemble de sommets V=V1˙∪V2, i.e. peut être divisé en deux
sous-ensembles disjoints V1etV2tels que chaque arête ait une extrémité dans V1et l’autre dans V2.
Si∀x∈V1,∀y∈V2;x y∈E, alors Gest dit biparti complet noté Kn,moùn= |V1|etm= |V2|.
a1
 a2
 a3
 a4
b1
 b2
 b3
FIGURE 1.2 – Un graphe biparti
Théorème 1.1 Lemme des poignées de main – Handshaking lemma
Soit Gun graphe alors, on a :X
x∈V(G)d(x)=2e(G)
Dans ce théorème d(x) est le nombre de personnes à qui xserre la main et e(G) le nombre total de poignées
de mains.H. SABRI 5
Preuve.
•Méthode simple Il y en a d(x) arêtes en un sommet xfixé. Pour tout les sommets cela fait doncP
x∈V(G)d(x).
Mais avec cette manière chaque arête est comptée deux fois, une fois à chacune de ses extrémités, d’où le
résultat en divisant par 2.
•Preuve par double dénombrement On pose
Z={(x,e)∈V×E:x∈e}⊆V×E
et les deux projections :
p:Z→V
(x,e)7→xet q:Z→E
(x,e)7→e
L ’idée est de calculer |Z|de deux manières différentes. D’abord, on rappelle que si f:A→Best une fonction
quelconque, alors :X
b∈B|f−1[b]| = | A|
oùf−1[b] désigne l’image réciproque de { b} par f(pourquoi ˙S
b∈Bf−1[b] est une union disjointe ?).
Ainsi on obtient :
|Z| =X
x∈V|p−1[x]| =X
e∈E|q−1[e]|
Or,|p−1[x]| =d(x) et|q−1[e]| = |{x∈V:x∈e}| =2. Donc :
X
x∈Vd(x)=X
e∈E2=2|E|
Remarque 2.
— Un sommet de degré 0est appelé sommet isolé .
— Un graphe tel que : ∀x∈V,d(x)=kest dit graphe k-régulier .
— Le graphe complet K nest un graphe (n−1)-régulier .
Exercice 1.1
Montrer que dans un graphe le nombre de sommets d’ordre impairs est toujours pair. En particulier un
graphe k-régulier avec kimpaire est un graphe d’ordre pair.
Voici quelques exemples comme application :
1. Est-il possible de relier 15 ordinateurs en réseau de sorte que chacun soit relié à exactement 3 autres ?
2. Une ligue de football comprenant 11 clubs organise un tournoi. Pour gagner du temps on décide que chaque
équipe ne jouera que la moitié des matches possibles. Comment organiser le tournoi ?
Proposition 1.1
Soit G=(V,E) un graphe (simple) d’ordre n≥2. Alors :
∃u,v∈V,u̸=v:d(u)=d(v)
Preuve. Supposons le contraire, c’est-à-dire ∀u,v∈V;d(u)̸=d(v). Or dans un graphe (simple) on a toujours d(x)∈
{0,1,..., n−1}. Dans ce cas, puisque tous les nsommets ont des degrés distincts, alors il existe une bijection
{d(x):x∈V}←→ {0,1,..., n−1}
Donc, il existe un sommet uavec un degré 0, et un sommet vavec degré n−1, donc vest connecté à tous les autres
sommets du graphe, ce qui signifie que une peut pas être un sommet isolé, d’où une contradiction.6 Chapitre 1. Les graphes
1.1.2 Graphes orientés
Les arêtes d’un graphe peuvent être orientées, auquel cas une flèche indique la direction. De tels graphes sont
appelés des graphes orientés ou des digraphes , et une arête ( a,b) dans un tel graphe indique que cette arête est
dirigée de sommet avers b, i.e. ( a,b)=− →ab̸=(b,a)=− →ba. D’où la définition :
Définition 1.3: Graphe orienté - digraphe
Un graphe orienté G(ou− →G) est un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V2des pairs
ordonnées de V.Eest l’ensemble des arêtes (ou flèches, arcs) de G. Lorsque e=(x,y) est une arête, on dit
que xestl’origine (ou sommet initiale) et yl’extrémité (ou sommet terminale) de e, que eest sortant en x
et incident en y, et que yest un successeur de xtandis que xest un prédécesseur de y. On note l’arête e
par :
e=(x,y)=− →x y=x→y
De la même façon, une arête x→xest une boucle. On peut toujours supprimer les boucles pour obtenir des
digraphes simples. Voici l’exemple d’un digraphe G=(V,E) d’une fonction f:E→Eoù ( x,y) est un arc si et seule-
ment si y=f(x). On l’appelle digraphe fonctionnelle.
0
3
1214
11 568
169
4
2 1
713 10
15
FIGURE 1.3 – Le digraphe fonctionnelle Gfdex7→(x2+3) mod 17.
Comme dans les graphes on peut définir les degrés (entrant, sortant) d’un sommet dans un digraphe.
Définition 1.4: indegree - outdegree
Soit G=(V,E) un digraphe. Pour v∈V, on note par :
d+(v) le degré extérieur (sortant - outdegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité initiale.
d+(v)= |{v→ •}|
d−(v) le degré intérieur (entrant - indegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité finale.
d−(v)= |{• → v}|
On définit le degré : d(v)=d−(v)+d+(v).
Un sommet de degré entrant non nul et de degré sortant nul est appelé puits , tandis qu’un sommet de
degré entrant nul et de degré sortant non nul est appelé source ouracine .
Dans un graphe orienté, les voisins d’un sommet vsont soit des successeurs ou des prédécesseurs. On les notes
par :
Γ+(x)=Succ (x)={y∈V:x→y∈E} et Γ−(x)=Pr ed (x)={y∈V:y→x∈E}H. SABRI 7
Si le digraphe est simple (ni boucle ni arcs parallèles) on a :
d−(v)= |Γ−(v)|et d+(v)= |Γ+(v)|
Proposition 1.2
Soit Gun digraphe, alors :X
v∈Vd−(v)=X
v∈Vd+(v)= |E|
Preuve. On a
E=˙[
v∈V{• → v}=˙[
v∈V{v→ •}
=⇒ | E| =X
v∈V|{• → v}| =X
v∈V|{v→ •}| =⇒ | E| =X
v∈Vd−(v)=X
v∈Vd+(v)
1.2 Opérations et quelques types de graphes
Une opération sur les graphes permet de construire un nouveau graphe comme résultat de l’opération. Les
opérations courantes sur les graphes sont la suppression, la valuation, l’union, l’intersection et le produit cartésien.
Graphe valué
Tout d’abord, on peut vouloir attribuer des valeurs aux arcs ou arêtes pour tenir compte de contraintes : dis-
tance, coût ...
Définition 1.5: (di)graphe valué
Un (di)graphe valué G=(V,E,w) est un (di)graphe muni d’une application w:E→R. L ’application west
appelée application poids ou coût. On indique sur chaque arête son poids (ou son coût). On note w(x,y)
au lieu de w((x,y)). On convient (même que ceci n’a pas de sens!) que w(x,y)= +∞ si (x,y)∉E.
ab
c
d
ef53
43
3
335
81
FIGURE 1.4 – Un digraphe valué
/pythonPython code : -
Implémenter le digraphe valué précédent avec python. Indice – use chatGPT : how to build a weighted digraph with
python8 Chapitre 1. Les graphes
Sous graphes
Soit G=(V,E) un graphe (orienté ou non). Un sous graphe de Gest un graphe de la forme G′=(V′,E′) où
V′⊆V,E′⊆Etels que toute arête de E′a ses extrémités dans V′(ou encore G′est aussi un graphe). On a :
•Sous-graphe induit Un sous-graphe G′=(V′,E′) de G=(V,E) est appelé un sous-graphe induit deGsi :
∀x,y∈V′; (x,y)∈E′⇐⇒ (x,y)∈E
En d’autres termes, deux sommets de G′qui sont connectés dans G, sont également connectés dans G′.
•Sous-graphe couvrant Un sous-graphe couvrant G′deGcontient tous les sommets de G, i.e. V′=V.
•G−vSupprimer un sommet vd’un graphe Gconsiste à supprimer vet toutes ses arêtes incidentes. Le sous-
graphe obtenu de cette opération est noté G−v, i.e.
V′=V−{v} et E′=E−{(v,y): (v,y)∈E}
De manière similaire, une arête epeut être supprimée (resp. ajoutée) d’un graphe G, et le sous-graphe
résultant est représenté par G−e(resp. G+e). Notez que la suppression d’une arête ne retire pas de sommets
du graphe.
•G−V′=G[V′] On supprimer tous les sommets v∈V′du graphe Gavec les arêtes incidentes. Le sous-graphe
obtenu de cette opération est noté G[V′], i.e.
V(G[V′])=V−V′et E(G[V′])=E−{(v,y)∈E:v∈V′}
•Clique Une clique Cd’un graphe Gest un sous-ensemble des sommets de Gdont le sous-graphe induit G′=
(C,E′) est un graphe complet, en d’autres termes, deux sommets quelconques de la clique Csont toujours
adjacents.
•Stable Un stable – appelé aussi ensemble indépendant (independent set en anglais) est un ensemble de som-
mets deux à deux non adjacents. Donc le sous-graphe induit est sans arcs.
FIGURE 1.5 – L ’ensemble des sommets en bleu dans ce graphe est un stable maximal du graphe.
Note : -
Le problème décisionnel de la clique (c’est à dire existe t-il une clique de taille k) est NP-complet . De même la
recherche d’un stable de taille maximum dans un graphe est un problème NP-complet et difficile à approximer.
Exercice 1.2
Trouver un plus grand stable et une plus grande clique du graphe suivant :
8
4
62 7
3
1 5
Indice : vérifier le résultat avec networkx.find_cliques(G) et.maximum_independent_set(G) de python.H. SABRI 9
Opérations binaires
Union L ’union de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∪H=(VF,EF) dans lequel
VF=VG∪VH et EF=EG∪EH
Intersection L ’intersection de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∩H=(VF,EF)
dans lequel
VF=VG∩VH et EF=EG∩EH
1.3 Représentation d’un graphe
Il est important de savoir comment représenter les graphes au sein d’un ordinateur. Il ya plusieurs méthodes
selon la nature des traitements que l’on souhaite appliquer au graphe considéré.
1.3.1 Listes d’adjacences (ou de succession)
Soit Gun (di)graphe. On suppose que les sommets de Gsont numérotés de S1àSn. La représentation par listes
d’adjacence de Gconsiste en un tableau (ou des listes chainées) tel que la ligne i=1... ncorrespond au sommet Si
et comporte la liste des voisins/successeurs (ou des prédécesseurs) de ce sommet notée T[Si]. Les sommets dans
chaque liste d’adjacence sont généralement listés selon un ordre arbitraire.
1
2
345
FIGURE 1.6 – Un digraphe
La liste d’adjacence de digraphe 1.6 est donc :
1 2 3 4 5
2 3
3 4
4−
5 1 410 Chapitre 1. Les graphes
1.3.2 Matrices d’adjacence
Définition 1.6: Mat. Adjacence
Soit G=(V,E) un graphe (orienté) d’ordre n. On peut numéroter V={1,2,..., n}.La matrice d’adjacence
deGest la matrice carrée A=(ai j) d’ordre n, définie par :
ai j=(
1 si ( i j)∈E;
0 sinon.
Remarque 3.
1. Si le graphe G est non orienté et simple, alors la matrice A est symétrique avec des 0sur la diagonale. Pour un
digraphe simple, on a toujours des 0sur la diagonale, mais la matrice n’est pas symétrique en général.
2. Pour les multigraphes, il peut y avoir des termes diagonaux (pour les boucles) et s’il y a plusieurs arêtes de i à
j , le coefficient de la matrice a i jest le nombre d’arêtes de i à j .
3. Pour un (di)graphe valué G =(V,E,w), on pose :
ai j=(
w(i,j)si(i j)∈E ;
∞ sinon.
La matrice d’adjacence de la figure 1.4 est :

∞ 5∞ 4 3 ∞
∞ ∞ 3∞ 1∞
∞ ∞ ∞ ∞ ∞ 5
∞ ∞ 3∞ 3 3
∞ ∞ ∞ ∞ ∞ 8
∞ ∞ ∞ ∞ ∞ ∞

1.3.3 Matrice d’incidence
Définition 1.7: Mat. Incidence
Soit G=(V,E) un graphe (simple) d’ordre net de taille m. On pose V={v1,v2,..., vn} etE={e1,e2,..., em}.
La matrice d’incidence deGest la matrice de type n×m B=(bi j), définie par :
•Si G orienté
bi j=

1 si ej=vi→ • (i.e. viest l’extrémité initiale de ej) ;
−1 si ej= • → vi(i.e. viest l’extrémité terminale de ej) ;
0 sinon.
•Si G non-orienté
bi j=(
1 si viest une extrémité de ej;
0 sinon.
Exercice 1.3
1. Donner la matrice d’incidence du graphe 1.6.
2. Montrer le théorème 1.1 avec la matrice d’incidence.CHAPITRE 2
La connexité
Il est important de savoir si on peut suivre un chemin d’un sommet donné à un autre dans un graphe donné.
Cette propriété (de connexité) doit être maintenue dans différents types de réseaux.
2.1 Les chaînes et les cycles
Définition 2.1: (chaine – cycle) (chemin – circuit)
•Graphe non orienté
1. Une chaîne (walk ) reliant xày, notée µ(x,y), est définie par une suite finie d’arêtes consécutives,
reliant xày, ou encore une séquence de sommets (puisque non multigraphe)
µ(x,y)=<v0,v1,..., vk>
tels que v0=x,vk=yet (vi−1,vi)∈E(G) pour tout i=1... k. Six=yla chaîne est dite fermée .
Lalongueur du chaîne l(µ(x,y)) est le nombre d’arcs dans la chaîne, c’est-à-dire k.
2. Une chaîne élémentaire (a path ) si tous les sommets sont distincts. Une chaîne simple (a simple
walk, a trail ) est une chaîne ne passant pas deux fois par une même arête, c’est-à-dire dont toutes
les arêtes sont distinctes. Remarquer que : élémentaire =⇒ simple.
3. Un cycle v0v1...vnde longueur n≥3 est une chaîne simple fermée ( v0=vn) tel que les sommets
v0,v1,..., vn−1sont tous distincts. Un graphe sans cycle est dit acyclique .
•Graphe orienté
Dans un graphe orienté, on parlera de chemin au lieu de chaîne, et de circuit au lieu de cycle.
Example 2.1
abxcd xa est une chaîne simple et fermée (non cycle!) de longueur 6 (mais, c’est un graphe eulérien - voir
plus loin). Y a-t-il un cycle de longueur 3,4 ?
a b
x
c dÏ
Remarque 4.
1. On peut pivoter une chaine fermée (l’orienter de manière arbitraire) , i.e.
<v0,v1,v2,..., v0>=< vk,vk+1,..., v0,v1,..., vk>
1112 Chapitre 2. La connexité
2. Soient x ,y∈V . La distance de x à y est définie par :
d(x,y)=(
k si le plus court chemin/chaîne de x vers y est de longueur k
∞ sinon
On convient que d (x,x)=0.
3. Le diamètre du graphe la plus grande distance entre deux sommets.
L ’observation suivante, bien que très facile à prouver, sera utile.
Théorème 2.1
S’il existe une chaîne du sommet yau sommet zdans le graphe G, où y̸=z, alors il existe une chaîne élé-
mentaire ( path ) dans Gavec pour premier sommet yet pour dernier sommet z.
Preuve. Soit la chaine
W1=µ(y,z)=x0x1...xn; avec x0=yetxn=z.
Si les sommets x0,x1,..., xnsont tous distincts, alors W1est une chaîne élémentaire, et nous avons terminé. Sinon,
il existe xi=xj(i<j) et on écrit :
W2=x0x1...xixj+1...xn.
Alors, l(W2)<l(W1). Si W2ne contient aucun sommet répété, alors c’est la chaîne recherché. Sinon, par la même
procédure, il existe W3(y z−chaîne) tel que
l(W3)<l(W2)<l(W1).
Ce processus doit s’arrêter à un certain stade, car chaque chaîne est plus courte que la précédente et la longueur
ne peut jamais être inférieure à 1
1< ··· < l(Wk)< ··· < l(W3)<l(W2)<l(W1).
Ainsi, pour un certain k,Wkne peut pas être réduit en longueur. Donc, la chaîne Wkne contient aucun sommet
répété et est donc une y z−chaîne élémentaire (path).
Exercice 2.1
Dans le graphe suivant, construire un path à partir de la chaîne W=v2v3v4v5v6v4v2v8v1
v1
 v2
v3
v4
v5
v6
v7
 v8
 v9
Calculer d(v1,v7) et le diamètre de G.
/pythonpython : >>G = nx.Graph([(1, 2), (2, 3), (2, 4), ...]) >>nx.diameter(G)
Les cycles fournissent la caractérisation suivante pour les graphes bipartis .H. SABRI 13
Théorème 2.2
Un graphe est biparti si et seulement s’il ne contient aucun cycle de longueur impaire.
Preuve.
⇒On suppose que G=U˙∪Vest un graphe biparti. Soit W=< x1,x2,..., x2k+1,x1>un cycle de longueur im-
paire (2 k+1). Si x1∈U, alors
x1∈U=⇒ x2∈V=⇒ x3∈U=⇒ ··· =⇒ x2k+1∈U=⇒ x1∈V/exclamati⌢n-triangle
absurde, d’où le résultat.
⇐On suppose que Gest connexe (car l’union des composantes connexes bipartis est un graphe biparti). Soit
xun sommet de Get on pose :
U={y∈V(G):d(x,y) est paire} et V={z∈V(G):d(x,z) est impaire}
S’il existe y1,y2∈Utel que y1y2∈E(G), alors on a :
W1=<x,..., y1>est une chaîne de longueur paire =2k1
W2=<x,..., y2>est une chaîne de longueur paire =2k2
=⇒ W3=<x,..., y1,y2,..., x>est un cycle de longueur impaire =2k1+2k2+1/exclamati⌢n-triangle
Donc G=U˙∪Vest un graphe biparti.
Exercice 2.2
Vérifier si le graphe maison est un graphe biparti. Faire de même pour la grille G4,4.
maison grille
2.2 Graphe connexe, eulérien, hamiltonien
Définition 2.2: Graphe connexe
Un graphe est dit connexe si deux points peuvent toujours être joints par une chaîne, i.e.
∀x,y∈V(G),d(x,y)< ∞
— Une composante connexe d’un graphe est un sous-graphe induit maximal connexe.
— Un point d’articulation d’un graphe est un sommet dont la suppression augmente le nombre de
composantes connexes.
Par exemple, le graphe suivant :14 Chapitre 2. La connexité
a
 b
d
 c
e
f
 g
n’est pas connexe car il n’existe pas de chaîne entre les sommets aete. On a donc 2 composantes connexes. En
revanche, le sous-graphe induit par les sommets { a,b,c,d} est connexe dont aest le seul point d’articulation.
Remarque 5.
1. Un graphe connexe à n sommets possède au moins n −1arêtes ( faite une preuve par récurrence ).
2. L’algorithme de parcours en profondeur permet de déterminer si un graphe est connexe ou non.
3. Même définitions dans un graphe orienté . Graphe orienté (fortement) connexe et de composante connexe .
Définition 2.3: Graphe eulérien
— Une chaîne joignant deux sommets xetyest dite chaîne eulérienne si elle emprunte chaque arête
deGune et une seule fois. On parle de chemin eulérien dans le cas d’un graphe orienté.
— Un cycle eulérien est une chaîne eulérienne dont les extrémités coïncident. Un graphe qui admet
un cycle (resp. circuit) eulérien est dit graphe eulérien .
/flushedRemarquer qu’un cycle eulérien n’est pas forcément un cycle comme définit dans la définition 2.1
Si un graphe (ou multigraphe) Gpossède une chaîne eulérienne, alors soit Gpossède deux sommets impairs, le
début et la fin de cette chaîne, soit Gn’a aucun sommet impair, et la promenade d’Euler commence et se termine
au même point (cycle eulérien). Une autre condition nécessaire évidente est que Gdoit être connexe. Ces deux
conditions sont ensemble suffisantes.
Théorème 2.3 Euler
Soit Gun graphe (multigraphe) connexe.
— Si Gn’a pas de sommets impairs, alors il possède un cycle eulérien (commençant à n’importe quel
point).
i.e.∀x,d(x)≡0 mod 2 =⇒ Gest un graphe eulérien.
— Si Ga deux sommets impairs, alors il possède une chaîne eulérienne dont le début et la fin sont les
sommets impairs.
La réciproque est aussi vraie.
Preuve.
⇐On commence par la réciproque. S’il existe une chaîne eulérienne µ(x,y), alors on peut crée une arête fictive
e=(y,x) et par la suite on obtient un cycle eulérien. Donc il suffit de montrer que si Gadmet un cycle
eulérien alors tous les sommets sont de degré pair.
Soit W=< v1,v2,..., vn,v1>un cycle eulérien. Soit le sommet vjavec j̸=1, il est donc claire que chaque
fois vjapparaît dans W, il ya deux arcs distincts incidents en vj( (•,vj) et ( vj,•)). Comme toutes les arêtes
sont utilisées, on voit que d(vj) est pair. Même chose pour v1car on ajoute deux arcs ( v1,v2) et ( v1,vn).
⇒On suppose que tous les sommets sont de degré pair. Montrons que Gadmet un cycle eulérien. Puisque
tous les sommets sont de degré pair on peut construire d’abord une chaîne simple fermée (quelconque)
W1=<v1,v2,..., vk,v1>
SiW1contient chaque arête de G, alors c’est finis, c’est un cycle eulérien. Sinon (puisque Gest connexe), il
existe une arête e=(vi,c) qui n’est pas dans W1(avec visommet de W1). On pose le sous-graphe
G′=G−{ arêtes de W1}H. SABRI 15
Il est donc claire que les sommets de G′sont aussi de degré pair. Alors, par la même procédure on construit
une chaîne simple fermée dans G′de la forme : <vi,c,d,..., vi>et par la suite on insère cette chaîne dans
W1pour obtenir :
W2=<v1,v2,..., vi,c,d,..., vi,vi+1,..., vk,v1>
Sil(W2)< |E(G)|, on construit W3de longueur plus grand. Ainsi, on a :
l(W1)<l(W2)<l(W3)< ··· ≤ | E(G)|
Donc, nécessairement, il existe Wk(chaîne simple fermée de longueur |E(G)|) donc c’est un cycle eulérien.
Finalement , si∃a,b∈V(G):d(a)≡d(b)≡1 mod 2, et tous les autres sommets sont de degré pair, alors on
pose :
G′=G+{a,b}
et donc tous les sommets de G′sont de degré pair. Avec la construction précédente, il existe un cycle eulérien
dans G′:
W=<a,b,v1,..., a>
est donc la chaîne <b,v2,..., a>est une chaîne eulérienne dans G.
Algorithme 1 : Euler
Entrées : Gun graphe eulérien
Output : Un cycle eulérien W
/* On suppose que G est eulérien, i.e. les sommets sont de degré pair */
1Gaux←G;W←µ(v,v) une chaîne simple (quelconque) de G; // Initialisation
2tant que l(W)<e(G)faire
3 Gaux←G−{ arêtes de W} ;
4 Choisir ( x,c)∈E(Gaux) tel que x∈W;
5 L←< x,c,..., x>une chaîne simple de Gaux ;
6 Dans W, remplacer (juste ce) xpar la séquence L;
7fin
8retourner W;
Exercice 2.3
1. Montrer que le graphe de l’exercice 2.1 est un graphe eulérien et donner un cycle eulérien.
2. Tracer cette maison d’un seul trait.
Remarque 6. Le théorème d’Euler dans un graphe orienté connexe s’écrit :
Admet un circuit eulérien si, et seulement si, pour tout sommet, le degré entrant est égal au degré sortant.
∀v∈V(G),d+(v)=d−(v)
Admet un chemin eulérien de a vers b si, et seulement si,


d+(v)=d−(v) ;∀v̸=a,b,
d−(a)=d+(a)−1
d−(b)=d+(b)+116 Chapitre 2. La connexité
Définition 2.4: Graphe hamiltonien
Soit Gun graphe connexe d’ordre n. On appelle :
1. On appelle cycle hamiltonien deGun cycle passant (une et une seule fois) par chacun des sommets
deG. Un graphe est dit hamiltonien s’il possède un cycle hamiltonien.
2. Une chaîne hamiltonienne est une chaîne passant une et une seule fois par chacun des sommets de
G. Un graphe ne possédant que des chaînes hamiltoniennes est semi-hamiltonien .
3. Dans un digraphe, on change cycle par circuit et chaîne par chemin .
Remarque 7.
— Une chaîne hamiltonienne est une chaîne élémentaire de longueur n −1.
— Un graphe peut être eulérien, hamiltonien, les deux à la fois, ou aucun des deux.
— De nombreux problèmes concrets peuvent être formulés en termes de recherche de parcours hamiltoniens : pro-
blème du voyageur de commerce (chercher un cycle hamiltonien de longueur totale minimale), l’ ordonancement
de tâches .
— Le problème du chaîne hamiltonienne est un problème NP-complet .
Exercice 2.4
Donner un graphe (connexe, simple) qui soit :
1. hamiltonien et eulérien.
2. hamiltonien et non eulérien.
3. eulérien et non hamiltonien.
4. non hamiltonien et non eulérien.
Aucune condition nécessaire et suffisante adéquate n’est connue pour l’existence de cycles hamiltoniens. Le
résultat suivant constitue une condition suffisante utile.
Théorème 2.4 Ore
Soit Gun graphe simple d’ordre n≥3. Si pour toute paire { x,y} de sommets non adjacents, on a d(x)+d(y)≥
n, alors Gest hamiltonien.
Preuve. On suppose que le théorème est faux. Alors, il existe un graphe Gsimple d’ordre nnon hamiltonien tel que
d(u)+d(v)≥npour tout sommets non adjacents uetv. On prend Gun tel graphe d’ordre nde taille maximale qui
vérifie cette propriété (remarquer que le graphe complet Knest hamiltonien).
Soient uetvdeux sommets non adjacents de G. Par maximalité de G, le graphe G+uv(d’ordre n) doit être
hamiltonien. Donc il existe dans G+uvun cycle hamiltonien :
W=<u,x1,x2,..., xn−2,v,u>
u
x1
xi xi+1xn−2
v
... ...
Or, si uxi+1∈E(G) etv xi∈E(G) (les arcs en rouge), alors on peut construire dans Gle cycle hamiltonien :
<u,x1,x2,..., xi,v,xn−2,..., xi+1,u>H. SABRI 17
Ceci est absurde car Gest non hamiltonien. Donc si xi+1est un sommet voisin à u, alors le sommet xin’est pas
voisin de v:
xi+1∈Γ(u)=⇒ xi∉Γ(v)
Donc :
d(u)= |Γ(u)| =p=⇒ d(v)≤(n−1)−p
et par la suite
d(u)+d(v)≤n−1
ce qui absurde par hypothèse. Donc Gest hamiltonien.
Une conséquence immédiate est le théorème de Dirac :
Proposition 2.1 Dirac
Soit Gun graphe simple d’ordre n≥3. Si pour tout sommet xdeG, on a d(x)≥n
2, alors Gest hamiltonien.
2.3 Arbres
Définition 2.5: Arbres et forêts
On appelle arbre tout graphe (non orienté) connexe et acyclique . Les composantes connexes dans un
graphe acyclique sont des arbres et le graphe est dit forêt . Une feuille ou sommet pendant est un som-
met de degré 1.
Un forêt avec deux arbres
Un graphe Gest une arborescence s’il existe un sommet Rappelé racine deGtel que, pour tout sommet
SdeG, il existe un chemin et un seul de Rvers S. Donc, c’est un arbre orienté dans lequel on choisit un
sommet Rcomme racine et on dirige les arcs vers le sens sortant de la racine.
Remarque 8.
— Un graphe G d’ordre n est un arbre ssi G est sans cycle et possède n −1arêtes.
— Un graphe G d’ordre n est un arbre ssi G est connexe et possède n −1arêtes.
— G est un arbre si pour chaque paire u ,v de sommets distincts est reliée par une seule chaîne (donc chaîne
élémentaire d’après le théorème 2.1).
— Un arbre (ou forêt) est nécessairement un graphe simple.
Pour démontrer les remarques précédentes, il suffit de prouver le théorème suivant :
Théorème 2.5
Soit Gun graphe ayant marêtes, nsommets et pcomposantes connexes, on définit nu( G) :
ν(G)=m−n+p
Alors, on a :
1.ν(G)≥0.
2.ν(G)=0⇐⇒ Gest acyclique.18 Chapitre 2. La connexité
Preuve. Par récurrence sur la taille mdu graphe. Le résultat est évident pour m=0 et m=1. On suppose le résultat
est vrai pour les graphe de taille m, et montrons que ceci est vrai pour un graphe de taille m+1. Soit donc Gun
graphe d’ordre nde taille m+1 ayant pcomposantes connexes.
•On suppose que Gest un graphe acyclique. Soit uvune arête de Gdans la composante C. Si on supprime uv,
la composante Cse transforme en deux composantes connexes (sinon on a un cycle dans G). Par la suite,
le graphe G′=G−uvest un graphe acyclique d’ordre n, de taille met ayant p+1 composantes connexes.
Donc d’après l’hypothèse de récurrence :
ν(G′)=0=(m−1)−n+(p+1)=m−n+p=ν(G)
•Maintenant, si Gcontient un cycle Wdans la composante connexe C. Soit uvune arête de W, alors si on
supprime l’arête uv, la composante Creste connexe. Donc le graphe G′=G−uvest un graphe d’ordre nde
taille m−1 ayant pcomposantes connexes. Donc, d’après l’hypothèse de récurrence :
ν(G′)=(m−1)−n−p≥0
=⇒ν(G)=m−n−p≥1>0
D’où le résultat – car si ν(G)=0,Gne peut être que acyclique, sinon 0 =ν(G)≥1/exclamati⌢n-triangle
2.3.1 Codage et décodage d’un arbre – Prüfer code
Soit Tun arbre ayant nsommet numérotés {1,2,..., n}. Le codage de Prüfer représente l’arbre Tarbre de avec
une suite P=(x1,x2,x3,..., xn−2) de n−2 termes (les n° des sommets avec répétition possible). Une suite Pdonnée
correspond à un et un seul arbre numéroté. Voici les algorithmes de codage et de décodage.
Algorithme 2 : Codage de Prüfer
Entrées : Un arbre T
Output : Séquence de Prüfer P
1P←() ; // Initialisation de P comme séquence vide
2tant que v(T)>2faire
3 x←feuille de Tayant le n° minimum ; // donc d(x)=1
4 P←(P,s) où sest le seul (n°) sommet adjacent à x;
5 T←T−x;
6fin
7retourner P;
Example 2.2
Donner le code de Prüfer de l’arbre :
126 345
Indice : on trouve, P=(2,3,3,2)
Pour faire la réciproque, étant donnée une séquence P=(x1,x2,..., xn−2) où les xi∈{1,2,..., n}, on construit
l’arbre Tdont les sommets sont {1,2,..., n} avec l’algorithme suivant (le décodage) :H. SABRI 19
Algorithme 3 : Décodage de Prüfer
Entrées : Une séquence Pde taille n−2
Output : L ’arbre Tcorrespondante
1I←{1,2,..., n};
2T←graphe tel que V(T)=IetE(T)= ; ; // T graphe à n sommets isolés
3tant que P̸=()faire
4 i←min {x∈I:x∉P};
5 T←T+(i,P[1]) ; // ajouter l'arc (i,P[1])
6 P←P−P[1];I←I−{i};
7fin
8T←T+(a,b) ; // a,b sont les deux éléments restant dans I
9retourner T;
Example 2.3
Donner l’arbre dont le code de Prüfer est : P=(2,3,3,3)
Puisqu’il ya une bijection entre les arbres d’ordre net les suites Pde longueur n−2 à coefficients dans {1,2,..., n},
on déduit le théorème de Cayley :
Théorème 2.6 Formule de Cayley
Le nombre d’arbres que l’on peut construire sur n(n≥2) sommets numérotés est égal à nn−2.
2.3.2 Arbre couvrant de poids minimum – ACM
Soit Gun graphe (non orienté). Un arbre couvrant (spanning tree) TdeGest un sous graphe couvrant de G
tel que Test un arbre. Remarquer que, Gdoit être connexe, sinon un arbre couvrant de Gn’existe pas. Le nombre
des arbres couvrant de Gest noté a(G). Remarquer que a(Kn)=nn−2(le nombre de Cayley). Un problème algo-
rithmique classique est de trouver, dans un graphe valué , un arbre couvrant de poids minimal . On dispose de
plusieurs algorithmes (l’algorithme de Prim, l’algorithme de Kruskal ...).
Algorithme 4 : Kruskal
Entrées : Un graphe Gvalué d’ordre net de taille m
Output : Arbre (ou forêt) couvrant de poids minimum
1Numéroter les arêtes de Gpar poids minimum : w(e1)≤w(e2)≤ ··· ≤ w(em)
2T←graphe tel que V(T)=V(G) etE(T)= ; ; // T graphe à n sommets isolés
3k←0;
4tant que k<m et e (T)<n−1faire
5 siT+ek+1est acyclique alors
6 T←T+ek+1;
7 k←k+1;
8fin
9retourner T;
Appliquer l’algorithme de Kruskal dans le graphe suivant :
CHAPITRE 3
Les algorithmes de base
Beaucoup de problèmes sur les graphes nécessitent que l’on parcourt l’ensemble des sommets et des arcs. Par
exemple, pour vérifier que le graphe est connexe, chercher un sommet particulier, construire un arbre couvrant,
trouver un plus court chemin ...etc.
3.1 Parcours en profondeur (DFS) / largeur (BFS)
Une manière simple de tester si un graphe Gest connexe ou non est d’exécuter l’algorithme DFS ouBFS dans
Gen commençant par n’importe quel sommet et en enregistrant les sommets visités pendant l’exécution dans une
liste. Si la liste contient tous les sommets de G, alors Gest connexe. Une petite modification permet de donner les
composantes connexes de G. L ’algorithme DFS_Component suivant donne les composantes connexes de G. Il est
donné sous forme d’implémentation récursive.
Algorithme 5 : DFS_Component
Entrées : Un graphe G=(V,E)
Output : Les composantes connexes C=(C1,C2,..., Ck) de G.
1VisitedNodes ← ; ;
2k←0 ; // k est le nombre des composantes connexes
3pour chaque u∈Vfaire
4 siu∉VisitedNodes alors
5 k←k+1;
6 DFS( u);
7 fin
8fin
9retourner (C1,C2,..., Ck);
1Procedure DFS( u )
2 VisitedNodes ←VisitedNodes ∪{u};
3 Ck←Ck∪{u};
4 pour chaque x∈Γ(u)faire
5 six∉VisitedNodes alors
6 DFS( x);
7 fin
8 fin
Note : -
Il est possible de d’implémenter la procédure DFS itérativement à l’aide d’une pile LIFO (stack) contenant les
sommets à explorer : on désempile un sommet et on empile ses voisins non encore explorés.
20H. SABRI 21
Pseudocode :
stack . push ( root )
while stack . isEmpty ( ) = f a l s e do
node = stack . pop ( ) // so mark i t as v i s i t e d
for each x in node . childNodes do
i f x i s not v i s i t e d then
stack . push ( x )
. . .
endfor
endwhile
Example 3.1 (DFS )
Ici on empile (gris) les sommets les plus à droite, alors l’ordre des sommets visité (noir) est ( a,b,d,e,g,c,f).
Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b
 c
d
 e
f
g
a
b
 c
d e
f
ga
b
 c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g
L ’utilisation d’une file (FIFO) au lieu d’une pile transforme l’algorithme du parcours en profondeur en algo-
rithme de parcours en largeur ( BFS ). Avec BFS l’exemple précédent devient (en enfile le plus à gauche) :
Example 3.2 (BFS )
Ici, avec BFS, on enfile (gris) les sommets les plus à gauche d’abord, alors l’ordre des sommets visité (noir)
est ( a,b,d,e,g,c,f). Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b c
d
 e
f
g
a
b c
d
 e
f
ga
b c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g22 Chapitre 3. Les algorithmes de base
Exercice 3.1
1. Écrire la procédure BFS .
2. Utiliser DFS (ou BFS) pour la construction d’un arbre couvrant d’un graphe connexe. L ’appliquer
pour le graphe triangle.
3. Utiliser DFS pour écrire une procédure DFS_Cycle pour détecter un cycle dans un graphe.
On sait qu’un graphe orienté G=(V,E) est fortement connexe si pour chaque paire de sommets u,v∈V, il
existe un chemin de uàvet il existe un chemin de vàu. En d’autres termes, nous avons besoin d’une connectivité
dans les deux directions .
Une procédure pour tester si un graphe orienté est fortement connexe ou non peut être conçue avec l’idée
suivante. En partant d’un sommet arbitraire vdu graphe G, on exécute l’algorithme BFS ouDFS et l’on note les
sommets visités. Ensuite, on obtient la transposée de G,GT, en inversant la direction des arêtes de G, et l’on
exécute à nouveau l’algorithme BFS ou DFS à partir du sommet v. Si les sommets visités dans les deux cas sont
égaux à V, alors le graphe orienté est fortement connexe. Cette méthode est illustrée dans l’algorithme 6.
Algorithme 6 : Fortement_connexe
Entrées : Un graphe orienté G=(V,E)
Output : true siGest fortement connexe et false sinon
1X← ; ;
2Y← ; ;
3v←un sommet quelconque de V;
4X←DFS( G,v) ; // Enregistrez les sommets visités dans X
5GT←Gavec flèches inversées;
6Y←DFS( GT,v);
7siX=Y=Valors
8 retourner TRUE.
9sinon
10 retourner FALSE.
11fin
3.2 Recherche des chemins
3.2.1 Matrice d’adjacence et nombre de chemins
La puissance de la matrice d’adjacence Amontre qu’il y a des chemins (ou chaînes) de longueur kallant de xà
ycomme le montre le théorème suivant.
Théorème 3.1
Soit G=(V,E) un (di)graphe. On note V={1,2,..., n} et Asa matrice d’adjacence et Akla puissance k-ème
deA. Alors le terme d’indices i,jdeAkest le nombre de chemins (chaînes) de longueur kallant de iàj.
Preuve. Par récurrence sur k. Pour k=1 c’est clair. On suppose le résultat est vrai à l’ordre ket montrons qu’elle
est vrai pour k+1. Soit S=(si,j)=Ak. Si on a un chemin de iàjde longueur k+1, alors on va d’abord de ià un
sommet ravec kpas et puis de ràj. Or d’après l’hypothèse de récurrence on a si,rchemins possibles pour aller de
iàret finalement ar,jpas (1 ou 0) pour aller de ràj. Ainsi, le nombre totale possibles (i.e. tous les sommets r) est :
nX
r=1si,rar,j=³
Ak×A´
i,jH. SABRI 23
ce qui est bien le terme ( i,j) de la matrice Ak+1.
3.2.2 Plus court chemin et l’algorithme de Dijkstra
Dans cette partie on suppose que le (di)graphe G=(V,E,w) est valué positivement (i.e.∀e∈E,w(e)>0). Notre
objectif est de chercher un plus court chemin (i.e., un chemin de poids minimal ) d’un sommet ufixé à un sommet
quelconque de G.
Il est clair que l’on peut restreindre ce problème au cas d’un (di)graphe simple1. On suppose aussi que Gest
connexe (sinon, certains trajets sont impossibles). Il est aussi claire (d’après théorème 2.1), qu’un plus court chemin
est nécessairement un chemin élémentaire (path).
L ’algorithme de Dijkstra (1959) permet de calculer le plus court chemin entre un sommet particulier u(racine )
et tous les autres sommets. L ’algorithme fonctionne de la manière suivante :
Pour tout sommet vdeG, on associe une valeur T(v), initialisée à w(u,v) et une liste de sommets C(v) qui
correspond à un chemin de uàv. À la fin de l’algorithme, T(v) contient le poids minimal des chemins joignant uà
v(ou T(v)= ∞ siu↛v) et la liste C(v) réalise un tel chemin. Voici donc l’algorithme de Dijkstra :
Algorithme 7 : Algorithme de Dijkstra
Entrées : Un (di)graphe valué G=(V,E,w) et un sommet racine u
Output : Le coût minimum d’un chemin de uàv(∀v∈V) et un trajet pour chaque coût minimal obtenu
1∀v∈V,T(v)←w(u,v) etC(v)←(u,v); // Initialisation de T(v) et la liste C(v)
2X←{u};
3tant que X̸=Vfaire
4 Choisir v∈V−Xtel que ∀y∈V−X,T(v)≤T(y);
5 X←X∪{v};
6 pour chaque y∈V−Xfaire // Faire les mises à jours pour les autres sommets
7 siT(y)>T(v)+w(v,y)alors
8 T(y)←T(v)+w(v,y);
9 C(y)←[C(v),y]; // On ajoute à la liste C(v) l'élément y
10
11 fin
12 fin
13fin
Example 3.3
Voici une application de l’algorithme de Dijkstra au digraphe suivant. On prend Ecomme sommet racine.
EA
B
CD
FG
S5
4
21
12
2
34
4
215
7
1. En effet, passer par une boucle ne ferait qu’augmenter inutilement le poids de ce chemin. De même, si plusieurs arcs joignent deux
sommets, il suffit de conserver l’arc de poids minimal.24 Chapitre 3. Les algorithmes de base
Ainsi, pour l’initialisation, on a : X={E} et on a les valeurs :
v  E A B C D F G S
T(v) 0 5 4 2 ∞ ∞ ∞ ∞
C(v)(E,E) ( E,A) ( E,B) ( E,C) ( E,D) ( E,F) ( E,G) ( E,S)
Maintenant, on choisit (un seul choix) le sommet C, donc X={E,C}. Le tableau est mis à jour :
v  E A B  C D F G S
T(v) 0 5 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À l’étape suivante, on est forcé de choisir B. Ainsi, X={E,C,B} et la mise à jour est :
v  E A  B  C D F G S
T(v) 0 4 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À présent, on a le choix entre AetF. On choisit A. Donc X={E,C,B,A} et on a :
v  E  A  B  C D F G S
T(v) 0 4 3 2 6 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,B,A,D) ( E,C,F) ( E,C,G) ( E,S)
Puis, on prend le sommet F. D’où X={E,C,B,A,F} et :
v  E  A  B  C D  F G S
T(v) 0 4 3 2 5 4 5 11
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,S)
On prend Det on obtient X={E,C,B,A,F,D} et :
v  E  A  B  C  D  F G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Finalement, on prend Gpuis Set on voit que ceci ne change rien. D’où le tableau finale :
v  E  A  B  C  D  F  G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Ainsi le chemin minimum pour aller de EàSest de coût 10 et un trajet de coût minimal de EàSest : EC F DS .H. SABRI 25
3.3 Problèmes d’ordonnancement et chemin critique
Un problème d’ordonnancement peut-être représenté sous la forme d’un digraphe. Les sommets sont des évé-
nements (début et fin de la tâche) et les arcs des tâches, La longueur (ou poids) de chaque arc représente la durée
d’exécution de la tâche. Ainsi, la tâche correspondant à l’arc ( i,j) ne peut commencer que si toutes les tâches cor-
respondant à des arcs ( k,i) ont été complétées. On ajoute deux sommets pour le début (s) et de fin(t) du projet .
Le digraphe peut contenir des tâches fictives dedurée nulle afin de forcer certaines précédences (postériorité).
Ainsi, un réseau PERT est un digraphe valué G=(V,E,w,s,t) où la fonction poids (ou longueur) w:E→R+
etsle sommet source (début) et tle sommet puits (fin). Un chemin critique est un chemin de sàtdelongueur
maximale . S’il n’existe pas de chemin critique, le projet n’est pas réalisable (e.g. un circuit). Le temps minimal
requis pour l’exécution d’un projet réalisable est égal à la longueur d’un chemin critique. Les tâches figurant sur un
chemin critique sont aussi appelées critiques, ce qui s’explique par le fait que tout retard d’exécution d’une tâche
critique retarde d’autant l’exécution du projet.
3.3.1 Algorithmes de tri topologique et de chemin critique
Il faut d’abord numérotés les sommets de 1 à nde manière compatible au pré-ordre (rang) avec l’algorithme du
rang suivant (tri topologique) :
Algorithme 8 : Algorithme du rang
Entrées : Un digraphe G=(V,E) sans circuit
Output : Le rang r(v) de chaque sommet v∈Vde G
1r←0;X←V;
2R←{v∈X:Γ−
X(v)= ;} ; // l'ensemble des sommets de X sans prédécesseur dans X
3tant que X̸= ; faire
4 r(v)←rpour chaque sommet v∈R;
5 X←X−R;
6 R←l’ensemble des sommets de Xsans prédécesseur dans X;
7 r←r+1;
8fin
On supposera dorénavant que les sommets ont déjà été numérotés de 1 à nde manière compatible avec leurs
rangs, c’est-à-dire que r(j)>r(i) implique j>i(donc 1 =setn=t). Enfin, on supposera éliminés les arcs paral-
lèles par l’introduction de tâches fictives de durée nulle .
Pour un sommet i, on note tiledébut au plus tôt des tâches correspondant aux arcs i→jet par Tilafin au
plus tard des tâches correspondant aux arcs j→i.
Algorithme 9 : Algorithme du chemin critique
Entrées : Un digraphe G=(V,E) sans circuit trié topologiquement
Output : La durée du chemin critique et les dates ti,Ti
1t1←0;
2pour j=2···nfaire // Calcul des dates de début au plus tôt  récurrence en avançant
3 tj←max i∈Γ−(j){ti+w(i,j)}
4fin
5Tn←tn;
6pour j=n−1···1faire // Calcul des dates de fin au plus tard  récurrence en reculant
7 Tj←min i∈Γ+(j){Ti−w(j,i)}
8fin26 Chapitre 3. Les algorithmes de base
Définition 3.1
— Un sommet iest critique si ti=Ti.
— Un arc ( i,j) est critique les sommets ietjsont critiques ettj−ti=w(i,j).
— Un chemin critique est un chemin de 1 à nn’utilisant que des arcs critiques.
— La durée du chemin critique est donnée par Tn(ou par tn). Elle correspond à la durée minimale du
projet .
Example 3.4
L ’application de l’algorithme du chemin critique au digraphe suivant (trié topologiquement) est :
1 23
45
6B
9A
3
C
5D
8
E
4
F7G
20
H6I5
=⇒
 1
0,02
9,933,16
4
16,23513,24
6
29,29B
9A
3
C
5D
8
E
4
F7G
20
H6I5
Les tâches critiques sont BetG. La durée totale minimale du projet est donc 29.
Exercice 3.2
Les tâches ( durée et précédences ) pour la construction d’un entrepôt sont données dans le tableau suivant :
Tâches Nature Précédences Durée (jours)
A Acceptation des plans par le propriétaire – 4
B Préparation du terrain – 2
C Commande des matériaux A 1
D Creusage des fondations A, B 1
E Commande des portes et fenêtres A 2
F Livraison des matériaux C 2
G Coulage des fondations D, F 2
H Livraison des portes et fenêtres E 10
I Pose des murs, de la charpente et du toit G 4
J Mise en place des portes et fenêtres H, I 1
1. Représentez le graphe des précédences de ce projet (trié topologiquement).
2. Déterminez une durée totale minimale en exhibant un chemin critique dans ce graphe.CHAPITRE 4
Programmation linéaire
La programmation linéaire est le processus de minimiser ou maximiser une fonction objective linéaire sou-
mise à un nombre fini de contraintes d’égalités et d’inégalités linéaires.
La programmation linéaire a de nombreuses applications dans le domaine de l’informatique théorique. Elle
peut être utilisée pour résoudre de nombreux problèmes combinatoires variés, tels que la recherche de flot maxi-
mum dans un réseau, la recherche d’un couplage maximal dans un graphe et la coloration d’un graphe parfait.
Example 4.1 (Problème de régime)
On suppose qu’on a quatre plats : de la truite ( XT), un sandwich au corned-beef ( XC B), un burrito ( XBU R )
et un hamburger ( XHB). Le tableau suivant répertorie la valeur nutritionnelle de chaque plat (vitamines et
calories) et notre besoin journalier des vitamines.
Vit. A Vit. C Vit. D Calories
Truite 203 92 100 600
Corned-beef 90 84 230 350
Burrito 270 80 512 250
Humburger 500 90 210 500
Besoins 2000 300 430
Notre objectif est de minimiser le nombre total de calories consommées : 600 XT+350XC B+250XBU R+
500XHBtout en satisfaisant les trois besoins nutritionnels en vitamines. Le programme linéaire résultant
s’écrit :
min 600 XT+350XC B+250XBU R+500XHB
s.t. 203 XT+90XC B+270XBU R+500XHB≥2000, (Besoins de Vit. A),
92XT+84XC B+80XBU R+90XHB≥300, (Besoins de Vit. C),
100XT+230XC B+512XBU R+210XHB≥430, (Besoins de Vit. D),
XT,XC B,XBU R ,XHB≥0
Définition 4.1: Forme canonique – Forme standard
On peut écrire un P .L. sous deux formes spéciales :
•Canonique
max
mincTX+c0
s.t. AX≤b(≥bsi min),
X≥0•Standard
max cTX+c0
s.t. AX=b,
X≥0Avec :
cTX=¡
c1··· cn¢
x1
...
xn

cTX+c0=c1x1+c2x2+···+ cnxn+c0
2728 Chapitre 4. Programmation linéaire
Remarque 9. Un P .L. général peut être formulé selon une forme standard ou canonique par la méthode suivante :
générale =⇒ standard il faut éliminer les contraintes d’inégalité et les variables sans contrainte de positivité.
— Si dT
iX≤biest une contrainte d’inégalité, alors créer une nouvelle variable ( d’écart ) siet remplacer l’in-
égalité dT
iX≤bipar dT
iX+si=biet s i≥0.
Si dT
iX≥bi, alors on peut écrire dT
iX−si=biet s i≥0.
— Si une variable x i≶0est de signe quelconque, alors créez deux nouvelles variables x+
iet x−
iet remplacez
xipartout par x+
i−x−
i, et ajoutez les contraintes de signe : x+
i≥0,x−
i≥0.
générale =⇒ canonique
— Si dT
iX=biest une contrainte d’égalité, alors remplacer cette égalité par une paire d’inégalités :
dT
iX≥biet−dT
iX≥ −bi
— Même chose que précédemment si la variable x i≶0.
Il est facile de voir que les problèmes qui en résultent sont équivalents aux problème d’origine. Pour l’algorithme
simplexe , nous utiliserons la forme standard .
On remarque aussi qu’en utilisant la relation min f(x)= − max¡
−f(x)¢
dans laquelle f (x)représente la fonction-
nelle linéaire à optimiser, on peut toujours se ramener à un problème de minimisation (ou de maximisation).
Example 4.2
Le P .L :max 5 x+4y
s.t. x≤6
1
4x+y≤6
3x+2y≤22
x,y≥0s’écrit sous forme standard :max 5 x1+4x2
s.t. x1+e1=6
1
4x1+x2+e2=6
3x1+2x2+e3=22
x1,x2,e1,e2,e3≥0
Donc (sous la forme matricielle) on a :
cT=¡
5 4 0 0 0¢
;A=
1 0 1 0 0
1
41 0 1 0
3 2 0 0 1
;X=
x1
x2
e1
e2
e3
et b=
6
6
22

4.1 La méthode simplexe
4.1.1 Solution de base admissible
On suppose que la matrice Adu programme linéaire est de type m×netde rang m(pourquoi !). Soit Bla
matrice carrée extraite de Aformée par les mcolonnes j1,j2,..., jmlinéairement indépendants de A(les vecteurs
de base). Alors, Best une matrice inversible. Ainsi si on pose xl=0 sil∉{j1,..., jm} etxjklak-ième composante de
B−1b. Alors, on a AX B=b. Si de plus XB≥0(i.e. chaque xi≥0), alors :
Xest une solution de base admissible (ou réalisable)
Dans l’exemple 4.2, la matrice extraite B=
1 0 0
0 1 0
0 0 1
est inversible et B−1b=
6
6
22
. Donc XB=
0
0
6
6
22
≥0, par suite
XBest une solution de base admissible. On appelle les variables xjklesvariables de base . Les autres variables xl
sont les variables hors-base .
Parfois, il n’est pas évident de trouver une solution de base admissible, comme le montre l’exercice suivant :H. SABRI 29
Exercice 4.1
Écrire le programme linéaire suivant sous forme standard et montrer qu’on n’a pas une solution de base
admissible. Résoudre le programme linéaire.
max −x+y
s.t. x+y≥1,
3x+2y=6,
x,y≥0
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux
Dans cette section, on suppose qu’on a déjà trouvé une solution de base admissible X(produite avec B=Im)
du programme linéaire ( P: max z=cTX+c0etb≥0pour garantir que 0est une solution de AX≤b).
La méthode du simplexe est une méthode itérative qui génère une séquence de solutions de base réalisable
(correspondant à différentes bases) et s’arrête finalement lorsqu’elle a trouvé une solution de base réalisable opti-
male. Remarquer qu’on peut toujours prendre c0=0.
Algorithme 10 : Algorithme du simplexe
Entrées : Un P .L. standard P(max) avec une solution de base réalisable
Output : La solution optimale (ou non)
1On commence à écrire le tableau initiale (avec les variables de base xj1,..., xjm)
VB x1 ... xn b
xj1 b1
... A...
xjm bm
c1 ... cn−c0
2Sicj≤0 (∀j:xjest hors base), alors solution optimale (STOP) // min ⇝cj≥0
3Trouver la colonne s(hors base) tel que cs=max©
cj:cj>0ª// min ⇝cs=min©
cj:cj<0ª
4Siai,s≤0∀i=1... m, alors pas de solution optimale (STOP)
5Min Ratio Test : trouver la ligne rtel que
br
ar,s=min
i=1...m½bi
ai,s:ai,s>0¾
6Appliquer la procédure de Gauss autour de pivot ar,s(ar,s⇝1 et on annule les coefficients situés sous et
sur le pivot dans la colonne s, par combinaisons de lignes) // Ne pas oublier la dernière ligne
7Remplacer (dans VB) la variable de base ( sortante ) située à la ligne rpar la variable ( entrante )xs
8Retourner à l’étape 2 // l'algorithme termine si le programme linéaire est non dégénéré
Remarque 10.
— La dernière ligne représente l’équation linéaire −z+c1x1+···+ cnxn= −c0.
— La valeur de la variable de base de V Bde la ligne k est égale à la valeur b k(de la ligne k).
— La solution optimale du problème est la valeur finale (dernière cellule) (×− 1).
— Si on n’a pas au départ B =Im(à l’aide des variables d’écart) alors, on ajoute les variables artificielles (et on
applique d’abord la phase I - voir section suivante).30 Chapitre 4. Programmation linéaire
Exercice 4.2
Soit le programme linéaire :
max 2 x1+x2
s.t. x1−x2≤3,
x1+2x2≤6,
−x1+2x2≤2,
x1,x2≥0
Rajouter les variables d’écart. Puis résoudre le problème par l’algorithme du simplexe.
Remarque 11. Vérifier le résultat de l’exercice précédent, par la méthode graphique.
4.1.3 Initialisation - Phase I du simplexe
Un programme linéaire est dit sous forme simpliciale si la matrice Acontient la matrice identité Imcomme
sous matrice. On suppose que le programme linéaire P, après la mise en forme AX=b, n’est pas simpliciale
(possible dans le cas de contraintes du type ≥ou du type =). Soit Bune matrice d’ordre mextraite de Ainversible
tel que B−1b≥0et soit XBla solution de base réalisable ( XB≥0etAX B=b), alors on peut changer l’équation
matricielle :
AX B=b
⇐⇒ (B−1A)XB=B−1b
⇐⇒ A∗XB=b∗
et la matrice A∗contient la matrice identité Imcomme matrice extraite ( B−1A=B−1(H|B)=¡
B−1H|Im¢
). Ainsi, on
peut appliquer directement l’algorithme 10 en remplaçant Apar A∗etbpar b∗. Cependant, cette méthode n’est
pas efficace, car il faut trouver une matrice extraite Bréalisable correspondante. Pour une matrice Ade type m×n,
il existe¡m
n¢
matrices extraites à tester !
L ’idée est d’ajouter des variables, dites artificielles w1,w2,..., wm, pour faire apparaître une forme simpliciale
du programme linéaire P: (AX=b). Mais, il faut que w1= ··· = wm=0. Donc, il faut minimiser d’abord le pro-
gramme linéaire P0suivant :
P0=min W=w1+···+ wm
s.t. (A|Im)×(x1...xnw1...wm)T=b
x1,..., xn,w1,..., wm ≥0
On exprime Wà l’aide des autres variables (hors base) et puis on applique l’algorithme du simplexe 10 pour P0
(phase I). À la fin, si on trouve que les wi=0, alors les variables de bases xj1,..., xjmforment une première base
admissible pour démarrer le simplexe pour le programme d’origine P.H. SABRI 31
Remarque 12. On ajoute la ligne de Z :c1 ... cn−c0dans le tableau du simplexe de P0(phase I) et on lui
applique les opérations élémentaire comme avec les autres lignes. À la fin de la phase I, on supprime les colonnes des
wiet la ligne de la fonction W . Finalement, on utilise ce tableau pour résoudre le problème initiale P.
Example 4.3
Soit le programme linéaire P:
min 6 x1+3x2
s.t. x1+x2≥1,
2x1−x2≥1,
3x2≤2,
x1,x2≥0sous forme standard (max)= = = = = = = = = = = = = = = = = = ⇒max Z= −6x1−3x2
s.t. x1+x2−e1=1,
2x1−x2−e2=1,
3x2+e3=2,
x1,x2,e1,e2,e3≥0
La matrice Aest :
A=x1 x2 e1 e2 e3

1 1 −1 0 0
2−1 0 −1 0
0 3 0 0 1
est par suite Pn’est pas sous forme simpliciale (il n’ ya pas de sous matrice I3). Donc on peut ajouter 2
variables artificielles pour construire le problème initiale P0:
max −w1−w2=3x1−e1−e2−2
s.t. x1+x2−e1+w1=1,
2x1−x2−e2+w2=1,
3x2+e3=2,
x1,x2,e1,e2,e3,w1,w2≥0dont le vecteur X=

0 x1
0 x2
0 e1
0 e2
2 e3
1 w1
1 w2est une solution de base réalisable.
Ainsi, on commence notre algorithme 10 pour le programme P0. Le tableau initial est :
x1 x2 e1 e2 e3 w1 w2 b

w1 1 1 −1 0 0 1 0 1
w2 2−1 0 −1 0 0 1 1
e3 0 3 0 0 1 0 0 2
W: 3 0 −1−1 0 0 0 2
Z:−6−3 0 0 0 0 0 0
Le pivot c’est a2,1donc x1est la variable entrante et w2est sortante. On obtient après pivotement le tableau :
L2←1
2L2− − − − − − − − →
L1←L1−L2
L4←L4−3L2
L5←L5+6L2x1 x2 e1 e2 e3 w1 w2 b

w1 03
2−11
20 1−1
21
2
x1 1−1
20−1
20 01
21
2
e3 0 3 0 0 1 0 0 2
W: 03
2−11
20 0−3
21
2
Z: 0 −6 0 −3 0 0 3 3
Le pivot est a1,2(Min ratio test =1
3). On obtient alors :32 Chapitre 4. Programmation linéaire
L1←2
3L1− − − − − − − − →
L2←L2+1
2L1
L3←L3−3L1
L4←L4−3
2L1
L5←L5+6L1x1 x2 e1 e2 e3 w1 w2 b


x2 0 1−2
31
302
3−1
31
3
x1 1 0−1
3−1
301
31
32
3
e3 0 0 2 −1 1 −2 1 1
W: 0 0 0 0 0 −1−1 0
Z: 0 0 −4−1 0 4 1 5
Ainsi, la phase I se termine avec W=0 et x1=2
3,x2=1
3,e3=1 et e1=e2=w1=w2=0. Le tableau pour la
phase II est donc :
x1 x2 e1 e2 e3 b


x2 0 1−2
31
301
3
x1 1 0−1
3−1
302
3
e3 0 0 2 −1 1 1
Z: 0 0 −4−1 0 5
On remarque donc que les cj≤0, donc (STOP) la solution est optimale et le max est −5. Ainsi la solution
optimale pour le programme P=min6 x1+3x2est−(−5)=5=6×2
3+3×1
3.
4.2 Dualité
SoitPun P .L. sous forme canonique. Le programme dualDdePest définit par :
P=max z=cTX
s.t. AX ≤ b
X≥ 0le dual est= = = = = = = ⇒D=min w=bTY
s.t. ATY≥ c
Y≥ 0
Le programme Pest dit primal . On remarque que si Ade type m×n, alors X∈RnetY∈Rmpour le dual.
Théorème 4.1 Théorème de dualité
Si un problème primal ou dual admet une solution, alors l’autre problème admet aussi une solution et on a :
max z=cTX =
s.t. AX ≤ b
X≥ 0min w=bTY
s.t. ATY≥ c
Y≥ 0
Exercice 4.3
Soit le problème suivant de type régime :
D=min w=340x1+2400 x2+560x3
s.t. x1+2x2+x3≥ 1200
x1+3x2+2x3≥ 1400
x1+x2+3x3≥ 1500
x1,x2,x3≥ 0
Écrire le programme primal PdeD. Résoudre le programme Pet déduire la valeur minimale de w, a-t-on
besoin de faire les deux phases du simplexe ?
7} A B oS



HOUSSEM SABRI
Graphes et Optimisation
2`emeannée
LISI  LSI
Institut Supérieur des Sciences Appliquées et de Technologie de Sousse
A.U. 2023-2024
28 novembre 2023Table des matières
1 Les graphes 3
1.1 Définitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.1 Graphes non orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.2 Graphes orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.2 Opérations et quelques types de graphes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.3 Représentation d’un graphe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.1 Listes d’adjacences (ou de succession) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.2 Matrices d’adjacence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.3.3 Matrice d’incidence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2 La connexité 11
2.1 Les chaînes et les cycles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.2 Graphe connexe, eulérien, hamiltonien . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.3 Arbres . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.3.1 Codage et décodage d’un arbre – Prüfer code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.3.2 Arbre couvrant de poids minimum – ACM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3 Les algorithmes de base 20
3.1 Parcours en profondeur (DFS) / largeur (BFS) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
3.2 Recherche des chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.1 Matrice d’adjacence et nombre de chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.2 Plus court chemin et l’algorithme de Dijkstra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
3.3 Problèmes d’ordonnancement et chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
3.3.1 Algorithmes de tri topologique et de chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . 25
4 Programmation linéaire 27
4.1 La méthode simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.1 Solution de base admissible . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux . . . . . . . . . . . . . . . . . . . . . . . . 29
4.1.3 Initialisation - Phase I du simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
4.2 Dualité . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
2CHAPITRE 1
Les graphes
L ’exemple classique pour introduire la théorie des graphes est le problème des ponts de Königsberg, étudié par
Euler en 1736. Quel itinéraire doit-on suivre pour traverser chaque pont exactement une fois? Une telle prome-
nade n’existe pas, et c’est Euler qui donna la solution de ce problème en caractérisant les graphes que l’on appelle
aujourd’hui eulériens .
A
B
Ce1 e2
e3 e4
De5
e6e7
FIGURE 1.1 – Les ponts de Königsberg
Les graphes introduisent une simplification : les régions se transforment en des "points" (aussi appelés noeuds
ousommet ), les ponts se transforment en des lignes (aussi appelées arêtes ouarcs ), et ce principe s’applique dès
lors qu’une relation existe entre des objets. Les graphes relèvent de la combinatoire plutôt que de la géométrie (les
intersections, les longueurs, et la forme des arêtes n’ont aucune importance, sauf en ce qui concerne la lisibilité de
la représentation).
1.1 Définitions
Dans la suite, il est toujours supposé que les graphes sont finis, sauf indication contraire.
1.1.1 Graphes non orientés
Définition 1.1: Graphe
Un graphe Gest un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V{2}des pairs non ordon-
nées de V.Vest l’ensemble des noeuds (Vertices en anglais) et Ec’est l’ensemble des arêtes de G(Edges en
anglais). Lorsque e={x,y} est une arête, on dit que x, y sont les extrémités de cette arête, que eest incidente
enxet en y. On joint x et y par un trait et on dit que x, y sont adjacents (ou voisins). On note aussi e=x you
encore e=(x,y) (attention , dans ce cas : ( x,y)=(y,x)).
SiGest un graphe alors, on note par V(G) l’ensemble de noeuds et par E(G) l’ensemble des arcs.
Remarque 1.
— Une arête e ={x,x}s’appelle boucle .
— Dans un graphe, il peut exister des arêtes parallèles (on parle donc de multigraphe ).
Dans l’exemple des ponts on a : e 1=e2=(A,B).
34 Chapitre 1. Les graphes
— Un graphe est dit simple s’il ne comporte ni arêtes multiples ni de boucles, c’est-à-dire chaque paire de nœuds
distincts est reliée par au plus une arête, ou encore E (G)⊆P2(G).
Dans la plupart des cas, les graphes sont considérés comme simples par défaut.
Définition 1.2: ordre – taille – degré
Soit G=(V,E) un graphe.
1. On appelle ordre d’un graphe noté v(G) le nombre de ses sommets :
v(G)= |V|
2. On appelle taille d’un graphe noté e(G) le nombre de ses arêtes :
e(G)= |E|
3. Le degré (ou valence) d’un sommet xnoté d(x) est le nombre d’arêtes contenant x. (Attention! Une
boucle sur un sommet compte double).
Si on note par Γ(x) l’ensemble des voisins de x, i.e.
Γ(x)={y∈V:x y∈E}
alors, siGest simple , on a :
d(x)= |Γ(x)|
Example 1.1 (Graphe complet)
Un graphe d’ordre nest dit complet noté Knsi chaque sommet du graphe est relié directement à tous les
autres sommets, i.e. E(Kn)=P2(V(Kn)).
Représenter graphiquement K3,K4,k5. Calculer la taille de K3,k4,...Kn.
Example 1.2 (Graphe biparti)
Un graphe G=(V,E) est dit biparti si son ensemble de sommets V=V1˙∪V2, i.e. peut être divisé en deux
sous-ensembles disjoints V1etV2tels que chaque arête ait une extrémité dans V1et l’autre dans V2.
Si∀x∈V1,∀y∈V2;x y∈E, alors Gest dit biparti complet noté Kn,moùn= |V1|etm= |V2|.
a1
 a2
 a3
 a4
b1
 b2
 b3
FIGURE 1.2 – Un graphe biparti
Théorème 1.1 Lemme des poignées de main – Handshaking lemma
Soit Gun graphe alors, on a :X
x∈V(G)d(x)=2e(G)
Dans ce théorème d(x) est le nombre de personnes à qui xserre la main et e(G) le nombre total de poignées
de mains.H. SABRI 5
Preuve.
•Méthode simple Il y en a d(x) arêtes en un sommet xfixé. Pour tout les sommets cela fait doncP
x∈V(G)d(x).
Mais avec cette manière chaque arête est comptée deux fois, une fois à chacune de ses extrémités, d’où le
résultat en divisant par 2.
•Preuve par double dénombrement On pose
Z={(x,e)∈V×E:x∈e}⊆V×E
et les deux projections :
p:Z→V
(x,e)7→xet q:Z→E
(x,e)7→e
L ’idée est de calculer |Z|de deux manières différentes. D’abord, on rappelle que si f:A→Best une fonction
quelconque, alors :X
b∈B|f−1[b]| = | A|
oùf−1[b] désigne l’image réciproque de { b} par f(pourquoi ˙S
b∈Bf−1[b] est une union disjointe ?).
Ainsi on obtient :
|Z| =X
x∈V|p−1[x]| =X
e∈E|q−1[e]|
Or,|p−1[x]| =d(x) et|q−1[e]| = |{x∈V:x∈e}| =2. Donc :
X
x∈Vd(x)=X
e∈E2=2|E|
Remarque 2.
— Un sommet de degré 0est appelé sommet isolé .
— Un graphe tel que : ∀x∈V,d(x)=kest dit graphe k-régulier .
— Le graphe complet K nest un graphe (n−1)-régulier .
Exercice 1.1
Montrer que dans un graphe le nombre de sommets d’ordre impairs est toujours pair. En particulier un
graphe k-régulier avec kimpaire est un graphe d’ordre pair.
Voici quelques exemples comme application :
1. Est-il possible de relier 15 ordinateurs en réseau de sorte que chacun soit relié à exactement 3 autres ?
2. Une ligue de football comprenant 11 clubs organise un tournoi. Pour gagner du temps on décide que chaque
équipe ne jouera que la moitié des matches possibles. Comment organiser le tournoi ?
Proposition 1.1
Soit G=(V,E) un graphe (simple) d’ordre n≥2. Alors :
∃u,v∈V,u̸=v:d(u)=d(v)
Preuve. Supposons le contraire, c’est-à-dire ∀u,v∈V;d(u)̸=d(v). Or dans un graphe (simple) on a toujours d(x)∈
{0,1,..., n−1}. Dans ce cas, puisque tous les nsommets ont des degrés distincts, alors il existe une bijection
{d(x):x∈V}←→ {0,1,..., n−1}
Donc, il existe un sommet uavec un degré 0, et un sommet vavec degré n−1, donc vest connecté à tous les autres
sommets du graphe, ce qui signifie que une peut pas être un sommet isolé, d’où une contradiction.6 Chapitre 1. Les graphes
1.1.2 Graphes orientés
Les arêtes d’un graphe peuvent être orientées, auquel cas une flèche indique la direction. De tels graphes sont
appelés des graphes orientés ou des digraphes , et une arête ( a,b) dans un tel graphe indique que cette arête est
dirigée de sommet avers b, i.e. ( a,b)=− →ab̸=(b,a)=− →ba. D’où la définition :
Définition 1.3: Graphe orienté - digraphe
Un graphe orienté G(ou− →G) est un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V2des pairs
ordonnées de V.Eest l’ensemble des arêtes (ou flèches, arcs) de G. Lorsque e=(x,y) est une arête, on dit
que xestl’origine (ou sommet initiale) et yl’extrémité (ou sommet terminale) de e, que eest sortant en x
et incident en y, et que yest un successeur de xtandis que xest un prédécesseur de y. On note l’arête e
par :
e=(x,y)=− →x y=x→y
De la même façon, une arête x→xest une boucle. On peut toujours supprimer les boucles pour obtenir des
digraphes simples. Voici l’exemple d’un digraphe G=(V,E) d’une fonction f:E→Eoù ( x,y) est un arc si et seule-
ment si y=f(x). On l’appelle digraphe fonctionnelle.
0
3
1214
11 568
169
4
2 1
713 10
15
FIGURE 1.3 – Le digraphe fonctionnelle Gfdex7→(x2+3) mod 17.
Comme dans les graphes on peut définir les degrés (entrant, sortant) d’un sommet dans un digraphe.
Définition 1.4: indegree - outdegree
Soit G=(V,E) un digraphe. Pour v∈V, on note par :
d+(v) le degré extérieur (sortant - outdegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité initiale.
d+(v)= |{v→ •}|
d−(v) le degré intérieur (entrant - indegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité finale.
d−(v)= |{• → v}|
On définit le degré : d(v)=d−(v)+d+(v).
Un sommet de degré entrant non nul et de degré sortant nul est appelé puits , tandis qu’un sommet de
degré entrant nul et de degré sortant non nul est appelé source ouracine .
Dans un graphe orienté, les voisins d’un sommet vsont soit des successeurs ou des prédécesseurs. On les notes
par :
Γ+(x)=Succ (x)={y∈V:x→y∈E} et Γ−(x)=Pr ed (x)={y∈V:y→x∈E}H. SABRI 7
Si le digraphe est simple (ni boucle ni arcs parallèles) on a :
d−(v)= |Γ−(v)|et d+(v)= |Γ+(v)|
Proposition 1.2
Soit Gun digraphe, alors :X
v∈Vd−(v)=X
v∈Vd+(v)= |E|
Preuve. On a
E=˙[
v∈V{• → v}=˙[
v∈V{v→ •}
=⇒ | E| =X
v∈V|{• → v}| =X
v∈V|{v→ •}| =⇒ | E| =X
v∈Vd−(v)=X
v∈Vd+(v)
1.2 Opérations et quelques types de graphes
Une opération sur les graphes permet de construire un nouveau graphe comme résultat de l’opération. Les
opérations courantes sur les graphes sont la suppression, la valuation, l’union, l’intersection et le produit cartésien.
Graphe valué
Tout d’abord, on peut vouloir attribuer des valeurs aux arcs ou arêtes pour tenir compte de contraintes : dis-
tance, coût ...
Définition 1.5: (di)graphe valué
Un (di)graphe valué G=(V,E,w) est un (di)graphe muni d’une application w:E→R. L ’application west
appelée application poids ou coût. On indique sur chaque arête son poids (ou son coût). On note w(x,y)
au lieu de w((x,y)). On convient (même que ceci n’a pas de sens!) que w(x,y)= +∞ si (x,y)∉E.
ab
c
d
ef53
43
3
335
81
FIGURE 1.4 – Un digraphe valué
/pythonPython code : -
Implémenter le digraphe valué précédent avec python. Indice – use chatGPT : how to build a weighted digraph with
python8 Chapitre 1. Les graphes
Sous graphes
Soit G=(V,E) un graphe (orienté ou non). Un sous graphe de Gest un graphe de la forme G′=(V′,E′) où
V′⊆V,E′⊆Etels que toute arête de E′a ses extrémités dans V′(ou encore G′est aussi un graphe). On a :
•Sous-graphe induit Un sous-graphe G′=(V′,E′) de G=(V,E) est appelé un sous-graphe induit deGsi :
∀x,y∈V′; (x,y)∈E′⇐⇒ (x,y)∈E
En d’autres termes, deux sommets de G′qui sont connectés dans G, sont également connectés dans G′.
•Sous-graphe couvrant Un sous-graphe couvrant G′deGcontient tous les sommets de G, i.e. V′=V.
•G−vSupprimer un sommet vd’un graphe Gconsiste à supprimer vet toutes ses arêtes incidentes. Le sous-
graphe obtenu de cette opération est noté G−v, i.e.
V′=V−{v} et E′=E−{(v,y): (v,y)∈E}
De manière similaire, une arête epeut être supprimée (resp. ajoutée) d’un graphe G, et le sous-graphe
résultant est représenté par G−e(resp. G+e). Notez que la suppression d’une arête ne retire pas de sommets
du graphe.
•G−V′=G[V′] On supprimer tous les sommets v∈V′du graphe Gavec les arêtes incidentes. Le sous-graphe
obtenu de cette opération est noté G[V′], i.e.
V(G[V′])=V−V′et E(G[V′])=E−{(v,y)∈E:v∈V′}
•Clique Une clique Cd’un graphe Gest un sous-ensemble des sommets de Gdont le sous-graphe induit G′=
(C,E′) est un graphe complet, en d’autres termes, deux sommets quelconques de la clique Csont toujours
adjacents.
•Stable Un stable – appelé aussi ensemble indépendant (independent set en anglais) est un ensemble de som-
mets deux à deux non adjacents. Donc le sous-graphe induit est sans arcs.
FIGURE 1.5 – L ’ensemble des sommets en bleu dans ce graphe est un stable maximal du graphe.
Note : -
Le problème décisionnel de la clique (c’est à dire existe t-il une clique de taille k) est NP-complet . De même la
recherche d’un stable de taille maximum dans un graphe est un problème NP-complet et difficile à approximer.
Exercice 1.2
Trouver un plus grand stable et une plus grande clique du graphe suivant :
8
4
62 7
3
1 5
Indice : vérifier le résultat avec networkx.find_cliques(G) et.maximum_independent_set(G) de python.H. SABRI 9
Opérations binaires
Union L ’union de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∪H=(VF,EF) dans lequel
VF=VG∪VH et EF=EG∪EH
Intersection L ’intersection de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∩H=(VF,EF)
dans lequel
VF=VG∩VH et EF=EG∩EH
1.3 Représentation d’un graphe
Il est important de savoir comment représenter les graphes au sein d’un ordinateur. Il ya plusieurs méthodes
selon la nature des traitements que l’on souhaite appliquer au graphe considéré.
1.3.1 Listes d’adjacences (ou de succession)
Soit Gun (di)graphe. On suppose que les sommets de Gsont numérotés de S1àSn. La représentation par listes
d’adjacence de Gconsiste en un tableau (ou des listes chainées) tel que la ligne i=1... ncorrespond au sommet Si
et comporte la liste des voisins/successeurs (ou des prédécesseurs) de ce sommet notée T[Si]. Les sommets dans
chaque liste d’adjacence sont généralement listés selon un ordre arbitraire.
1
2
345
FIGURE 1.6 – Un digraphe
La liste d’adjacence de digraphe 1.6 est donc :
1 2 3 4 5
2 3
3 4
4−
5 1 410 Chapitre 1. Les graphes
1.3.2 Matrices d’adjacence
Définition 1.6: Mat. Adjacence
Soit G=(V,E) un graphe (orienté) d’ordre n. On peut numéroter V={1,2,..., n}.La matrice d’adjacence
deGest la matrice carrée A=(ai j) d’ordre n, définie par :
ai j=(
1 si ( i j)∈E;
0 sinon.
Remarque 3.
1. Si le graphe G est non orienté et simple, alors la matrice A est symétrique avec des 0sur la diagonale. Pour un
digraphe simple, on a toujours des 0sur la diagonale, mais la matrice n’est pas symétrique en général.
2. Pour les multigraphes, il peut y avoir des termes diagonaux (pour les boucles) et s’il y a plusieurs arêtes de i à
j , le coefficient de la matrice a i jest le nombre d’arêtes de i à j .
3. Pour un (di)graphe valué G =(V,E,w), on pose :
ai j=(
w(i,j)si(i j)∈E ;
∞ sinon.
La matrice d’adjacence de la figure 1.4 est :

∞ 5∞ 4 3 ∞
∞ ∞ 3∞ 1∞
∞ ∞ ∞ ∞ ∞ 5
∞ ∞ 3∞ 3 3
∞ ∞ ∞ ∞ ∞ 8
∞ ∞ ∞ ∞ ∞ ∞

1.3.3 Matrice d’incidence
Définition 1.7: Mat. Incidence
Soit G=(V,E) un graphe (simple) d’ordre net de taille m. On pose V={v1,v2,..., vn} etE={e1,e2,..., em}.
La matrice d’incidence deGest la matrice de type n×m B=(bi j), définie par :
•Si G orienté
bi j=

1 si ej=vi→ • (i.e. viest l’extrémité initiale de ej) ;
−1 si ej= • → vi(i.e. viest l’extrémité terminale de ej) ;
0 sinon.
•Si G non-orienté
bi j=(
1 si viest une extrémité de ej;
0 sinon.
Exercice 1.3
1. Donner la matrice d’incidence du graphe 1.6.
2. Montrer le théorème 1.1 avec la matrice d’incidence.CHAPITRE 2
La connexité
Il est important de savoir si on peut suivre un chemin d’un sommet donné à un autre dans un graphe donné.
Cette propriété (de connexité) doit être maintenue dans différents types de réseaux.
2.1 Les chaînes et les cycles
Définition 2.1: (chaine – cycle) (chemin – circuit)
•Graphe non orienté
1. Une chaîne (walk ) reliant xày, notée µ(x,y), est définie par une suite finie d’arêtes consécutives,
reliant xày, ou encore une séquence de sommets (puisque non multigraphe)
µ(x,y)=<v0,v1,..., vk>
tels que v0=x,vk=yet (vi−1,vi)∈E(G) pour tout i=1... k. Six=yla chaîne est dite fermée .
Lalongueur du chaîne l(µ(x,y)) est le nombre d’arcs dans la chaîne, c’est-à-dire k.
2. Une chaîne élémentaire (a path ) si tous les sommets sont distincts. Une chaîne simple (a simple
walk, a trail ) est une chaîne ne passant pas deux fois par une même arête, c’est-à-dire dont toutes
les arêtes sont distinctes. Remarquer que : élémentaire =⇒ simple.
3. Un cycle v0v1...vnde longueur n≥3 est une chaîne simple fermée ( v0=vn) tel que les sommets
v0,v1,..., vn−1sont tous distincts. Un graphe sans cycle est dit acyclique .
•Graphe orienté
Dans un graphe orienté, on parlera de chemin au lieu de chaîne, et de circuit au lieu de cycle.
Example 2.1
abxcd xa est une chaîne simple et fermée (non cycle!) de longueur 6 (mais, c’est un graphe eulérien - voir
plus loin). Y a-t-il un cycle de longueur 3,4 ?
a b
x
c dÏ
Remarque 4.
1. On peut pivoter une chaine fermée (l’orienter de manière arbitraire) , i.e.
<v0,v1,v2,..., v0>=< vk,vk+1,..., v0,v1,..., vk>
1112 Chapitre 2. La connexité
2. Soient x ,y∈V . La distance de x à y est définie par :
d(x,y)=(
k si le plus court chemin/chaîne de x vers y est de longueur k
∞ sinon
On convient que d (x,x)=0.
3. Le diamètre du graphe la plus grande distance entre deux sommets.
L ’observation suivante, bien que très facile à prouver, sera utile.
Théorème 2.1
S’il existe une chaîne du sommet yau sommet zdans le graphe G, où y̸=z, alors il existe une chaîne élé-
mentaire ( path ) dans Gavec pour premier sommet yet pour dernier sommet z.
Preuve. Soit la chaine
W1=µ(y,z)=x0x1...xn; avec x0=yetxn=z.
Si les sommets x0,x1,..., xnsont tous distincts, alors W1est une chaîne élémentaire, et nous avons terminé. Sinon,
il existe xi=xj(i<j) et on écrit :
W2=x0x1...xixj+1...xn.
Alors, l(W2)<l(W1). Si W2ne contient aucun sommet répété, alors c’est la chaîne recherché. Sinon, par la même
procédure, il existe W3(y z−chaîne) tel que
l(W3)<l(W2)<l(W1).
Ce processus doit s’arrêter à un certain stade, car chaque chaîne est plus courte que la précédente et la longueur
ne peut jamais être inférieure à 1
1< ··· < l(Wk)< ··· < l(W3)<l(W2)<l(W1).
Ainsi, pour un certain k,Wkne peut pas être réduit en longueur. Donc, la chaîne Wkne contient aucun sommet
répété et est donc une y z−chaîne élémentaire (path).
Exercice 2.1
Dans le graphe suivant, construire un path à partir de la chaîne W=v2v3v4v5v6v4v2v8v1
v1
 v2
v3
v4
v5
v6
v7
 v8
 v9
Calculer d(v1,v7) et le diamètre de G.
/pythonpython : >>G = nx.Graph([(1, 2), (2, 3), (2, 4), ...]) >>nx.diameter(G)
Les cycles fournissent la caractérisation suivante pour les graphes bipartis .H. SABRI 13
Théorème 2.2
Un graphe est biparti si et seulement s’il ne contient aucun cycle de longueur impaire.
Preuve.
⇒On suppose que G=U˙∪Vest un graphe biparti. Soit W=< x1,x2,..., x2k+1,x1>un cycle de longueur im-
paire (2 k+1). Si x1∈U, alors
x1∈U=⇒ x2∈V=⇒ x3∈U=⇒ ··· =⇒ x2k+1∈U=⇒ x1∈V/exclamati⌢n-triangle
absurde, d’où le résultat.
⇐On suppose que Gest connexe (car l’union des composantes connexes bipartis est un graphe biparti). Soit
xun sommet de Get on pose :
U={y∈V(G):d(x,y) est paire} et V={z∈V(G):d(x,z) est impaire}
S’il existe y1,y2∈Utel que y1y2∈E(G), alors on a :
W1=<x,..., y1>est une chaîne de longueur paire =2k1
W2=<x,..., y2>est une chaîne de longueur paire =2k2
=⇒ W3=<x,..., y1,y2,..., x>est un cycle de longueur impaire =2k1+2k2+1/exclamati⌢n-triangle
Donc G=U˙∪Vest un graphe biparti.
Exercice 2.2
Vérifier si le graphe maison est un graphe biparti. Faire de même pour la grille G4,4.
maison grille
2.2 Graphe connexe, eulérien, hamiltonien
Définition 2.2: Graphe connexe
Un graphe est dit connexe si deux points peuvent toujours être joints par une chaîne, i.e.
∀x,y∈V(G),d(x,y)< ∞
— Une composante connexe d’un graphe est un sous-graphe induit maximal connexe.
— Un point d’articulation d’un graphe est un sommet dont la suppression augmente le nombre de
composantes connexes.
Par exemple, le graphe suivant :14 Chapitre 2. La connexité
a
 b
d
 c
e
f
 g
n’est pas connexe car il n’existe pas de chaîne entre les sommets aete. On a donc 2 composantes connexes. En
revanche, le sous-graphe induit par les sommets { a,b,c,d} est connexe dont aest le seul point d’articulation.
Remarque 5.
1. Un graphe connexe à n sommets possède au moins n −1arêtes ( faite une preuve par récurrence ).
2. L’algorithme de parcours en profondeur permet de déterminer si un graphe est connexe ou non.
3. Même définitions dans un graphe orienté . Graphe orienté (fortement) connexe et de composante connexe .
Définition 2.3: Graphe eulérien
— Une chaîne joignant deux sommets xetyest dite chaîne eulérienne si elle emprunte chaque arête
deGune et une seule fois. On parle de chemin eulérien dans le cas d’un graphe orienté.
— Un cycle eulérien est une chaîne eulérienne dont les extrémités coïncident. Un graphe qui admet
un cycle (resp. circuit) eulérien est dit graphe eulérien .
/flushedRemarquer qu’un cycle eulérien n’est pas forcément un cycle comme définit dans la définition 2.1
Si un graphe (ou multigraphe) Gpossède une chaîne eulérienne, alors soit Gpossède deux sommets impairs, le
début et la fin de cette chaîne, soit Gn’a aucun sommet impair, et la promenade d’Euler commence et se termine
au même point (cycle eulérien). Une autre condition nécessaire évidente est que Gdoit être connexe. Ces deux
conditions sont ensemble suffisantes.
Théorème 2.3 Euler
Soit Gun graphe (multigraphe) connexe.
— Si Gn’a pas de sommets impairs, alors il possède un cycle eulérien (commençant à n’importe quel
point).
i.e.∀x,d(x)≡0 mod 2 =⇒ Gest un graphe eulérien.
— Si Ga deux sommets impairs, alors il possède une chaîne eulérienne dont le début et la fin sont les
sommets impairs.
La réciproque est aussi vraie.
Preuve.
⇐On commence par la réciproque. S’il existe une chaîne eulérienne µ(x,y), alors on peut crée une arête fictive
e=(y,x) et par la suite on obtient un cycle eulérien. Donc il suffit de montrer que si Gadmet un cycle
eulérien alors tous les sommets sont de degré pair.
Soit W=< v1,v2,..., vn,v1>un cycle eulérien. Soit le sommet vjavec j̸=1, il est donc claire que chaque
fois vjapparaît dans W, il ya deux arcs distincts incidents en vj( (•,vj) et ( vj,•)). Comme toutes les arêtes
sont utilisées, on voit que d(vj) est pair. Même chose pour v1car on ajoute deux arcs ( v1,v2) et ( v1,vn).
⇒On suppose que tous les sommets sont de degré pair. Montrons que Gadmet un cycle eulérien. Puisque
tous les sommets sont de degré pair on peut construire d’abord une chaîne simple fermée (quelconque)
W1=<v1,v2,..., vk,v1>
SiW1contient chaque arête de G, alors c’est finis, c’est un cycle eulérien. Sinon (puisque Gest connexe), il
existe une arête e=(vi,c) qui n’est pas dans W1(avec visommet de W1). On pose le sous-graphe
G′=G−{ arêtes de W1}H. SABRI 15
Il est donc claire que les sommets de G′sont aussi de degré pair. Alors, par la même procédure on construit
une chaîne simple fermée dans G′de la forme : <vi,c,d,..., vi>et par la suite on insère cette chaîne dans
W1pour obtenir :
W2=<v1,v2,..., vi,c,d,..., vi,vi+1,..., vk,v1>
Sil(W2)< |E(G)|, on construit W3de longueur plus grand. Ainsi, on a :
l(W1)<l(W2)<l(W3)< ··· ≤ | E(G)|
Donc, nécessairement, il existe Wk(chaîne simple fermée de longueur |E(G)|) donc c’est un cycle eulérien.
Finalement , si∃a,b∈V(G):d(a)≡d(b)≡1 mod 2, et tous les autres sommets sont de degré pair, alors on
pose :
G′=G+{a,b}
et donc tous les sommets de G′sont de degré pair. Avec la construction précédente, il existe un cycle eulérien
dans G′:
W=<a,b,v1,..., a>
est donc la chaîne <b,v2,..., a>est une chaîne eulérienne dans G.
Algorithme 1 : Euler
Entrées : Gun graphe eulérien
Output : Un cycle eulérien W
/* On suppose que G est eulérien, i.e. les sommets sont de degré pair */
1Gaux←G;W←µ(v,v) une chaîne simple (quelconque) de G; // Initialisation
2tant que l(W)<e(G)faire
3 Gaux←G−{ arêtes de W} ;
4 Choisir ( x,c)∈E(Gaux) tel que x∈W;
5 L←< x,c,..., x>une chaîne simple de Gaux ;
6 Dans W, remplacer (juste ce) xpar la séquence L;
7fin
8retourner W;
Exercice 2.3
1. Montrer que le graphe de l’exercice 2.1 est un graphe eulérien et donner un cycle eulérien.
2. Tracer cette maison d’un seul trait.
Remarque 6. Le théorème d’Euler dans un graphe orienté connexe s’écrit :
Admet un circuit eulérien si, et seulement si, pour tout sommet, le degré entrant est égal au degré sortant.
∀v∈V(G),d+(v)=d−(v)
Admet un chemin eulérien de a vers b si, et seulement si,


d+(v)=d−(v) ;∀v̸=a,b,
d−(a)=d+(a)−1
d−(b)=d+(b)+116 Chapitre 2. La connexité
Définition 2.4: Graphe hamiltonien
Soit Gun graphe connexe d’ordre n. On appelle :
1. On appelle cycle hamiltonien deGun cycle passant (une et une seule fois) par chacun des sommets
deG. Un graphe est dit hamiltonien s’il possède un cycle hamiltonien.
2. Une chaîne hamiltonienne est une chaîne passant une et une seule fois par chacun des sommets de
G. Un graphe ne possédant que des chaînes hamiltoniennes est semi-hamiltonien .
3. Dans un digraphe, on change cycle par circuit et chaîne par chemin .
Remarque 7.
— Une chaîne hamiltonienne est une chaîne élémentaire de longueur n −1.
— Un graphe peut être eulérien, hamiltonien, les deux à la fois, ou aucun des deux.
— De nombreux problèmes concrets peuvent être formulés en termes de recherche de parcours hamiltoniens : pro-
blème du voyageur de commerce (chercher un cycle hamiltonien de longueur totale minimale), l’ ordonancement
de tâches .
— Le problème du chaîne hamiltonienne est un problème NP-complet .
Exercice 2.4
Donner un graphe (connexe, simple) qui soit :
1. hamiltonien et eulérien.
2. hamiltonien et non eulérien.
3. eulérien et non hamiltonien.
4. non hamiltonien et non eulérien.
Aucune condition nécessaire et suffisante adéquate n’est connue pour l’existence de cycles hamiltoniens. Le
résultat suivant constitue une condition suffisante utile.
Théorème 2.4 Ore
Soit Gun graphe simple d’ordre n≥3. Si pour toute paire { x,y} de sommets non adjacents, on a d(x)+d(y)≥
n, alors Gest hamiltonien.
Preuve. On suppose que le théorème est faux. Alors, il existe un graphe Gsimple d’ordre nnon hamiltonien tel que
d(u)+d(v)≥npour tout sommets non adjacents uetv. On prend Gun tel graphe d’ordre nde taille maximale qui
vérifie cette propriété (remarquer que le graphe complet Knest hamiltonien).
Soient uetvdeux sommets non adjacents de G. Par maximalité de G, le graphe G+uv(d’ordre n) doit être
hamiltonien. Donc il existe dans G+uvun cycle hamiltonien :
W=<u,x1,x2,..., xn−2,v,u>
u
x1
xi xi+1xn−2
v
... ...
Or, si uxi+1∈E(G) etv xi∈E(G) (les arcs en rouge), alors on peut construire dans Gle cycle hamiltonien :
<u,x1,x2,..., xi,v,xn−2,..., xi+1,u>H. SABRI 17
Ceci est absurde car Gest non hamiltonien. Donc si xi+1est un sommet voisin à u, alors le sommet xin’est pas
voisin de v:
xi+1∈Γ(u)=⇒ xi∉Γ(v)
Donc :
d(u)= |Γ(u)| =p=⇒ d(v)≤(n−1)−p
et par la suite
d(u)+d(v)≤n−1
ce qui absurde par hypothèse. Donc Gest hamiltonien.
Une conséquence immédiate est le théorème de Dirac :
Proposition 2.1 Dirac
Soit Gun graphe simple d’ordre n≥3. Si pour tout sommet xdeG, on a d(x)≥n
2, alors Gest hamiltonien.
2.3 Arbres
Définition 2.5: Arbres et forêts
On appelle arbre tout graphe (non orienté) connexe et acyclique . Les composantes connexes dans un
graphe acyclique sont des arbres et le graphe est dit forêt . Une feuille ou sommet pendant est un som-
met de degré 1.
Un forêt avec deux arbres
Un graphe Gest une arborescence s’il existe un sommet Rappelé racine deGtel que, pour tout sommet
SdeG, il existe un chemin et un seul de Rvers S. Donc, c’est un arbre orienté dans lequel on choisit un
sommet Rcomme racine et on dirige les arcs vers le sens sortant de la racine.
Remarque 8.
— Un graphe G d’ordre n est un arbre ssi G est sans cycle et possède n −1arêtes.
— Un graphe G d’ordre n est un arbre ssi G est connexe et possède n −1arêtes.
— G est un arbre si pour chaque paire u ,v de sommets distincts est reliée par une seule chaîne (donc chaîne
élémentaire d’après le théorème 2.1).
— Un arbre (ou forêt) est nécessairement un graphe simple.
Pour démontrer les remarques précédentes, il suffit de prouver le théorème suivant :
Théorème 2.5
Soit Gun graphe ayant marêtes, nsommets et pcomposantes connexes, on définit nu( G) :
ν(G)=m−n+p
Alors, on a :
1.ν(G)≥0.
2.ν(G)=0⇐⇒ Gest acyclique.18 Chapitre 2. La connexité
Preuve. Par récurrence sur la taille mdu graphe. Le résultat est évident pour m=0 et m=1. On suppose le résultat
est vrai pour les graphe de taille m, et montrons que ceci est vrai pour un graphe de taille m+1. Soit donc Gun
graphe d’ordre nde taille m+1 ayant pcomposantes connexes.
•On suppose que Gest un graphe acyclique. Soit uvune arête de Gdans la composante C. Si on supprime uv,
la composante Cse transforme en deux composantes connexes (sinon on a un cycle dans G). Par la suite,
le graphe G′=G−uvest un graphe acyclique d’ordre n, de taille met ayant p+1 composantes connexes.
Donc d’après l’hypothèse de récurrence :
ν(G′)=0=(m−1)−n+(p+1)=m−n+p=ν(G)
•Maintenant, si Gcontient un cycle Wdans la composante connexe C. Soit uvune arête de W, alors si on
supprime l’arête uv, la composante Creste connexe. Donc le graphe G′=G−uvest un graphe d’ordre nde
taille m−1 ayant pcomposantes connexes. Donc, d’après l’hypothèse de récurrence :
ν(G′)=(m−1)−n−p≥0
=⇒ν(G)=m−n−p≥1>0
D’où le résultat – car si ν(G)=0,Gne peut être que acyclique, sinon 0 =ν(G)≥1/exclamati⌢n-triangle
2.3.1 Codage et décodage d’un arbre – Prüfer code
Soit Tun arbre ayant nsommet numérotés {1,2,..., n}. Le codage de Prüfer représente l’arbre Tarbre de avec
une suite P=(x1,x2,x3,..., xn−2) de n−2 termes (les n° des sommets avec répétition possible). Une suite Pdonnée
correspond à un et un seul arbre numéroté. Voici les algorithmes de codage et de décodage.
Algorithme 2 : Codage de Prüfer
Entrées : Un arbre T
Output : Séquence de Prüfer P
1P←() ; // Initialisation de P comme séquence vide
2tant que v(T)>2faire
3 x←feuille de Tayant le n° minimum ; // donc d(x)=1
4 P←(P,s) où sest le seul (n°) sommet adjacent à x;
5 T←T−x;
6fin
7retourner P;
Example 2.2
Donner le code de Prüfer de l’arbre :
126 345
Indice : on trouve, P=(2,3,3,2)
Pour faire la réciproque, étant donnée une séquence P=(x1,x2,..., xn−2) où les xi∈{1,2,..., n}, on construit
l’arbre Tdont les sommets sont {1,2,..., n} avec l’algorithme suivant (le décodage) :H. SABRI 19
Algorithme 3 : Décodage de Prüfer
Entrées : Une séquence Pde taille n−2
Output : L ’arbre Tcorrespondante
1I←{1,2,..., n};
2T←graphe tel que V(T)=IetE(T)= ; ; // T graphe à n sommets isolés
3tant que P̸=()faire
4 i←min {x∈I:x∉P};
5 T←T+(i,P[1]) ; // ajouter l'arc (i,P[1])
6 P←P−P[1];I←I−{i};
7fin
8T←T+(a,b) ; // a,b sont les deux éléments restant dans I
9retourner T;
Example 2.3
Donner l’arbre dont le code de Prüfer est : P=(2,3,3,3)
Puisqu’il ya une bijection entre les arbres d’ordre net les suites Pde longueur n−2 à coefficients dans {1,2,..., n},
on déduit le théorème de Cayley :
Théorème 2.6 Formule de Cayley
Le nombre d’arbres que l’on peut construire sur n(n≥2) sommets numérotés est égal à nn−2.
2.3.2 Arbre couvrant de poids minimum – ACM
Soit Gun graphe (non orienté). Un arbre couvrant (spanning tree) TdeGest un sous graphe couvrant de G
tel que Test un arbre. Remarquer que, Gdoit être connexe, sinon un arbre couvrant de Gn’existe pas. Le nombre
des arbres couvrant de Gest noté a(G). Remarquer que a(Kn)=nn−2(le nombre de Cayley). Un problème algo-
rithmique classique est de trouver, dans un graphe valué , un arbre couvrant de poids minimal . On dispose de
plusieurs algorithmes (l’algorithme de Prim, l’algorithme de Kruskal ...).
Algorithme 4 : Kruskal
Entrées : Un graphe Gvalué d’ordre net de taille m
Output : Arbre (ou forêt) couvrant de poids minimum
1Numéroter les arêtes de Gpar poids minimum : w(e1)≤w(e2)≤ ··· ≤ w(em)
2T←graphe tel que V(T)=V(G) etE(T)= ; ; // T graphe à n sommets isolés
3k←0;
4tant que k<m et e (T)<n−1faire
5 siT+ek+1est acyclique alors
6 T←T+ek+1;
7 k←k+1;
8fin
9retourner T;
Appliquer l’algorithme de Kruskal dans le graphe suivant :
CHAPITRE 3
Les algorithmes de base
Beaucoup de problèmes sur les graphes nécessitent que l’on parcourt l’ensemble des sommets et des arcs. Par
exemple, pour vérifier que le graphe est connexe, chercher un sommet particulier, construire un arbre couvrant,
trouver un plus court chemin ...etc.
3.1 Parcours en profondeur (DFS) / largeur (BFS)
Une manière simple de tester si un graphe Gest connexe ou non est d’exécuter l’algorithme DFS ouBFS dans
Gen commençant par n’importe quel sommet et en enregistrant les sommets visités pendant l’exécution dans une
liste. Si la liste contient tous les sommets de G, alors Gest connexe. Une petite modification permet de donner les
composantes connexes de G. L ’algorithme DFS_Component suivant donne les composantes connexes de G. Il est
donné sous forme d’implémentation récursive.
Algorithme 5 : DFS_Component
Entrées : Un graphe G=(V,E)
Output : Les composantes connexes C=(C1,C2,..., Ck) de G.
1VisitedNodes ← ; ;
2k←0 ; // k est le nombre des composantes connexes
3pour chaque u∈Vfaire
4 siu∉VisitedNodes alors
5 k←k+1;
6 DFS( u);
7 fin
8fin
9retourner (C1,C2,..., Ck);
1Procedure DFS( u )
2 VisitedNodes ←VisitedNodes ∪{u};
3 Ck←Ck∪{u};
4 pour chaque x∈Γ(u)faire
5 six∉VisitedNodes alors
6 DFS( x);
7 fin
8 fin
Note : -
Il est possible de d’implémenter la procédure DFS itérativement à l’aide d’une pile LIFO (stack) contenant les
sommets à explorer : on désempile un sommet et on empile ses voisins non encore explorés.
20H. SABRI 21
Pseudocode :
stack . push ( root )
while stack . isEmpty ( ) = f a l s e do
node = stack . pop ( ) // so mark i t as v i s i t e d
for each x in node . childNodes do
i f x i s not v i s i t e d then
stack . push ( x )
. . .
endfor
endwhile
Example 3.1 (DFS )
Ici on empile (gris) les sommets les plus à droite, alors l’ordre des sommets visité (noir) est ( a,b,d,e,g,c,f).
Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b
 c
d
 e
f
g
a
b
 c
d e
f
ga
b
 c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g
L ’utilisation d’une file (FIFO) au lieu d’une pile transforme l’algorithme du parcours en profondeur en algo-
rithme de parcours en largeur ( BFS ). Avec BFS l’exemple précédent devient (en enfile le plus à gauche) :
Example 3.2 (BFS )
Ici, avec BFS, on enfile (gris) les sommets les plus à gauche d’abord, alors l’ordre des sommets visité (noir)
est ( a,b,d,e,g,c,f). Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b c
d
 e
f
g
a
b c
d
 e
f
ga
b c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g22 Chapitre 3. Les algorithmes de base
Exercice 3.1
1. Écrire la procédure BFS .
2. Utiliser DFS (ou BFS) pour la construction d’un arbre couvrant d’un graphe connexe. L ’appliquer
pour le graphe triangle.
3. Utiliser DFS pour écrire une procédure DFS_Cycle pour détecter un cycle dans un graphe.
On sait qu’un graphe orienté G=(V,E) est fortement connexe si pour chaque paire de sommets u,v∈V, il
existe un chemin de uàvet il existe un chemin de vàu. En d’autres termes, nous avons besoin d’une connectivité
dans les deux directions .
Une procédure pour tester si un graphe orienté est fortement connexe ou non peut être conçue avec l’idée
suivante. En partant d’un sommet arbitraire vdu graphe G, on exécute l’algorithme BFS ouDFS et l’on note les
sommets visités. Ensuite, on obtient la transposée de G,GT, en inversant la direction des arêtes de G, et l’on
exécute à nouveau l’algorithme BFS ou DFS à partir du sommet v. Si les sommets visités dans les deux cas sont
égaux à V, alors le graphe orienté est fortement connexe. Cette méthode est illustrée dans l’algorithme 6.
Algorithme 6 : Fortement_connexe
Entrées : Un graphe orienté G=(V,E)
Output : true siGest fortement connexe et false sinon
1X← ; ;
2Y← ; ;
3v←un sommet quelconque de V;
4X←DFS( G,v) ; // Enregistrez les sommets visités dans X
5GT←Gavec flèches inversées;
6Y←DFS( GT,v);
7siX=Y=Valors
8 retourner TRUE.
9sinon
10 retourner FALSE.
11fin
3.2 Recherche des chemins
3.2.1 Matrice d’adjacence et nombre de chemins
La puissance de la matrice d’adjacence Amontre qu’il y a des chemins (ou chaînes) de longueur kallant de xà
ycomme le montre le théorème suivant.
Théorème 3.1
Soit G=(V,E) un (di)graphe. On note V={1,2,..., n} et Asa matrice d’adjacence et Akla puissance k-ème
deA. Alors le terme d’indices i,jdeAkest le nombre de chemins (chaînes) de longueur kallant de iàj.
Preuve. Par récurrence sur k. Pour k=1 c’est clair. On suppose le résultat est vrai à l’ordre ket montrons qu’elle
est vrai pour k+1. Soit S=(si,j)=Ak. Si on a un chemin de iàjde longueur k+1, alors on va d’abord de ià un
sommet ravec kpas et puis de ràj. Or d’après l’hypothèse de récurrence on a si,rchemins possibles pour aller de
iàret finalement ar,jpas (1 ou 0) pour aller de ràj. Ainsi, le nombre totale possibles (i.e. tous les sommets r) est :
nX
r=1si,rar,j=³
Ak×A´
i,jH. SABRI 23
ce qui est bien le terme ( i,j) de la matrice Ak+1.
3.2.2 Plus court chemin et l’algorithme de Dijkstra
Dans cette partie on suppose que le (di)graphe G=(V,E,w) est valué positivement (i.e.∀e∈E,w(e)>0). Notre
objectif est de chercher un plus court chemin (i.e., un chemin de poids minimal ) d’un sommet ufixé à un sommet
quelconque de G.
Il est clair que l’on peut restreindre ce problème au cas d’un (di)graphe simple1. On suppose aussi que Gest
connexe (sinon, certains trajets sont impossibles). Il est aussi claire (d’après théorème 2.1), qu’un plus court chemin
est nécessairement un chemin élémentaire (path).
L ’algorithme de Dijkstra (1959) permet de calculer le plus court chemin entre un sommet particulier u(racine )
et tous les autres sommets. L ’algorithme fonctionne de la manière suivante :
Pour tout sommet vdeG, on associe une valeur T(v), initialisée à w(u,v) et une liste de sommets C(v) qui
correspond à un chemin de uàv. À la fin de l’algorithme, T(v) contient le poids minimal des chemins joignant uà
v(ou T(v)= ∞ siu↛v) et la liste C(v) réalise un tel chemin. Voici donc l’algorithme de Dijkstra :
Algorithme 7 : Algorithme de Dijkstra
Entrées : Un (di)graphe valué G=(V,E,w) et un sommet racine u
Output : Le coût minimum d’un chemin de uàv(∀v∈V) et un trajet pour chaque coût minimal obtenu
1∀v∈V,T(v)←w(u,v) etC(v)←(u,v); // Initialisation de T(v) et la liste C(v)
2X←{u};
3tant que X̸=Vfaire
4 Choisir v∈V−Xtel que ∀y∈V−X,T(v)≤T(y);
5 X←X∪{v};
6 pour chaque y∈V−Xfaire // Faire les mises à jours pour les autres sommets
7 siT(y)>T(v)+w(v,y)alors
8 T(y)←T(v)+w(v,y);
9 C(y)←[C(v),y]; // On ajoute à la liste C(v) l'élément y
10
11 fin
12 fin
13fin
Example 3.3
Voici une application de l’algorithme de Dijkstra au digraphe suivant. On prend Ecomme sommet racine.
EA
B
CD
FG
S5
4
21
12
2
34
4
215
7
1. En effet, passer par une boucle ne ferait qu’augmenter inutilement le poids de ce chemin. De même, si plusieurs arcs joignent deux
sommets, il suffit de conserver l’arc de poids minimal.24 Chapitre 3. Les algorithmes de base
Ainsi, pour l’initialisation, on a : X={E} et on a les valeurs :
v  E A B C D F G S
T(v) 0 5 4 2 ∞ ∞ ∞ ∞
C(v)(E,E) ( E,A) ( E,B) ( E,C) ( E,D) ( E,F) ( E,G) ( E,S)
Maintenant, on choisit (un seul choix) le sommet C, donc X={E,C}. Le tableau est mis à jour :
v  E A B  C D F G S
T(v) 0 5 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À l’étape suivante, on est forcé de choisir B. Ainsi, X={E,C,B} et la mise à jour est :
v  E A  B  C D F G S
T(v) 0 4 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À présent, on a le choix entre AetF. On choisit A. Donc X={E,C,B,A} et on a :
v  E  A  B  C D F G S
T(v) 0 4 3 2 6 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,B,A,D) ( E,C,F) ( E,C,G) ( E,S)
Puis, on prend le sommet F. D’où X={E,C,B,A,F} et :
v  E  A  B  C D  F G S
T(v) 0 4 3 2 5 4 5 11
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,S)
On prend Det on obtient X={E,C,B,A,F,D} et :
v  E  A  B  C  D  F G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Finalement, on prend Gpuis Set on voit que ceci ne change rien. D’où le tableau finale :
v  E  A  B  C  D  F  G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Ainsi le chemin minimum pour aller de EàSest de coût 10 et un trajet de coût minimal de EàSest : EC F DS .H. SABRI 25
3.3 Problèmes d’ordonnancement et chemin critique
Un problème d’ordonnancement peut-être représenté sous la forme d’un digraphe. Les sommets sont des évé-
nements (début et fin de la tâche) et les arcs des tâches, La longueur (ou poids) de chaque arc représente la durée
d’exécution de la tâche. Ainsi, la tâche correspondant à l’arc ( i,j) ne peut commencer que si toutes les tâches cor-
respondant à des arcs ( k,i) ont été complétées. On ajoute deux sommets pour le début (s) et de fin(t) du projet .
Le digraphe peut contenir des tâches fictives dedurée nulle afin de forcer certaines précédences (postériorité).
Ainsi, un réseau PERT est un digraphe valué G=(V,E,w,s,t) où la fonction poids (ou longueur) w:E→R+
etsle sommet source (début) et tle sommet puits (fin). Un chemin critique est un chemin de sàtdelongueur
maximale . S’il n’existe pas de chemin critique, le projet n’est pas réalisable (e.g. un circuit). Le temps minimal
requis pour l’exécution d’un projet réalisable est égal à la longueur d’un chemin critique. Les tâches figurant sur un
chemin critique sont aussi appelées critiques, ce qui s’explique par le fait que tout retard d’exécution d’une tâche
critique retarde d’autant l’exécution du projet.
3.3.1 Algorithmes de tri topologique et de chemin critique
Il faut d’abord numérotés les sommets de 1 à nde manière compatible au pré-ordre (rang) avec l’algorithme du
rang suivant (tri topologique) :
Algorithme 8 : Algorithme du rang
Entrées : Un digraphe G=(V,E) sans circuit
Output : Le rang r(v) de chaque sommet v∈Vde G
1r←0;X←V;
2R←{v∈X:Γ−
X(v)= ;} ; // l'ensemble des sommets de X sans prédécesseur dans X
3tant que X̸= ; faire
4 r(v)←rpour chaque sommet v∈R;
5 X←X−R;
6 R←l’ensemble des sommets de Xsans prédécesseur dans X;
7 r←r+1;
8fin
On supposera dorénavant que les sommets ont déjà été numérotés de 1 à nde manière compatible avec leurs
rangs, c’est-à-dire que r(j)>r(i) implique j>i(donc 1 =setn=t). Enfin, on supposera éliminés les arcs paral-
lèles par l’introduction de tâches fictives de durée nulle .
Pour un sommet i, on note tiledébut au plus tôt des tâches correspondant aux arcs i→jet par Tilafin au
plus tard des tâches correspondant aux arcs j→i.
Algorithme 9 : Algorithme du chemin critique
Entrées : Un digraphe G=(V,E) sans circuit trié topologiquement
Output : La durée du chemin critique et les dates ti,Ti
1t1←0;
2pour j=2···nfaire // Calcul des dates de début au plus tôt  récurrence en avançant
3 tj←max i∈Γ−(j){ti+w(i,j)}
4fin
5Tn←tn;
6pour j=n−1···1faire // Calcul des dates de fin au plus tard  récurrence en reculant
7 Tj←min i∈Γ+(j){Ti−w(j,i)}
8fin26 Chapitre 3. Les algorithmes de base
Définition 3.1
— Un sommet iest critique si ti=Ti.
— Un arc ( i,j) est critique les sommets ietjsont critiques ettj−ti=w(i,j).
— Un chemin critique est un chemin de 1 à nn’utilisant que des arcs critiques.
— La durée du chemin critique est donnée par Tn(ou par tn). Elle correspond à la durée minimale du
projet .
Example 3.4
L ’application de l’algorithme du chemin critique au digraphe suivant (trié topologiquement) est :
1 23
45
6B
9A
3
C
5D
8
E
4
F7G
20
H6I5
=⇒
 1
0,02
9,933,16
4
16,23513,24
6
29,29B
9A
3
C
5D
8
E
4
F7G
20
H6I5
Les tâches critiques sont BetG. La durée totale minimale du projet est donc 29.
Exercice 3.2
Les tâches ( durée et précédences ) pour la construction d’un entrepôt sont données dans le tableau suivant :
Tâches Nature Précédences Durée (jours)
A Acceptation des plans par le propriétaire – 4
B Préparation du terrain – 2
C Commande des matériaux A 1
D Creusage des fondations A, B 1
E Commande des portes et fenêtres A 2
F Livraison des matériaux C 2
G Coulage des fondations D, F 2
H Livraison des portes et fenêtres E 10
I Pose des murs, de la charpente et du toit G 4
J Mise en place des portes et fenêtres H, I 1
1. Représentez le graphe des précédences de ce projet (trié topologiquement).
2. Déterminez une durée totale minimale en exhibant un chemin critique dans ce graphe.CHAPITRE 4
Programmation linéaire
La programmation linéaire est le processus de minimiser ou maximiser une fonction objective linéaire sou-
mise à un nombre fini de contraintes d’égalités et d’inégalités linéaires.
La programmation linéaire a de nombreuses applications dans le domaine de l’informatique théorique. Elle
peut être utilisée pour résoudre de nombreux problèmes combinatoires variés, tels que la recherche de flot maxi-
mum dans un réseau, la recherche d’un couplage maximal dans un graphe et la coloration d’un graphe parfait.
Example 4.1 (Problème de régime)
On suppose qu’on a quatre plats : de la truite ( XT), un sandwich au corned-beef ( XC B), un burrito ( XBU R )
et un hamburger ( XHB). Le tableau suivant répertorie la valeur nutritionnelle de chaque plat (vitamines et
calories) et notre besoin journalier des vitamines.
Vit. A Vit. C Vit. D Calories
Truite 203 92 100 600
Corned-beef 90 84 230 350
Burrito 270 80 512 250
Humburger 500 90 210 500
Besoins 2000 300 430
Notre objectif est de minimiser le nombre total de calories consommées : 600 XT+350XC B+250XBU R+
500XHBtout en satisfaisant les trois besoins nutritionnels en vitamines. Le programme linéaire résultant
s’écrit :
min 600 XT+350XC B+250XBU R+500XHB
s.t. 203 XT+90XC B+270XBU R+500XHB≥2000, (Besoins de Vit. A),
92XT+84XC B+80XBU R+90XHB≥300, (Besoins de Vit. C),
100XT+230XC B+512XBU R+210XHB≥430, (Besoins de Vit. D),
XT,XC B,XBU R ,XHB≥0
Définition 4.1: Forme canonique – Forme standard
On peut écrire un P .L. sous deux formes spéciales :
•Canonique
max
mincTX+c0
s.t. AX≤b(≥bsi min),
X≥0•Standard
max cTX+c0
s.t. AX=b,
X≥0Avec :
cTX=¡
c1··· cn¢
x1
...
xn

cTX+c0=c1x1+c2x2+···+ cnxn+c0
2728 Chapitre 4. Programmation linéaire
Remarque 9. Un P .L. général peut être formulé selon une forme standard ou canonique par la méthode suivante :
générale =⇒ standard il faut éliminer les contraintes d’inégalité et les variables sans contrainte de positivité.
— Si dT
iX≤biest une contrainte d’inégalité, alors créer une nouvelle variable ( d’écart ) siet remplacer l’in-
égalité dT
iX≤bipar dT
iX+si=biet s i≥0.
Si dT
iX≥bi, alors on peut écrire dT
iX−si=biet s i≥0.
— Si une variable x i≶0est de signe quelconque, alors créez deux nouvelles variables x+
iet x−
iet remplacez
xipartout par x+
i−x−
i, et ajoutez les contraintes de signe : x+
i≥0,x−
i≥0.
générale =⇒ canonique
— Si dT
iX=biest une contrainte d’égalité, alors remplacer cette égalité par une paire d’inégalités :
dT
iX≥biet−dT
iX≥ −bi
— Même chose que précédemment si la variable x i≶0.
Il est facile de voir que les problèmes qui en résultent sont équivalents aux problème d’origine. Pour l’algorithme
simplexe , nous utiliserons la forme standard .
On remarque aussi qu’en utilisant la relation min f(x)= − max¡
−f(x)¢
dans laquelle f (x)représente la fonction-
nelle linéaire à optimiser, on peut toujours se ramener à un problème de minimisation (ou de maximisation).
Example 4.2
Le P .L :max 5 x+4y
s.t. x≤6
1
4x+y≤6
3x+2y≤22
x,y≥0s’écrit sous forme standard :max 5 x1+4x2
s.t. x1+e1=6
1
4x1+x2+e2=6
3x1+2x2+e3=22
x1,x2,e1,e2,e3≥0
Donc (sous la forme matricielle) on a :
cT=¡
5 4 0 0 0¢
;A=
1 0 1 0 0
1
41 0 1 0
3 2 0 0 1
;X=
x1
x2
e1
e2
e3
et b=
6
6
22

4.1 La méthode simplexe
4.1.1 Solution de base admissible
On suppose que la matrice Adu programme linéaire est de type m×netde rang m(pourquoi !). Soit Bla
matrice carrée extraite de Aformée par les mcolonnes j1,j2,..., jmlinéairement indépendants de A(les vecteurs
de base). Alors, Best une matrice inversible. Ainsi si on pose xl=0 sil∉{j1,..., jm} etxjklak-ième composante de
B−1b. Alors, on a AX B=b. Si de plus XB≥0(i.e. chaque xi≥0), alors :
Xest une solution de base admissible (ou réalisable)
Dans l’exemple 4.2, la matrice extraite B=
1 0 0
0 1 0
0 0 1
est inversible et B−1b=
6
6
22
. Donc XB=
0
0
6
6
22
≥0, par suite
XBest une solution de base admissible. On appelle les variables xjklesvariables de base . Les autres variables xl
sont les variables hors-base .
Parfois, il n’est pas évident de trouver une solution de base admissible, comme le montre l’exercice suivant :H. SABRI 29
Exercice 4.1
Écrire le programme linéaire suivant sous forme standard et montrer qu’on n’a pas une solution de base
admissible. Résoudre le programme linéaire.
max −x+y
s.t. x+y≥1,
3x+2y=6,
x,y≥0
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux
Dans cette section, on suppose qu’on a déjà trouvé une solution de base admissible X(produite avec B=Im)
du programme linéaire ( P: max z=cTX+c0etb≥0pour garantir que 0est une solution de AX≤b).
La méthode du simplexe est une méthode itérative qui génère une séquence de solutions de base réalisable
(correspondant à différentes bases) et s’arrête finalement lorsqu’elle a trouvé une solution de base réalisable opti-
male. Remarquer qu’on peut toujours prendre c0=0.
Algorithme 10 : Algorithme du simplexe
Entrées : Un P .L. standard P(max) avec une solution de base réalisable
Output : La solution optimale (ou non)
1On commence à écrire le tableau initiale (avec les variables de base xj1,..., xjm)
VB x1 ... xn b
xj1 b1
... A...
xjm bm
c1 ... cn−c0
2Sicj≤0 (∀j:xjest hors base), alors solution optimale (STOP) // min ⇝cj≥0
3Trouver la colonne s(hors base) tel que cs=max©
cj:cj>0ª// min ⇝cs=min©
cj:cj<0ª
4Siai,s≤0∀i=1... m, alors pas de solution optimale (STOP)
5Min Ratio Test : trouver la ligne rtel que
br
ar,s=min
i=1...m½bi
ai,s:ai,s>0¾
6Appliquer la procédure de Gauss autour de pivot ar,s(ar,s⇝1 et on annule les coefficients situés sous et
sur le pivot dans la colonne s, par combinaisons de lignes) // Ne pas oublier la dernière ligne
7Remplacer (dans VB) la variable de base ( sortante ) située à la ligne rpar la variable ( entrante )xs
8Retourner à l’étape 2 // l'algorithme termine si le programme linéaire est non dégénéré
Remarque 10.
— La dernière ligne représente l’équation linéaire −z+c1x1+···+ cnxn= −c0.
— La valeur de la variable de base de V Bde la ligne k est égale à la valeur b k(de la ligne k).
— La solution optimale du problème est la valeur finale (dernière cellule) (×− 1).
— Si on n’a pas au départ B =Im(à l’aide des variables d’écart) alors, on ajoute les variables artificielles (et on
applique d’abord la phase I - voir section suivante).30 Chapitre 4. Programmation linéaire
Exercice 4.2
Soit le programme linéaire :
max 2 x1+x2
s.t. x1−x2≤3,
x1+2x2≤6,
−x1+2x2≤2,
x1,x2≥0
Rajouter les variables d’écart. Puis résoudre le problème par l’algorithme du simplexe.
Remarque 11. Vérifier le résultat de l’exercice précédent, par la méthode graphique.
4.1.3 Initialisation - Phase I du simplexe
Un programme linéaire est dit sous forme simpliciale si la matrice Acontient la matrice identité Imcomme
sous matrice. On suppose que le programme linéaire P, après la mise en forme AX=b, n’est pas simpliciale
(possible dans le cas de contraintes du type ≥ou du type =). Soit Bune matrice d’ordre mextraite de Ainversible
tel que B−1b≥0et soit XBla solution de base réalisable ( XB≥0etAX B=b), alors on peut changer l’équation
matricielle :
AX B=b
⇐⇒ (B−1A)XB=B−1b
⇐⇒ A∗XB=b∗
et la matrice A∗contient la matrice identité Imcomme matrice extraite ( B−1A=B−1(H|B)=¡
B−1H|Im¢
). Ainsi, on
peut appliquer directement l’algorithme 10 en remplaçant Apar A∗etbpar b∗. Cependant, cette méthode n’est
pas efficace, car il faut trouver une matrice extraite Bréalisable correspondante. Pour une matrice Ade type m×n,
il existe¡m
n¢
matrices extraites à tester !
L ’idée est d’ajouter des variables, dites artificielles w1,w2,..., wm, pour faire apparaître une forme simpliciale
du programme linéaire P: (AX=b). Mais, il faut que w1= ··· = wm=0. Donc, il faut minimiser d’abord le pro-
gramme linéaire P0suivant :
P0=min W=w1+···+ wm
s.t. (A|Im)×(x1...xnw1...wm)T=b
x1,..., xn,w1,..., wm ≥0
On exprime Wà l’aide des autres variables (hors base) et puis on applique l’algorithme du simplexe 10 pour P0
(phase I). À la fin, si on trouve que les wi=0, alors les variables de bases xj1,..., xjmforment une première base
admissible pour démarrer le simplexe pour le programme d’origine P.H. SABRI 31
Remarque 12. On ajoute la ligne de Z :c1 ... cn−c0dans le tableau du simplexe de P0(phase I) et on lui
applique les opérations élémentaire comme avec les autres lignes. À la fin de la phase I, on supprime les colonnes des
wiet la ligne de la fonction W . Finalement, on utilise ce tableau pour résoudre le problème initiale P.
Example 4.3
Soit le programme linéaire P:
min 6 x1+3x2
s.t. x1+x2≥1,
2x1−x2≥1,
3x2≤2,
x1,x2≥0sous forme standard (max)= = = = = = = = = = = = = = = = = = ⇒max Z= −6x1−3x2
s.t. x1+x2−e1=1,
2x1−x2−e2=1,
3x2+e3=2,
x1,x2,e1,e2,e3≥0
La matrice Aest :
A=x1 x2 e1 e2 e3

1 1 −1 0 0
2−1 0 −1 0
0 3 0 0 1
est par suite Pn’est pas sous forme simpliciale (il n’ ya pas de sous matrice I3). Donc on peut ajouter 2
variables artificielles pour construire le problème initiale P0:
max −w1−w2=3x1−e1−e2−2
s.t. x1+x2−e1+w1=1,
2x1−x2−e2+w2=1,
3x2+e3=2,
x1,x2,e1,e2,e3,w1,w2≥0dont le vecteur X=

0 x1
0 x2
0 e1
0 e2
2 e3
1 w1
1 w2est une solution de base réalisable.
Ainsi, on commence notre algorithme 10 pour le programme P0. Le tableau initial est :
x1 x2 e1 e2 e3 w1 w2 b

w1 1 1 −1 0 0 1 0 1
w2 2−1 0 −1 0 0 1 1
e3 0 3 0 0 1 0 0 2
W: 3 0 −1−1 0 0 0 2
Z:−6−3 0 0 0 0 0 0
Le pivot c’est a2,1donc x1est la variable entrante et w2est sortante. On obtient après pivotement le tableau :
L2←1
2L2− − − − − − − − →
L1←L1−L2
L4←L4−3L2
L5←L5+6L2x1 x2 e1 e2 e3 w1 w2 b

w1 03
2−11
20 1−1
21
2
x1 1−1
20−1
20 01
21
2
e3 0 3 0 0 1 0 0 2
W: 03
2−11
20 0−3
21
2
Z: 0 −6 0 −3 0 0 3 3
Le pivot est a1,2(Min ratio test =1
3). On obtient alors :32 Chapitre 4. Programmation linéaire
L1←2
3L1− − − − − − − − →
L2←L2+1
2L1
L3←L3−3L1
L4←L4−3
2L1
L5←L5+6L1x1 x2 e1 e2 e3 w1 w2 b


x2 0 1−2
31
302
3−1
31
3
x1 1 0−1
3−1
301
31
32
3
e3 0 0 2 −1 1 −2 1 1
W: 0 0 0 0 0 −1−1 0
Z: 0 0 −4−1 0 4 1 5
Ainsi, la phase I se termine avec W=0 et x1=2
3,x2=1
3,e3=1 et e1=e2=w1=w2=0. Le tableau pour la
phase II est donc :
x1 x2 e1 e2 e3 b


x2 0 1−2
31
301
3
x1 1 0−1
3−1
302
3
e3 0 0 2 −1 1 1
Z: 0 0 −4−1 0 5
On remarque donc que les cj≤0, donc (STOP) la solution est optimale et le max est −5. Ainsi la solution
optimale pour le programme P=min6 x1+3x2est−(−5)=5=6×2
3+3×1
3.
4.2 Dualité
SoitPun P .L. sous forme canonique. Le programme dualDdePest définit par :
P=max z=cTX
s.t. AX ≤ b
X≥ 0le dual est= = = = = = = ⇒D=min w=bTY
s.t. ATY≥ c
Y≥ 0
Le programme Pest dit primal . On remarque que si Ade type m×n, alors X∈RnetY∈Rmpour le dual.
Théorème 4.1 Théorème de dualité
Si un problème primal ou dual admet une solution, alors l’autre problème admet aussi une solution et on a :
max z=cTX =
s.t. AX ≤ b
X≥ 0min w=bTY
s.t. ATY≥ c
Y≥ 0
Exercice 4.3
Soit le problème suivant de type régime :
D=min w=340x1+2400 x2+560x3
s.t. x1+2x2+x3≥ 1200
x1+3x2+2x3≥ 1400
x1+x2+3x3≥ 1500
x1,x2,x3≥ 0
Écrire le programme primal PdeD. Résoudre le programme Pet déduire la valeur minimale de w, a-t-on
besoin de faire les deux phases du simplexe ?
7} A B oS



HOUSSEM SABRI
Graphes et Optimisation
2`emeannée
LISI  LSI
Institut Supérieur des Sciences Appliquées et de Technologie de Sousse
A.U. 2023-2024
28 novembre 2023Table des matières
1 Les graphes 3
1.1 Définitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.1 Graphes non orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.2 Graphes orientés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.2 Opérations et quelques types de graphes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.3 Représentation d’un graphe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.1 Listes d’adjacences (ou de succession) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3.2 Matrices d’adjacence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.3.3 Matrice d’incidence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2 La connexité 11
2.1 Les chaînes et les cycles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.2 Graphe connexe, eulérien, hamiltonien . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.3 Arbres . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.3.1 Codage et décodage d’un arbre – Prüfer code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.3.2 Arbre couvrant de poids minimum – ACM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3 Les algorithmes de base 20
3.1 Parcours en profondeur (DFS) / largeur (BFS) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
3.2 Recherche des chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.1 Matrice d’adjacence et nombre de chemins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.2 Plus court chemin et l’algorithme de Dijkstra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
3.3 Problèmes d’ordonnancement et chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
3.3.1 Algorithmes de tri topologique et de chemin critique . . . . . . . . . . . . . . . . . . . . . . . . . . 25
4 Programmation linéaire 27
4.1 La méthode simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.1 Solution de base admissible . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux . . . . . . . . . . . . . . . . . . . . . . . . 29
4.1.3 Initialisation - Phase I du simplexe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
4.2 Dualité . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
2CHAPITRE 1
Les graphes
L ’exemple classique pour introduire la théorie des graphes est le problème des ponts de Königsberg, étudié par
Euler en 1736. Quel itinéraire doit-on suivre pour traverser chaque pont exactement une fois? Une telle prome-
nade n’existe pas, et c’est Euler qui donna la solution de ce problème en caractérisant les graphes que l’on appelle
aujourd’hui eulériens .
A
B
Ce1 e2
e3 e4
De5
e6e7
FIGURE 1.1 – Les ponts de Königsberg
Les graphes introduisent une simplification : les régions se transforment en des "points" (aussi appelés noeuds
ousommet ), les ponts se transforment en des lignes (aussi appelées arêtes ouarcs ), et ce principe s’applique dès
lors qu’une relation existe entre des objets. Les graphes relèvent de la combinatoire plutôt que de la géométrie (les
intersections, les longueurs, et la forme des arêtes n’ont aucune importance, sauf en ce qui concerne la lisibilité de
la représentation).
1.1 Définitions
Dans la suite, il est toujours supposé que les graphes sont finis, sauf indication contraire.
1.1.1 Graphes non orientés
Définition 1.1: Graphe
Un graphe Gest un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V{2}des pairs non ordon-
nées de V.Vest l’ensemble des noeuds (Vertices en anglais) et Ec’est l’ensemble des arêtes de G(Edges en
anglais). Lorsque e={x,y} est une arête, on dit que x, y sont les extrémités de cette arête, que eest incidente
enxet en y. On joint x et y par un trait et on dit que x, y sont adjacents (ou voisins). On note aussi e=x you
encore e=(x,y) (attention , dans ce cas : ( x,y)=(y,x)).
SiGest un graphe alors, on note par V(G) l’ensemble de noeuds et par E(G) l’ensemble des arcs.
Remarque 1.
— Une arête e ={x,x}s’appelle boucle .
— Dans un graphe, il peut exister des arêtes parallèles (on parle donc de multigraphe ).
Dans l’exemple des ponts on a : e 1=e2=(A,B).
34 Chapitre 1. Les graphes
— Un graphe est dit simple s’il ne comporte ni arêtes multiples ni de boucles, c’est-à-dire chaque paire de nœuds
distincts est reliée par au plus une arête, ou encore E (G)⊆P2(G).
Dans la plupart des cas, les graphes sont considérés comme simples par défaut.
Définition 1.2: ordre – taille – degré
Soit G=(V,E) un graphe.
1. On appelle ordre d’un graphe noté v(G) le nombre de ses sommets :
v(G)= |V|
2. On appelle taille d’un graphe noté e(G) le nombre de ses arêtes :
e(G)= |E|
3. Le degré (ou valence) d’un sommet xnoté d(x) est le nombre d’arêtes contenant x. (Attention! Une
boucle sur un sommet compte double).
Si on note par Γ(x) l’ensemble des voisins de x, i.e.
Γ(x)={y∈V:x y∈E}
alors, siGest simple , on a :
d(x)= |Γ(x)|
Example 1.1 (Graphe complet)
Un graphe d’ordre nest dit complet noté Knsi chaque sommet du graphe est relié directement à tous les
autres sommets, i.e. E(Kn)=P2(V(Kn)).
Représenter graphiquement K3,K4,k5. Calculer la taille de K3,k4,...Kn.
Example 1.2 (Graphe biparti)
Un graphe G=(V,E) est dit biparti si son ensemble de sommets V=V1˙∪V2, i.e. peut être divisé en deux
sous-ensembles disjoints V1etV2tels que chaque arête ait une extrémité dans V1et l’autre dans V2.
Si∀x∈V1,∀y∈V2;x y∈E, alors Gest dit biparti complet noté Kn,moùn= |V1|etm= |V2|.
a1
 a2
 a3
 a4
b1
 b2
 b3
FIGURE 1.2 – Un graphe biparti
Théorème 1.1 Lemme des poignées de main – Handshaking lemma
Soit Gun graphe alors, on a :X
x∈V(G)d(x)=2e(G)
Dans ce théorème d(x) est le nombre de personnes à qui xserre la main et e(G) le nombre total de poignées
de mains.H. SABRI 5
Preuve.
•Méthode simple Il y en a d(x) arêtes en un sommet xfixé. Pour tout les sommets cela fait doncP
x∈V(G)d(x).
Mais avec cette manière chaque arête est comptée deux fois, une fois à chacune de ses extrémités, d’où le
résultat en divisant par 2.
•Preuve par double dénombrement On pose
Z={(x,e)∈V×E:x∈e}⊆V×E
et les deux projections :
p:Z→V
(x,e)7→xet q:Z→E
(x,e)7→e
L ’idée est de calculer |Z|de deux manières différentes. D’abord, on rappelle que si f:A→Best une fonction
quelconque, alors :X
b∈B|f−1[b]| = | A|
oùf−1[b] désigne l’image réciproque de { b} par f(pourquoi ˙S
b∈Bf−1[b] est une union disjointe ?).
Ainsi on obtient :
|Z| =X
x∈V|p−1[x]| =X
e∈E|q−1[e]|
Or,|p−1[x]| =d(x) et|q−1[e]| = |{x∈V:x∈e}| =2. Donc :
X
x∈Vd(x)=X
e∈E2=2|E|
Remarque 2.
— Un sommet de degré 0est appelé sommet isolé .
— Un graphe tel que : ∀x∈V,d(x)=kest dit graphe k-régulier .
— Le graphe complet K nest un graphe (n−1)-régulier .
Exercice 1.1
Montrer que dans un graphe le nombre de sommets d’ordre impairs est toujours pair. En particulier un
graphe k-régulier avec kimpaire est un graphe d’ordre pair.
Voici quelques exemples comme application :
1. Est-il possible de relier 15 ordinateurs en réseau de sorte que chacun soit relié à exactement 3 autres ?
2. Une ligue de football comprenant 11 clubs organise un tournoi. Pour gagner du temps on décide que chaque
équipe ne jouera que la moitié des matches possibles. Comment organiser le tournoi ?
Proposition 1.1
Soit G=(V,E) un graphe (simple) d’ordre n≥2. Alors :
∃u,v∈V,u̸=v:d(u)=d(v)
Preuve. Supposons le contraire, c’est-à-dire ∀u,v∈V;d(u)̸=d(v). Or dans un graphe (simple) on a toujours d(x)∈
{0,1,..., n−1}. Dans ce cas, puisque tous les nsommets ont des degrés distincts, alors il existe une bijection
{d(x):x∈V}←→ {0,1,..., n−1}
Donc, il existe un sommet uavec un degré 0, et un sommet vavec degré n−1, donc vest connecté à tous les autres
sommets du graphe, ce qui signifie que une peut pas être un sommet isolé, d’où une contradiction.6 Chapitre 1. Les graphes
1.1.2 Graphes orientés
Les arêtes d’un graphe peuvent être orientées, auquel cas une flèche indique la direction. De tels graphes sont
appelés des graphes orientés ou des digraphes , et une arête ( a,b) dans un tel graphe indique que cette arête est
dirigée de sommet avers b, i.e. ( a,b)=− →ab̸=(b,a)=− →ba. D’où la définition :
Définition 1.3: Graphe orienté - digraphe
Un graphe orienté G(ou− →G) est un couple d’ensembles ( V,E) où l’ensemble Eest une partie de V2des pairs
ordonnées de V.Eest l’ensemble des arêtes (ou flèches, arcs) de G. Lorsque e=(x,y) est une arête, on dit
que xestl’origine (ou sommet initiale) et yl’extrémité (ou sommet terminale) de e, que eest sortant en x
et incident en y, et que yest un successeur de xtandis que xest un prédécesseur de y. On note l’arête e
par :
e=(x,y)=− →x y=x→y
De la même façon, une arête x→xest une boucle. On peut toujours supprimer les boucles pour obtenir des
digraphes simples. Voici l’exemple d’un digraphe G=(V,E) d’une fonction f:E→Eoù ( x,y) est un arc si et seule-
ment si y=f(x). On l’appelle digraphe fonctionnelle.
0
3
1214
11 568
169
4
2 1
713 10
15
FIGURE 1.3 – Le digraphe fonctionnelle Gfdex7→(x2+3) mod 17.
Comme dans les graphes on peut définir les degrés (entrant, sortant) d’un sommet dans un digraphe.
Définition 1.4: indegree - outdegree
Soit G=(V,E) un digraphe. Pour v∈V, on note par :
d+(v) le degré extérieur (sortant - outdegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité initiale.
d+(v)= |{v→ •}|
d−(v) le degré intérieur (entrant - indegree) du sommet v, c’est-à-dire le nombre d’arcs ayant vcomme
extrémité finale.
d−(v)= |{• → v}|
On définit le degré : d(v)=d−(v)+d+(v).
Un sommet de degré entrant non nul et de degré sortant nul est appelé puits , tandis qu’un sommet de
degré entrant nul et de degré sortant non nul est appelé source ouracine .
Dans un graphe orienté, les voisins d’un sommet vsont soit des successeurs ou des prédécesseurs. On les notes
par :
Γ+(x)=Succ (x)={y∈V:x→y∈E} et Γ−(x)=Pr ed (x)={y∈V:y→x∈E}H. SABRI 7
Si le digraphe est simple (ni boucle ni arcs parallèles) on a :
d−(v)= |Γ−(v)|et d+(v)= |Γ+(v)|
Proposition 1.2
Soit Gun digraphe, alors :X
v∈Vd−(v)=X
v∈Vd+(v)= |E|
Preuve. On a
E=˙[
v∈V{• → v}=˙[
v∈V{v→ •}
=⇒ | E| =X
v∈V|{• → v}| =X
v∈V|{v→ •}| =⇒ | E| =X
v∈Vd−(v)=X
v∈Vd+(v)
1.2 Opérations et quelques types de graphes
Une opération sur les graphes permet de construire un nouveau graphe comme résultat de l’opération. Les
opérations courantes sur les graphes sont la suppression, la valuation, l’union, l’intersection et le produit cartésien.
Graphe valué
Tout d’abord, on peut vouloir attribuer des valeurs aux arcs ou arêtes pour tenir compte de contraintes : dis-
tance, coût ...
Définition 1.5: (di)graphe valué
Un (di)graphe valué G=(V,E,w) est un (di)graphe muni d’une application w:E→R. L ’application west
appelée application poids ou coût. On indique sur chaque arête son poids (ou son coût). On note w(x,y)
au lieu de w((x,y)). On convient (même que ceci n’a pas de sens!) que w(x,y)= +∞ si (x,y)∉E.
ab
c
d
ef53
43
3
335
81
FIGURE 1.4 – Un digraphe valué
/pythonPython code : -
Implémenter le digraphe valué précédent avec python. Indice – use chatGPT : how to build a weighted digraph with
python8 Chapitre 1. Les graphes
Sous graphes
Soit G=(V,E) un graphe (orienté ou non). Un sous graphe de Gest un graphe de la forme G′=(V′,E′) où
V′⊆V,E′⊆Etels que toute arête de E′a ses extrémités dans V′(ou encore G′est aussi un graphe). On a :
•Sous-graphe induit Un sous-graphe G′=(V′,E′) de G=(V,E) est appelé un sous-graphe induit deGsi :
∀x,y∈V′; (x,y)∈E′⇐⇒ (x,y)∈E
En d’autres termes, deux sommets de G′qui sont connectés dans G, sont également connectés dans G′.
•Sous-graphe couvrant Un sous-graphe couvrant G′deGcontient tous les sommets de G, i.e. V′=V.
•G−vSupprimer un sommet vd’un graphe Gconsiste à supprimer vet toutes ses arêtes incidentes. Le sous-
graphe obtenu de cette opération est noté G−v, i.e.
V′=V−{v} et E′=E−{(v,y): (v,y)∈E}
De manière similaire, une arête epeut être supprimée (resp. ajoutée) d’un graphe G, et le sous-graphe
résultant est représenté par G−e(resp. G+e). Notez que la suppression d’une arête ne retire pas de sommets
du graphe.
•G−V′=G[V′] On supprimer tous les sommets v∈V′du graphe Gavec les arêtes incidentes. Le sous-graphe
obtenu de cette opération est noté G[V′], i.e.
V(G[V′])=V−V′et E(G[V′])=E−{(v,y)∈E:v∈V′}
•Clique Une clique Cd’un graphe Gest un sous-ensemble des sommets de Gdont le sous-graphe induit G′=
(C,E′) est un graphe complet, en d’autres termes, deux sommets quelconques de la clique Csont toujours
adjacents.
•Stable Un stable – appelé aussi ensemble indépendant (independent set en anglais) est un ensemble de som-
mets deux à deux non adjacents. Donc le sous-graphe induit est sans arcs.
FIGURE 1.5 – L ’ensemble des sommets en bleu dans ce graphe est un stable maximal du graphe.
Note : -
Le problème décisionnel de la clique (c’est à dire existe t-il une clique de taille k) est NP-complet . De même la
recherche d’un stable de taille maximum dans un graphe est un problème NP-complet et difficile à approximer.
Exercice 1.2
Trouver un plus grand stable et une plus grande clique du graphe suivant :
8
4
62 7
3
1 5
Indice : vérifier le résultat avec networkx.find_cliques(G) et.maximum_independent_set(G) de python.H. SABRI 9
Opérations binaires
Union L ’union de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∪H=(VF,EF) dans lequel
VF=VG∪VH et EF=EG∪EH
Intersection L ’intersection de deux graphes G=(VG,EG) et H=(VH,EH) est un graphe F=G∩H=(VF,EF)
dans lequel
VF=VG∩VH et EF=EG∩EH
1.3 Représentation d’un graphe
Il est important de savoir comment représenter les graphes au sein d’un ordinateur. Il ya plusieurs méthodes
selon la nature des traitements que l’on souhaite appliquer au graphe considéré.
1.3.1 Listes d’adjacences (ou de succession)
Soit Gun (di)graphe. On suppose que les sommets de Gsont numérotés de S1àSn. La représentation par listes
d’adjacence de Gconsiste en un tableau (ou des listes chainées) tel que la ligne i=1... ncorrespond au sommet Si
et comporte la liste des voisins/successeurs (ou des prédécesseurs) de ce sommet notée T[Si]. Les sommets dans
chaque liste d’adjacence sont généralement listés selon un ordre arbitraire.
1
2
345
FIGURE 1.6 – Un digraphe
La liste d’adjacence de digraphe 1.6 est donc :
1 2 3 4 5
2 3
3 4
4−
5 1 410 Chapitre 1. Les graphes
1.3.2 Matrices d’adjacence
Définition 1.6: Mat. Adjacence
Soit G=(V,E) un graphe (orienté) d’ordre n. On peut numéroter V={1,2,..., n}.La matrice d’adjacence
deGest la matrice carrée A=(ai j) d’ordre n, définie par :
ai j=(
1 si ( i j)∈E;
0 sinon.
Remarque 3.
1. Si le graphe G est non orienté et simple, alors la matrice A est symétrique avec des 0sur la diagonale. Pour un
digraphe simple, on a toujours des 0sur la diagonale, mais la matrice n’est pas symétrique en général.
2. Pour les multigraphes, il peut y avoir des termes diagonaux (pour les boucles) et s’il y a plusieurs arêtes de i à
j , le coefficient de la matrice a i jest le nombre d’arêtes de i à j .
3. Pour un (di)graphe valué G =(V,E,w), on pose :
ai j=(
w(i,j)si(i j)∈E ;
∞ sinon.
La matrice d’adjacence de la figure 1.4 est :

∞ 5∞ 4 3 ∞
∞ ∞ 3∞ 1∞
∞ ∞ ∞ ∞ ∞ 5
∞ ∞ 3∞ 3 3
∞ ∞ ∞ ∞ ∞ 8
∞ ∞ ∞ ∞ ∞ ∞

1.3.3 Matrice d’incidence
Définition 1.7: Mat. Incidence
Soit G=(V,E) un graphe (simple) d’ordre net de taille m. On pose V={v1,v2,..., vn} etE={e1,e2,..., em}.
La matrice d’incidence deGest la matrice de type n×m B=(bi j), définie par :
•Si G orienté
bi j=

1 si ej=vi→ • (i.e. viest l’extrémité initiale de ej) ;
−1 si ej= • → vi(i.e. viest l’extrémité terminale de ej) ;
0 sinon.
•Si G non-orienté
bi j=(
1 si viest une extrémité de ej;
0 sinon.
Exercice 1.3
1. Donner la matrice d’incidence du graphe 1.6.
2. Montrer le théorème 1.1 avec la matrice d’incidence.CHAPITRE 2
La connexité
Il est important de savoir si on peut suivre un chemin d’un sommet donné à un autre dans un graphe donné.
Cette propriété (de connexité) doit être maintenue dans différents types de réseaux.
2.1 Les chaînes et les cycles
Définition 2.1: (chaine – cycle) (chemin – circuit)
•Graphe non orienté
1. Une chaîne (walk ) reliant xày, notée µ(x,y), est définie par une suite finie d’arêtes consécutives,
reliant xày, ou encore une séquence de sommets (puisque non multigraphe)
µ(x,y)=<v0,v1,..., vk>
tels que v0=x,vk=yet (vi−1,vi)∈E(G) pour tout i=1... k. Six=yla chaîne est dite fermée .
Lalongueur du chaîne l(µ(x,y)) est le nombre d’arcs dans la chaîne, c’est-à-dire k.
2. Une chaîne élémentaire (a path ) si tous les sommets sont distincts. Une chaîne simple (a simple
walk, a trail ) est une chaîne ne passant pas deux fois par une même arête, c’est-à-dire dont toutes
les arêtes sont distinctes. Remarquer que : élémentaire =⇒ simple.
3. Un cycle v0v1...vnde longueur n≥3 est une chaîne simple fermée ( v0=vn) tel que les sommets
v0,v1,..., vn−1sont tous distincts. Un graphe sans cycle est dit acyclique .
•Graphe orienté
Dans un graphe orienté, on parlera de chemin au lieu de chaîne, et de circuit au lieu de cycle.
Example 2.1
abxcd xa est une chaîne simple et fermée (non cycle!) de longueur 6 (mais, c’est un graphe eulérien - voir
plus loin). Y a-t-il un cycle de longueur 3,4 ?
a b
x
c dÏ
Remarque 4.
1. On peut pivoter une chaine fermée (l’orienter de manière arbitraire) , i.e.
<v0,v1,v2,..., v0>=< vk,vk+1,..., v0,v1,..., vk>
1112 Chapitre 2. La connexité
2. Soient x ,y∈V . La distance de x à y est définie par :
d(x,y)=(
k si le plus court chemin/chaîne de x vers y est de longueur k
∞ sinon
On convient que d (x,x)=0.
3. Le diamètre du graphe la plus grande distance entre deux sommets.
L ’observation suivante, bien que très facile à prouver, sera utile.
Théorème 2.1
S’il existe une chaîne du sommet yau sommet zdans le graphe G, où y̸=z, alors il existe une chaîne élé-
mentaire ( path ) dans Gavec pour premier sommet yet pour dernier sommet z.
Preuve. Soit la chaine
W1=µ(y,z)=x0x1...xn; avec x0=yetxn=z.
Si les sommets x0,x1,..., xnsont tous distincts, alors W1est une chaîne élémentaire, et nous avons terminé. Sinon,
il existe xi=xj(i<j) et on écrit :
W2=x0x1...xixj+1...xn.
Alors, l(W2)<l(W1). Si W2ne contient aucun sommet répété, alors c’est la chaîne recherché. Sinon, par la même
procédure, il existe W3(y z−chaîne) tel que
l(W3)<l(W2)<l(W1).
Ce processus doit s’arrêter à un certain stade, car chaque chaîne est plus courte que la précédente et la longueur
ne peut jamais être inférieure à 1
1< ··· < l(Wk)< ··· < l(W3)<l(W2)<l(W1).
Ainsi, pour un certain k,Wkne peut pas être réduit en longueur. Donc, la chaîne Wkne contient aucun sommet
répété et est donc une y z−chaîne élémentaire (path).
Exercice 2.1
Dans le graphe suivant, construire un path à partir de la chaîne W=v2v3v4v5v6v4v2v8v1
v1
 v2
v3
v4
v5
v6
v7
 v8
 v9
Calculer d(v1,v7) et le diamètre de G.
/pythonpython : >>G = nx.Graph([(1, 2), (2, 3), (2, 4), ...]) >>nx.diameter(G)
Les cycles fournissent la caractérisation suivante pour les graphes bipartis .H. SABRI 13
Théorème 2.2
Un graphe est biparti si et seulement s’il ne contient aucun cycle de longueur impaire.
Preuve.
⇒On suppose que G=U˙∪Vest un graphe biparti. Soit W=< x1,x2,..., x2k+1,x1>un cycle de longueur im-
paire (2 k+1). Si x1∈U, alors
x1∈U=⇒ x2∈V=⇒ x3∈U=⇒ ··· =⇒ x2k+1∈U=⇒ x1∈V/exclamati⌢n-triangle
absurde, d’où le résultat.
⇐On suppose que Gest connexe (car l’union des composantes connexes bipartis est un graphe biparti). Soit
xun sommet de Get on pose :
U={y∈V(G):d(x,y) est paire} et V={z∈V(G):d(x,z) est impaire}
S’il existe y1,y2∈Utel que y1y2∈E(G), alors on a :
W1=<x,..., y1>est une chaîne de longueur paire =2k1
W2=<x,..., y2>est une chaîne de longueur paire =2k2
=⇒ W3=<x,..., y1,y2,..., x>est un cycle de longueur impaire =2k1+2k2+1/exclamati⌢n-triangle
Donc G=U˙∪Vest un graphe biparti.
Exercice 2.2
Vérifier si le graphe maison est un graphe biparti. Faire de même pour la grille G4,4.
maison grille
2.2 Graphe connexe, eulérien, hamiltonien
Définition 2.2: Graphe connexe
Un graphe est dit connexe si deux points peuvent toujours être joints par une chaîne, i.e.
∀x,y∈V(G),d(x,y)< ∞
— Une composante connexe d’un graphe est un sous-graphe induit maximal connexe.
— Un point d’articulation d’un graphe est un sommet dont la suppression augmente le nombre de
composantes connexes.
Par exemple, le graphe suivant :14 Chapitre 2. La connexité
a
 b
d
 c
e
f
 g
n’est pas connexe car il n’existe pas de chaîne entre les sommets aete. On a donc 2 composantes connexes. En
revanche, le sous-graphe induit par les sommets { a,b,c,d} est connexe dont aest le seul point d’articulation.
Remarque 5.
1. Un graphe connexe à n sommets possède au moins n −1arêtes ( faite une preuve par récurrence ).
2. L’algorithme de parcours en profondeur permet de déterminer si un graphe est connexe ou non.
3. Même définitions dans un graphe orienté . Graphe orienté (fortement) connexe et de composante connexe .
Définition 2.3: Graphe eulérien
— Une chaîne joignant deux sommets xetyest dite chaîne eulérienne si elle emprunte chaque arête
deGune et une seule fois. On parle de chemin eulérien dans le cas d’un graphe orienté.
— Un cycle eulérien est une chaîne eulérienne dont les extrémités coïncident. Un graphe qui admet
un cycle (resp. circuit) eulérien est dit graphe eulérien .
/flushedRemarquer qu’un cycle eulérien n’est pas forcément un cycle comme définit dans la définition 2.1
Si un graphe (ou multigraphe) Gpossède une chaîne eulérienne, alors soit Gpossède deux sommets impairs, le
début et la fin de cette chaîne, soit Gn’a aucun sommet impair, et la promenade d’Euler commence et se termine
au même point (cycle eulérien). Une autre condition nécessaire évidente est que Gdoit être connexe. Ces deux
conditions sont ensemble suffisantes.
Théorème 2.3 Euler
Soit Gun graphe (multigraphe) connexe.
— Si Gn’a pas de sommets impairs, alors il possède un cycle eulérien (commençant à n’importe quel
point).
i.e.∀x,d(x)≡0 mod 2 =⇒ Gest un graphe eulérien.
— Si Ga deux sommets impairs, alors il possède une chaîne eulérienne dont le début et la fin sont les
sommets impairs.
La réciproque est aussi vraie.
Preuve.
⇐On commence par la réciproque. S’il existe une chaîne eulérienne µ(x,y), alors on peut crée une arête fictive
e=(y,x) et par la suite on obtient un cycle eulérien. Donc il suffit de montrer que si Gadmet un cycle
eulérien alors tous les sommets sont de degré pair.
Soit W=< v1,v2,..., vn,v1>un cycle eulérien. Soit le sommet vjavec j̸=1, il est donc claire que chaque
fois vjapparaît dans W, il ya deux arcs distincts incidents en vj( (•,vj) et ( vj,•)). Comme toutes les arêtes
sont utilisées, on voit que d(vj) est pair. Même chose pour v1car on ajoute deux arcs ( v1,v2) et ( v1,vn).
⇒On suppose que tous les sommets sont de degré pair. Montrons que Gadmet un cycle eulérien. Puisque
tous les sommets sont de degré pair on peut construire d’abord une chaîne simple fermée (quelconque)
W1=<v1,v2,..., vk,v1>
SiW1contient chaque arête de G, alors c’est finis, c’est un cycle eulérien. Sinon (puisque Gest connexe), il
existe une arête e=(vi,c) qui n’est pas dans W1(avec visommet de W1). On pose le sous-graphe
G′=G−{ arêtes de W1}H. SABRI 15
Il est donc claire que les sommets de G′sont aussi de degré pair. Alors, par la même procédure on construit
une chaîne simple fermée dans G′de la forme : <vi,c,d,..., vi>et par la suite on insère cette chaîne dans
W1pour obtenir :
W2=<v1,v2,..., vi,c,d,..., vi,vi+1,..., vk,v1>
Sil(W2)< |E(G)|, on construit W3de longueur plus grand. Ainsi, on a :
l(W1)<l(W2)<l(W3)< ··· ≤ | E(G)|
Donc, nécessairement, il existe Wk(chaîne simple fermée de longueur |E(G)|) donc c’est un cycle eulérien.
Finalement , si∃a,b∈V(G):d(a)≡d(b)≡1 mod 2, et tous les autres sommets sont de degré pair, alors on
pose :
G′=G+{a,b}
et donc tous les sommets de G′sont de degré pair. Avec la construction précédente, il existe un cycle eulérien
dans G′:
W=<a,b,v1,..., a>
est donc la chaîne <b,v2,..., a>est une chaîne eulérienne dans G.
Algorithme 1 : Euler
Entrées : Gun graphe eulérien
Output : Un cycle eulérien W
/* On suppose que G est eulérien, i.e. les sommets sont de degré pair */
1Gaux←G;W←µ(v,v) une chaîne simple (quelconque) de G; // Initialisation
2tant que l(W)<e(G)faire
3 Gaux←G−{ arêtes de W} ;
4 Choisir ( x,c)∈E(Gaux) tel que x∈W;
5 L←< x,c,..., x>une chaîne simple de Gaux ;
6 Dans W, remplacer (juste ce) xpar la séquence L;
7fin
8retourner W;
Exercice 2.3
1. Montrer que le graphe de l’exercice 2.1 est un graphe eulérien et donner un cycle eulérien.
2. Tracer cette maison d’un seul trait.
Remarque 6. Le théorème d’Euler dans un graphe orienté connexe s’écrit :
Admet un circuit eulérien si, et seulement si, pour tout sommet, le degré entrant est égal au degré sortant.
∀v∈V(G),d+(v)=d−(v)
Admet un chemin eulérien de a vers b si, et seulement si,


d+(v)=d−(v) ;∀v̸=a,b,
d−(a)=d+(a)−1
d−(b)=d+(b)+116 Chapitre 2. La connexité
Définition 2.4: Graphe hamiltonien
Soit Gun graphe connexe d’ordre n. On appelle :
1. On appelle cycle hamiltonien deGun cycle passant (une et une seule fois) par chacun des sommets
deG. Un graphe est dit hamiltonien s’il possède un cycle hamiltonien.
2. Une chaîne hamiltonienne est une chaîne passant une et une seule fois par chacun des sommets de
G. Un graphe ne possédant que des chaînes hamiltoniennes est semi-hamiltonien .
3. Dans un digraphe, on change cycle par circuit et chaîne par chemin .
Remarque 7.
— Une chaîne hamiltonienne est une chaîne élémentaire de longueur n −1.
— Un graphe peut être eulérien, hamiltonien, les deux à la fois, ou aucun des deux.
— De nombreux problèmes concrets peuvent être formulés en termes de recherche de parcours hamiltoniens : pro-
blème du voyageur de commerce (chercher un cycle hamiltonien de longueur totale minimale), l’ ordonancement
de tâches .
— Le problème du chaîne hamiltonienne est un problème NP-complet .
Exercice 2.4
Donner un graphe (connexe, simple) qui soit :
1. hamiltonien et eulérien.
2. hamiltonien et non eulérien.
3. eulérien et non hamiltonien.
4. non hamiltonien et non eulérien.
Aucune condition nécessaire et suffisante adéquate n’est connue pour l’existence de cycles hamiltoniens. Le
résultat suivant constitue une condition suffisante utile.
Théorème 2.4 Ore
Soit Gun graphe simple d’ordre n≥3. Si pour toute paire { x,y} de sommets non adjacents, on a d(x)+d(y)≥
n, alors Gest hamiltonien.
Preuve. On suppose que le théorème est faux. Alors, il existe un graphe Gsimple d’ordre nnon hamiltonien tel que
d(u)+d(v)≥npour tout sommets non adjacents uetv. On prend Gun tel graphe d’ordre nde taille maximale qui
vérifie cette propriété (remarquer que le graphe complet Knest hamiltonien).
Soient uetvdeux sommets non adjacents de G. Par maximalité de G, le graphe G+uv(d’ordre n) doit être
hamiltonien. Donc il existe dans G+uvun cycle hamiltonien :
W=<u,x1,x2,..., xn−2,v,u>
u
x1
xi xi+1xn−2
v
... ...
Or, si uxi+1∈E(G) etv xi∈E(G) (les arcs en rouge), alors on peut construire dans Gle cycle hamiltonien :
<u,x1,x2,..., xi,v,xn−2,..., xi+1,u>H. SABRI 17
Ceci est absurde car Gest non hamiltonien. Donc si xi+1est un sommet voisin à u, alors le sommet xin’est pas
voisin de v:
xi+1∈Γ(u)=⇒ xi∉Γ(v)
Donc :
d(u)= |Γ(u)| =p=⇒ d(v)≤(n−1)−p
et par la suite
d(u)+d(v)≤n−1
ce qui absurde par hypothèse. Donc Gest hamiltonien.
Une conséquence immédiate est le théorème de Dirac :
Proposition 2.1 Dirac
Soit Gun graphe simple d’ordre n≥3. Si pour tout sommet xdeG, on a d(x)≥n
2, alors Gest hamiltonien.
2.3 Arbres
Définition 2.5: Arbres et forêts
On appelle arbre tout graphe (non orienté) connexe et acyclique . Les composantes connexes dans un
graphe acyclique sont des arbres et le graphe est dit forêt . Une feuille ou sommet pendant est un som-
met de degré 1.
Un forêt avec deux arbres
Un graphe Gest une arborescence s’il existe un sommet Rappelé racine deGtel que, pour tout sommet
SdeG, il existe un chemin et un seul de Rvers S. Donc, c’est un arbre orienté dans lequel on choisit un
sommet Rcomme racine et on dirige les arcs vers le sens sortant de la racine.
Remarque 8.
— Un graphe G d’ordre n est un arbre ssi G est sans cycle et possède n −1arêtes.
— Un graphe G d’ordre n est un arbre ssi G est connexe et possède n −1arêtes.
— G est un arbre si pour chaque paire u ,v de sommets distincts est reliée par une seule chaîne (donc chaîne
élémentaire d’après le théorème 2.1).
— Un arbre (ou forêt) est nécessairement un graphe simple.
Pour démontrer les remarques précédentes, il suffit de prouver le théorème suivant :
Théorème 2.5
Soit Gun graphe ayant marêtes, nsommets et pcomposantes connexes, on définit nu( G) :
ν(G)=m−n+p
Alors, on a :
1.ν(G)≥0.
2.ν(G)=0⇐⇒ Gest acyclique.18 Chapitre 2. La connexité
Preuve. Par récurrence sur la taille mdu graphe. Le résultat est évident pour m=0 et m=1. On suppose le résultat
est vrai pour les graphe de taille m, et montrons que ceci est vrai pour un graphe de taille m+1. Soit donc Gun
graphe d’ordre nde taille m+1 ayant pcomposantes connexes.
•On suppose que Gest un graphe acyclique. Soit uvune arête de Gdans la composante C. Si on supprime uv,
la composante Cse transforme en deux composantes connexes (sinon on a un cycle dans G). Par la suite,
le graphe G′=G−uvest un graphe acyclique d’ordre n, de taille met ayant p+1 composantes connexes.
Donc d’après l’hypothèse de récurrence :
ν(G′)=0=(m−1)−n+(p+1)=m−n+p=ν(G)
•Maintenant, si Gcontient un cycle Wdans la composante connexe C. Soit uvune arête de W, alors si on
supprime l’arête uv, la composante Creste connexe. Donc le graphe G′=G−uvest un graphe d’ordre nde
taille m−1 ayant pcomposantes connexes. Donc, d’après l’hypothèse de récurrence :
ν(G′)=(m−1)−n−p≥0
=⇒ν(G)=m−n−p≥1>0
D’où le résultat – car si ν(G)=0,Gne peut être que acyclique, sinon 0 =ν(G)≥1/exclamati⌢n-triangle
2.3.1 Codage et décodage d’un arbre – Prüfer code
Soit Tun arbre ayant nsommet numérotés {1,2,..., n}. Le codage de Prüfer représente l’arbre Tarbre de avec
une suite P=(x1,x2,x3,..., xn−2) de n−2 termes (les n° des sommets avec répétition possible). Une suite Pdonnée
correspond à un et un seul arbre numéroté. Voici les algorithmes de codage et de décodage.
Algorithme 2 : Codage de Prüfer
Entrées : Un arbre T
Output : Séquence de Prüfer P
1P←() ; // Initialisation de P comme séquence vide
2tant que v(T)>2faire
3 x←feuille de Tayant le n° minimum ; // donc d(x)=1
4 P←(P,s) où sest le seul (n°) sommet adjacent à x;
5 T←T−x;
6fin
7retourner P;
Example 2.2
Donner le code de Prüfer de l’arbre :
126 345
Indice : on trouve, P=(2,3,3,2)
Pour faire la réciproque, étant donnée une séquence P=(x1,x2,..., xn−2) où les xi∈{1,2,..., n}, on construit
l’arbre Tdont les sommets sont {1,2,..., n} avec l’algorithme suivant (le décodage) :H. SABRI 19
Algorithme 3 : Décodage de Prüfer
Entrées : Une séquence Pde taille n−2
Output : L ’arbre Tcorrespondante
1I←{1,2,..., n};
2T←graphe tel que V(T)=IetE(T)= ; ; // T graphe à n sommets isolés
3tant que P̸=()faire
4 i←min {x∈I:x∉P};
5 T←T+(i,P[1]) ; // ajouter l'arc (i,P[1])
6 P←P−P[1];I←I−{i};
7fin
8T←T+(a,b) ; // a,b sont les deux éléments restant dans I
9retourner T;
Example 2.3
Donner l’arbre dont le code de Prüfer est : P=(2,3,3,3)
Puisqu’il ya une bijection entre les arbres d’ordre net les suites Pde longueur n−2 à coefficients dans {1,2,..., n},
on déduit le théorème de Cayley :
Théorème 2.6 Formule de Cayley
Le nombre d’arbres que l’on peut construire sur n(n≥2) sommets numérotés est égal à nn−2.
2.3.2 Arbre couvrant de poids minimum – ACM
Soit Gun graphe (non orienté). Un arbre couvrant (spanning tree) TdeGest un sous graphe couvrant de G
tel que Test un arbre. Remarquer que, Gdoit être connexe, sinon un arbre couvrant de Gn’existe pas. Le nombre
des arbres couvrant de Gest noté a(G). Remarquer que a(Kn)=nn−2(le nombre de Cayley). Un problème algo-
rithmique classique est de trouver, dans un graphe valué , un arbre couvrant de poids minimal . On dispose de
plusieurs algorithmes (l’algorithme de Prim, l’algorithme de Kruskal ...).
Algorithme 4 : Kruskal
Entrées : Un graphe Gvalué d’ordre net de taille m
Output : Arbre (ou forêt) couvrant de poids minimum
1Numéroter les arêtes de Gpar poids minimum : w(e1)≤w(e2)≤ ··· ≤ w(em)
2T←graphe tel que V(T)=V(G) etE(T)= ; ; // T graphe à n sommets isolés
3k←0;
4tant que k<m et e (T)<n−1faire
5 siT+ek+1est acyclique alors
6 T←T+ek+1;
7 k←k+1;
8fin
9retourner T;
Appliquer l’algorithme de Kruskal dans le graphe suivant :
CHAPITRE 3
Les algorithmes de base
Beaucoup de problèmes sur les graphes nécessitent que l’on parcourt l’ensemble des sommets et des arcs. Par
exemple, pour vérifier que le graphe est connexe, chercher un sommet particulier, construire un arbre couvrant,
trouver un plus court chemin ...etc.
3.1 Parcours en profondeur (DFS) / largeur (BFS)
Une manière simple de tester si un graphe Gest connexe ou non est d’exécuter l’algorithme DFS ouBFS dans
Gen commençant par n’importe quel sommet et en enregistrant les sommets visités pendant l’exécution dans une
liste. Si la liste contient tous les sommets de G, alors Gest connexe. Une petite modification permet de donner les
composantes connexes de G. L ’algorithme DFS_Component suivant donne les composantes connexes de G. Il est
donné sous forme d’implémentation récursive.
Algorithme 5 : DFS_Component
Entrées : Un graphe G=(V,E)
Output : Les composantes connexes C=(C1,C2,..., Ck) de G.
1VisitedNodes ← ; ;
2k←0 ; // k est le nombre des composantes connexes
3pour chaque u∈Vfaire
4 siu∉VisitedNodes alors
5 k←k+1;
6 DFS( u);
7 fin
8fin
9retourner (C1,C2,..., Ck);
1Procedure DFS( u )
2 VisitedNodes ←VisitedNodes ∪{u};
3 Ck←Ck∪{u};
4 pour chaque x∈Γ(u)faire
5 six∉VisitedNodes alors
6 DFS( x);
7 fin
8 fin
Note : -
Il est possible de d’implémenter la procédure DFS itérativement à l’aide d’une pile LIFO (stack) contenant les
sommets à explorer : on désempile un sommet et on empile ses voisins non encore explorés.
20H. SABRI 21
Pseudocode :
stack . push ( root )
while stack . isEmpty ( ) = f a l s e do
node = stack . pop ( ) // so mark i t as v i s i t e d
for each x in node . childNodes do
i f x i s not v i s i t e d then
stack . push ( x )
. . .
endfor
endwhile
Example 3.1 (DFS )
Ici on empile (gris) les sommets les plus à droite, alors l’ordre des sommets visité (noir) est ( a,b,d,e,g,c,f).
Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b
 c
d
 e
f
g
a
b
 c
d e
f
ga
b
 c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g
L ’utilisation d’une file (FIFO) au lieu d’une pile transforme l’algorithme du parcours en profondeur en algo-
rithme de parcours en largeur ( BFS ). Avec BFS l’exemple précédent devient (en enfile le plus à gauche) :
Example 3.2 (BFS )
Ici, avec BFS, on enfile (gris) les sommets les plus à gauche d’abord, alors l’ordre des sommets visité (noir)
est ( a,b,d,e,g,c,f). Ici on prend a=root.
a
b c
d e
f
g
a
b c
d e
f
ga
b
 c
d e
f
ga
b
 c
d
 e
f
ga
b c
d
 e
f
g
a
b c
d
 e
f
ga
b c
d e
f
ga
b c
d e
f
ga
b c
d e
f
g22 Chapitre 3. Les algorithmes de base
Exercice 3.1
1. Écrire la procédure BFS .
2. Utiliser DFS (ou BFS) pour la construction d’un arbre couvrant d’un graphe connexe. L ’appliquer
pour le graphe triangle.
3. Utiliser DFS pour écrire une procédure DFS_Cycle pour détecter un cycle dans un graphe.
On sait qu’un graphe orienté G=(V,E) est fortement connexe si pour chaque paire de sommets u,v∈V, il
existe un chemin de uàvet il existe un chemin de vàu. En d’autres termes, nous avons besoin d’une connectivité
dans les deux directions .
Une procédure pour tester si un graphe orienté est fortement connexe ou non peut être conçue avec l’idée
suivante. En partant d’un sommet arbitraire vdu graphe G, on exécute l’algorithme BFS ouDFS et l’on note les
sommets visités. Ensuite, on obtient la transposée de G,GT, en inversant la direction des arêtes de G, et l’on
exécute à nouveau l’algorithme BFS ou DFS à partir du sommet v. Si les sommets visités dans les deux cas sont
égaux à V, alors le graphe orienté est fortement connexe. Cette méthode est illustrée dans l’algorithme 6.
Algorithme 6 : Fortement_connexe
Entrées : Un graphe orienté G=(V,E)
Output : true siGest fortement connexe et false sinon
1X← ; ;
2Y← ; ;
3v←un sommet quelconque de V;
4X←DFS( G,v) ; // Enregistrez les sommets visités dans X
5GT←Gavec flèches inversées;
6Y←DFS( GT,v);
7siX=Y=Valors
8 retourner TRUE.
9sinon
10 retourner FALSE.
11fin
3.2 Recherche des chemins
3.2.1 Matrice d’adjacence et nombre de chemins
La puissance de la matrice d’adjacence Amontre qu’il y a des chemins (ou chaînes) de longueur kallant de xà
ycomme le montre le théorème suivant.
Théorème 3.1
Soit G=(V,E) un (di)graphe. On note V={1,2,..., n} et Asa matrice d’adjacence et Akla puissance k-ème
deA. Alors le terme d’indices i,jdeAkest le nombre de chemins (chaînes) de longueur kallant de iàj.
Preuve. Par récurrence sur k. Pour k=1 c’est clair. On suppose le résultat est vrai à l’ordre ket montrons qu’elle
est vrai pour k+1. Soit S=(si,j)=Ak. Si on a un chemin de iàjde longueur k+1, alors on va d’abord de ià un
sommet ravec kpas et puis de ràj. Or d’après l’hypothèse de récurrence on a si,rchemins possibles pour aller de
iàret finalement ar,jpas (1 ou 0) pour aller de ràj. Ainsi, le nombre totale possibles (i.e. tous les sommets r) est :
nX
r=1si,rar,j=³
Ak×A´
i,jH. SABRI 23
ce qui est bien le terme ( i,j) de la matrice Ak+1.
3.2.2 Plus court chemin et l’algorithme de Dijkstra
Dans cette partie on suppose que le (di)graphe G=(V,E,w) est valué positivement (i.e.∀e∈E,w(e)>0). Notre
objectif est de chercher un plus court chemin (i.e., un chemin de poids minimal ) d’un sommet ufixé à un sommet
quelconque de G.
Il est clair que l’on peut restreindre ce problème au cas d’un (di)graphe simple1. On suppose aussi que Gest
connexe (sinon, certains trajets sont impossibles). Il est aussi claire (d’après théorème 2.1), qu’un plus court chemin
est nécessairement un chemin élémentaire (path).
L ’algorithme de Dijkstra (1959) permet de calculer le plus court chemin entre un sommet particulier u(racine )
et tous les autres sommets. L ’algorithme fonctionne de la manière suivante :
Pour tout sommet vdeG, on associe une valeur T(v), initialisée à w(u,v) et une liste de sommets C(v) qui
correspond à un chemin de uàv. À la fin de l’algorithme, T(v) contient le poids minimal des chemins joignant uà
v(ou T(v)= ∞ siu↛v) et la liste C(v) réalise un tel chemin. Voici donc l’algorithme de Dijkstra :
Algorithme 7 : Algorithme de Dijkstra
Entrées : Un (di)graphe valué G=(V,E,w) et un sommet racine u
Output : Le coût minimum d’un chemin de uàv(∀v∈V) et un trajet pour chaque coût minimal obtenu
1∀v∈V,T(v)←w(u,v) etC(v)←(u,v); // Initialisation de T(v) et la liste C(v)
2X←{u};
3tant que X̸=Vfaire
4 Choisir v∈V−Xtel que ∀y∈V−X,T(v)≤T(y);
5 X←X∪{v};
6 pour chaque y∈V−Xfaire // Faire les mises à jours pour les autres sommets
7 siT(y)>T(v)+w(v,y)alors
8 T(y)←T(v)+w(v,y);
9 C(y)←[C(v),y]; // On ajoute à la liste C(v) l'élément y
10
11 fin
12 fin
13fin
Example 3.3
Voici une application de l’algorithme de Dijkstra au digraphe suivant. On prend Ecomme sommet racine.
EA
B
CD
FG
S5
4
21
12
2
34
4
215
7
1. En effet, passer par une boucle ne ferait qu’augmenter inutilement le poids de ce chemin. De même, si plusieurs arcs joignent deux
sommets, il suffit de conserver l’arc de poids minimal.24 Chapitre 3. Les algorithmes de base
Ainsi, pour l’initialisation, on a : X={E} et on a les valeurs :
v  E A B C D F G S
T(v) 0 5 4 2 ∞ ∞ ∞ ∞
C(v)(E,E) ( E,A) ( E,B) ( E,C) ( E,D) ( E,F) ( E,G) ( E,S)
Maintenant, on choisit (un seul choix) le sommet C, donc X={E,C}. Le tableau est mis à jour :
v  E A B  C D F G S
T(v) 0 5 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À l’étape suivante, on est forcé de choisir B. Ainsi, X={E,C,B} et la mise à jour est :
v  E A  B  C D F G S
T(v) 0 4 3 2 ∞ 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,D) ( E,C,F) ( E,C,G) ( E,S)
À présent, on a le choix entre AetF. On choisit A. Donc X={E,C,B,A} et on a :
v  E  A  B  C D F G S
T(v) 0 4 3 2 6 4 5 ∞
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,B,A,D) ( E,C,F) ( E,C,G) ( E,S)
Puis, on prend le sommet F. D’où X={E,C,B,A,F} et :
v  E  A  B  C D  F G S
T(v) 0 4 3 2 5 4 5 11
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,S)
On prend Det on obtient X={E,C,B,A,F,D} et :
v  E  A  B  C  D  F G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Finalement, on prend Gpuis Set on voit que ceci ne change rien. D’où le tableau finale :
v  E  A  B  C  D  F  G S
T(v) 0 4 3 2 5 4 5 10
C(v)(E,E) ( E,C,B,A) ( E,C,B) ( E,C) ( E,C,F,D) ( E,C,F) ( E,C,G) ( E,C,F,D,S)
Ainsi le chemin minimum pour aller de EàSest de coût 10 et un trajet de coût minimal de EàSest : EC F DS .H. SABRI 25
3.3 Problèmes d’ordonnancement et chemin critique
Un problème d’ordonnancement peut-être représenté sous la forme d’un digraphe. Les sommets sont des évé-
nements (début et fin de la tâche) et les arcs des tâches, La longueur (ou poids) de chaque arc représente la durée
d’exécution de la tâche. Ainsi, la tâche correspondant à l’arc ( i,j) ne peut commencer que si toutes les tâches cor-
respondant à des arcs ( k,i) ont été complétées. On ajoute deux sommets pour le début (s) et de fin(t) du projet .
Le digraphe peut contenir des tâches fictives dedurée nulle afin de forcer certaines précédences (postériorité).
Ainsi, un réseau PERT est un digraphe valué G=(V,E,w,s,t) où la fonction poids (ou longueur) w:E→R+
etsle sommet source (début) et tle sommet puits (fin). Un chemin critique est un chemin de sàtdelongueur
maximale . S’il n’existe pas de chemin critique, le projet n’est pas réalisable (e.g. un circuit). Le temps minimal
requis pour l’exécution d’un projet réalisable est égal à la longueur d’un chemin critique. Les tâches figurant sur un
chemin critique sont aussi appelées critiques, ce qui s’explique par le fait que tout retard d’exécution d’une tâche
critique retarde d’autant l’exécution du projet.
3.3.1 Algorithmes de tri topologique et de chemin critique
Il faut d’abord numérotés les sommets de 1 à nde manière compatible au pré-ordre (rang) avec l’algorithme du
rang suivant (tri topologique) :
Algorithme 8 : Algorithme du rang
Entrées : Un digraphe G=(V,E) sans circuit
Output : Le rang r(v) de chaque sommet v∈Vde G
1r←0;X←V;
2R←{v∈X:Γ−
X(v)= ;} ; // l'ensemble des sommets de X sans prédécesseur dans X
3tant que X̸= ; faire
4 r(v)←rpour chaque sommet v∈R;
5 X←X−R;
6 R←l’ensemble des sommets de Xsans prédécesseur dans X;
7 r←r+1;
8fin
On supposera dorénavant que les sommets ont déjà été numérotés de 1 à nde manière compatible avec leurs
rangs, c’est-à-dire que r(j)>r(i) implique j>i(donc 1 =setn=t). Enfin, on supposera éliminés les arcs paral-
lèles par l’introduction de tâches fictives de durée nulle .
Pour un sommet i, on note tiledébut au plus tôt des tâches correspondant aux arcs i→jet par Tilafin au
plus tard des tâches correspondant aux arcs j→i.
Algorithme 9 : Algorithme du chemin critique
Entrées : Un digraphe G=(V,E) sans circuit trié topologiquement
Output : La durée du chemin critique et les dates ti,Ti
1t1←0;
2pour j=2···nfaire // Calcul des dates de début au plus tôt  récurrence en avançant
3 tj←max i∈Γ−(j){ti+w(i,j)}
4fin
5Tn←tn;
6pour j=n−1···1faire // Calcul des dates de fin au plus tard  récurrence en reculant
7 Tj←min i∈Γ+(j){Ti−w(j,i)}
8fin26 Chapitre 3. Les algorithmes de base
Définition 3.1
— Un sommet iest critique si ti=Ti.
— Un arc ( i,j) est critique les sommets ietjsont critiques ettj−ti=w(i,j).
— Un chemin critique est un chemin de 1 à nn’utilisant que des arcs critiques.
— La durée du chemin critique est donnée par Tn(ou par tn). Elle correspond à la durée minimale du
projet .
Example 3.4
L ’application de l’algorithme du chemin critique au digraphe suivant (trié topologiquement) est :
1 23
45
6B
9A
3
C
5D
8
E
4
F7G
20
H6I5
=⇒
 1
0,02
9,933,16
4
16,23513,24
6
29,29B
9A
3
C
5D
8
E
4
F7G
20
H6I5
Les tâches critiques sont BetG. La durée totale minimale du projet est donc 29.
Exercice 3.2
Les tâches ( durée et précédences ) pour la construction d’un entrepôt sont données dans le tableau suivant :
Tâches Nature Précédences Durée (jours)
A Acceptation des plans par le propriétaire – 4
B Préparation du terrain – 2
C Commande des matériaux A 1
D Creusage des fondations A, B 1
E Commande des portes et fenêtres A 2
F Livraison des matériaux C 2
G Coulage des fondations D, F 2
H Livraison des portes et fenêtres E 10
I Pose des murs, de la charpente et du toit G 4
J Mise en place des portes et fenêtres H, I 1
1. Représentez le graphe des précédences de ce projet (trié topologiquement).
2. Déterminez une durée totale minimale en exhibant un chemin critique dans ce graphe.CHAPITRE 4
Programmation linéaire
La programmation linéaire est le processus de minimiser ou maximiser une fonction objective linéaire sou-
mise à un nombre fini de contraintes d’égalités et d’inégalités linéaires.
La programmation linéaire a de nombreuses applications dans le domaine de l’informatique théorique. Elle
peut être utilisée pour résoudre de nombreux problèmes combinatoires variés, tels que la recherche de flot maxi-
mum dans un réseau, la recherche d’un couplage maximal dans un graphe et la coloration d’un graphe parfait.
Example 4.1 (Problème de régime)
On suppose qu’on a quatre plats : de la truite ( XT), un sandwich au corned-beef ( XC B), un burrito ( XBU R )
et un hamburger ( XHB). Le tableau suivant répertorie la valeur nutritionnelle de chaque plat (vitamines et
calories) et notre besoin journalier des vitamines.
Vit. A Vit. C Vit. D Calories
Truite 203 92 100 600
Corned-beef 90 84 230 350
Burrito 270 80 512 250
Humburger 500 90 210 500
Besoins 2000 300 430
Notre objectif est de minimiser le nombre total de calories consommées : 600 XT+350XC B+250XBU R+
500XHBtout en satisfaisant les trois besoins nutritionnels en vitamines. Le programme linéaire résultant
s’écrit :
min 600 XT+350XC B+250XBU R+500XHB
s.t. 203 XT+90XC B+270XBU R+500XHB≥2000, (Besoins de Vit. A),
92XT+84XC B+80XBU R+90XHB≥300, (Besoins de Vit. C),
100XT+230XC B+512XBU R+210XHB≥430, (Besoins de Vit. D),
XT,XC B,XBU R ,XHB≥0
Définition 4.1: Forme canonique – Forme standard
On peut écrire un P .L. sous deux formes spéciales :
•Canonique
max
mincTX+c0
s.t. AX≤b(≥bsi min),
X≥0•Standard
max cTX+c0
s.t. AX=b,
X≥0Avec :
cTX=¡
c1··· cn¢
x1
...
xn

cTX+c0=c1x1+c2x2+···+ cnxn+c0
2728 Chapitre 4. Programmation linéaire
Remarque 9. Un P .L. général peut être formulé selon une forme standard ou canonique par la méthode suivante :
générale =⇒ standard il faut éliminer les contraintes d’inégalité et les variables sans contrainte de positivité.
— Si dT
iX≤biest une contrainte d’inégalité, alors créer une nouvelle variable ( d’écart ) siet remplacer l’in-
égalité dT
iX≤bipar dT
iX+si=biet s i≥0.
Si dT
iX≥bi, alors on peut écrire dT
iX−si=biet s i≥0.
— Si une variable x i≶0est de signe quelconque, alors créez deux nouvelles variables x+
iet x−
iet remplacez
xipartout par x+
i−x−
i, et ajoutez les contraintes de signe : x+
i≥0,x−
i≥0.
générale =⇒ canonique
— Si dT
iX=biest une contrainte d’égalité, alors remplacer cette égalité par une paire d’inégalités :
dT
iX≥biet−dT
iX≥ −bi
— Même chose que précédemment si la variable x i≶0.
Il est facile de voir que les problèmes qui en résultent sont équivalents aux problème d’origine. Pour l’algorithme
simplexe , nous utiliserons la forme standard .
On remarque aussi qu’en utilisant la relation min f(x)= − max¡
−f(x)¢
dans laquelle f (x)représente la fonction-
nelle linéaire à optimiser, on peut toujours se ramener à un problème de minimisation (ou de maximisation).
Example 4.2
Le P .L :max 5 x+4y
s.t. x≤6
1
4x+y≤6
3x+2y≤22
x,y≥0s’écrit sous forme standard :max 5 x1+4x2
s.t. x1+e1=6
1
4x1+x2+e2=6
3x1+2x2+e3=22
x1,x2,e1,e2,e3≥0
Donc (sous la forme matricielle) on a :
cT=¡
5 4 0 0 0¢
;A=
1 0 1 0 0
1
41 0 1 0
3 2 0 0 1
;X=
x1
x2
e1
e2
e3
et b=
6
6
22

4.1 La méthode simplexe
4.1.1 Solution de base admissible
On suppose que la matrice Adu programme linéaire est de type m×netde rang m(pourquoi !). Soit Bla
matrice carrée extraite de Aformée par les mcolonnes j1,j2,..., jmlinéairement indépendants de A(les vecteurs
de base). Alors, Best une matrice inversible. Ainsi si on pose xl=0 sil∉{j1,..., jm} etxjklak-ième composante de
B−1b. Alors, on a AX B=b. Si de plus XB≥0(i.e. chaque xi≥0), alors :
Xest une solution de base admissible (ou réalisable)
Dans l’exemple 4.2, la matrice extraite B=
1 0 0
0 1 0
0 0 1
est inversible et B−1b=
6
6
22
. Donc XB=
0
0
6
6
22
≥0, par suite
XBest une solution de base admissible. On appelle les variables xjklesvariables de base . Les autres variables xl
sont les variables hors-base .
Parfois, il n’est pas évident de trouver une solution de base admissible, comme le montre l’exercice suivant :H. SABRI 29
Exercice 4.1
Écrire le programme linéaire suivant sous forme standard et montrer qu’on n’a pas une solution de base
admissible. Résoudre le programme linéaire.
max −x+y
s.t. x+y≥1,
3x+2y=6,
x,y≥0
4.1.2 L ’algorithme du simplexe avec la méthode des tableaux
Dans cette section, on suppose qu’on a déjà trouvé une solution de base admissible X(produite avec B=Im)
du programme linéaire ( P: max z=cTX+c0etb≥0pour garantir que 0est une solution de AX≤b).
La méthode du simplexe est une méthode itérative qui génère une séquence de solutions de base réalisable
(correspondant à différentes bases) et s’arrête finalement lorsqu’elle a trouvé une solution de base réalisable opti-
male. Remarquer qu’on peut toujours prendre c0=0.
Algorithme 10 : Algorithme du simplexe
Entrées : Un P .L. standard P(max) avec une solution de base réalisable
Output : La solution optimale (ou non)
1On commence à écrire le tableau initiale (avec les variables de base xj1,..., xjm)
VB x1 ... xn b
xj1 b1
... A...
xjm bm
c1 ... cn−c0
2Sicj≤0 (∀j:xjest hors base), alors solution optimale (STOP) // min ⇝cj≥0
3Trouver la colonne s(hors base) tel que cs=max©
cj:cj>0ª// min ⇝cs=min©
cj:cj<0ª
4Siai,s≤0∀i=1... m, alors pas de solution optimale (STOP)
5Min Ratio Test : trouver la ligne rtel que
br
ar,s=min
i=1...m½bi
ai,s:ai,s>0¾
6Appliquer la procédure de Gauss autour de pivot ar,s(ar,s⇝1 et on annule les coefficients situés sous et
sur le pivot dans la colonne s, par combinaisons de lignes) // Ne pas oublier la dernière ligne
7Remplacer (dans VB) la variable de base ( sortante ) située à la ligne rpar la variable ( entrante )xs
8Retourner à l’étape 2 // l'algorithme termine si le programme linéaire est non dégénéré
Remarque 10.
— La dernière ligne représente l’équation linéaire −z+c1x1+···+ cnxn= −c0.
— La valeur de la variable de base de V Bde la ligne k est égale à la valeur b k(de la ligne k).
— La solution optimale du problème est la valeur finale (dernière cellule) (×− 1).
— Si on n’a pas au départ B =Im(à l’aide des variables d’écart) alors, on ajoute les variables artificielles (et on
applique d’abord la phase I - voir section suivante).30 Chapitre 4. Programmation linéaire
Exercice 4.2
Soit le programme linéaire :
max 2 x1+x2
s.t. x1−x2≤3,
x1+2x2≤6,
−x1+2x2≤2,
x1,x2≥0
Rajouter les variables d’écart. Puis résoudre le problème par l’algorithme du simplexe.
Remarque 11. Vérifier le résultat de l’exercice précédent, par la méthode graphique.
4.1.3 Initialisation - Phase I du simplexe
Un programme linéaire est dit sous forme simpliciale si la matrice Acontient la matrice identité Imcomme
sous matrice. On suppose que le programme linéaire P, après la mise en forme AX=b, n’est pas simpliciale
(possible dans le cas de contraintes du type ≥ou du type =). Soit Bune matrice d’ordre mextraite de Ainversible
tel que B−1b≥0et soit XBla solution de base réalisable ( XB≥0etAX B=b), alors on peut changer l’équation
matricielle :
AX B=b
⇐⇒ (B−1A)XB=B−1b
⇐⇒ A∗XB=b∗
et la matrice A∗contient la matrice identité Imcomme matrice extraite ( B−1A=B−1(H|B)=¡
B−1H|Im¢
). Ainsi, on
peut appliquer directement l’algorithme 10 en remplaçant Apar A∗etbpar b∗. Cependant, cette méthode n’est
pas efficace, car il faut trouver une matrice extraite Bréalisable correspondante. Pour une matrice Ade type m×n,
il existe¡m
n¢
matrices extraites à tester !
L ’idée est d’ajouter des variables, dites artificielles w1,w2,..., wm, pour faire apparaître une forme simpliciale
du programme linéaire P: (AX=b). Mais, il faut que w1= ··· = wm=0. Donc, il faut minimiser d’abord le pro-
gramme linéaire P0suivant :
P0=min W=w1+···+ wm
s.t. (A|Im)×(x1...xnw1...wm)T=b
x1,..., xn,w1,..., wm ≥0
On exprime Wà l’aide des autres variables (hors base) et puis on applique l’algorithme du simplexe 10 pour P0
(phase I). À la fin, si on trouve que les wi=0, alors les variables de bases xj1,..., xjmforment une première base
admissible pour démarrer le simplexe pour le programme d’origine P.H. SABRI 31
Remarque 12. On ajoute la ligne de Z :c1 ... cn−c0dans le tableau du simplexe de P0(phase I) et on lui
applique les opérations élémentaire comme avec les autres lignes. À la fin de la phase I, on supprime les colonnes des
wiet la ligne de la fonction W . Finalement, on utilise ce tableau pour résoudre le problème initiale P.
Example 4.3
Soit le programme linéaire P:
min 6 x1+3x2
s.t. x1+x2≥1,
2x1−x2≥1,
3x2≤2,
x1,x2≥0sous forme standard (max)= = = = = = = = = = = = = = = = = = ⇒max Z= −6x1−3x2
s.t. x1+x2−e1=1,
2x1−x2−e2=1,
3x2+e3=2,
x1,x2,e1,e2,e3≥0
La matrice Aest :
A=x1 x2 e1 e2 e3

1 1 −1 0 0
2−1 0 −1 0
0 3 0 0 1
est par suite Pn’est pas sous forme simpliciale (il n’ ya pas de sous matrice I3). Donc on peut ajouter 2
variables artificielles pour construire le problème initiale P0:
max −w1−w2=3x1−e1−e2−2
s.t. x1+x2−e1+w1=1,
2x1−x2−e2+w2=1,
3x2+e3=2,
x1,x2,e1,e2,e3,w1,w2≥0dont le vecteur X=

0 x1
0 x2
0 e1
0 e2
2 e3
1 w1
1 w2est une solution de base réalisable.
Ainsi, on commence notre algorithme 10 pour le programme P0. Le tableau initial est :
x1 x2 e1 e2 e3 w1 w2 b

w1 1 1 −1 0 0 1 0 1
w2 2−1 0 −1 0 0 1 1
e3 0 3 0 0 1 0 0 2
W: 3 0 −1−1 0 0 0 2
Z:−6−3 0 0 0 0 0 0
Le pivot c’est a2,1donc x1est la variable entrante et w2est sortante. On obtient après pivotement le tableau :
L2←1
2L2− − − − − − − − →
L1←L1−L2
L4←L4−3L2
L5←L5+6L2x1 x2 e1 e2 e3 w1 w2 b

w1 03
2−11
20 1−1
21
2
x1 1−1
20−1
20 01
21
2
e3 0 3 0 0 1 0 0 2
W: 03
2−11
20 0−3
21
2
Z: 0 −6 0 −3 0 0 3 3
Le pivot est a1,2(Min ratio test =1
3). On obtient alors :32 Chapitre 4. Programmation linéaire
L1←2
3L1− − − − − − − − →
L2←L2+1
2L1
L3←L3−3L1
L4←L4−3
2L1
L5←L5+6L1x1 x2 e1 e2 e3 w1 w2 b


x2 0 1−2
31
302
3−1
31
3
x1 1 0−1
3−1
301
31
32
3
e3 0 0 2 −1 1 −2 1 1
W: 0 0 0 0 0 −1−1 0
Z: 0 0 −4−1 0 4 1 5
Ainsi, la phase I se termine avec W=0 et x1=2
3,x2=1
3,e3=1 et e1=e2=w1=w2=0. Le tableau pour la
phase II est donc :
x1 x2 e1 e2 e3 b


x2 0 1−2
31
301
3
x1 1 0−1
3−1
302
3
e3 0 0 2 −1 1 1
Z: 0 0 −4−1 0 5
On remarque donc que les cj≤0, donc (STOP) la solution est optimale et le max est −5. Ainsi la solution
optimale pour le programme P=min6 x1+3x2est−(−5)=5=6×2
3+3×1
3.
4.2 Dualité
SoitPun P .L. sous forme canonique. Le programme dualDdePest définit par :
P=max z=cTX
s.t. AX ≤ b
X≥ 0le dual est= = = = = = = ⇒D=min w=bTY
s.t. ATY≥ c
Y≥ 0
Le programme Pest dit primal . On remarque que si Ade type m×n, alors X∈RnetY∈Rmpour le dual.
Théorème 4.1 Théorème de dualité
Si un problème primal ou dual admet une solution, alors l’autre problème admet aussi une solution et on a :
max z=cTX =
s.t. AX ≤ b
X≥ 0min w=bTY
s.t. ATY≥ c
Y≥ 0
Exercice 4.3
Soit le problème suivant de type régime :
D=min w=340x1+2400 x2+560x3
s.t. x1+2x2+x3≥ 1200
x1+3x2+2x3≥ 1400
x1+x2+3x3≥ 1500
x1,x2,x3≥ 0
Écrire le programme primal PdeD. Résoudre le programme Pet déduire la valeur minimale de w, a-t-on
besoin de faire les deux phases du simplexe ?
7} A B oS



